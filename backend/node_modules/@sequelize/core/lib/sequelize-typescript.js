"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var sequelize_typescript_exports = {};
__export(sequelize_typescript_exports, {
  SequelizeTypeScript: () => SequelizeTypeScript
});
module.exports = __toCommonJS(sequelize_typescript_exports);
var import_node_async_hooks = require("node:async_hooks");
var import_associations = require("./decorators/legacy/associations.js");
var import_model = require("./decorators/shared/model.js");
var import_hooks_legacy = require("./hooks-legacy.js");
var import_hooks = require("./hooks.js");
var import_model_hooks = require("./model-hooks.js");
var import_model_internals = require("./model-internals.js");
var import_transaction = require("./transaction.js");
const staticSequelizeHooks = new import_hooks.HookHandlerBuilder([
  "beforeInit",
  "afterInit"
]);
const instanceSequelizeHooks = new import_hooks.HookHandlerBuilder([
  "beforeQuery",
  "afterQuery",
  "beforeBulkSync",
  "afterBulkSync",
  "beforeConnect",
  "afterConnect",
  "beforeDisconnect",
  "afterDisconnect",
  "beforeDefine",
  "afterDefine",
  "beforePoolAcquire",
  "afterPoolAcquire",
  ...import_model_hooks.validModelHooks
]);
class SequelizeTypeScript {
  static get hooks() {
    return staticSequelizeHooks.getFor(this);
  }
  static addHook = (0, import_hooks_legacy.legacyBuildAddAnyHook)(staticSequelizeHooks);
  static removeHook = (0, import_hooks_legacy.legacyBuildRemoveHook)(staticSequelizeHooks);
  static hasHook = (0, import_hooks_legacy.legacyBuildHasHook)(staticSequelizeHooks);
  static hasHooks = (0, import_hooks_legacy.legacyBuildHasHook)(staticSequelizeHooks);
  static runHooks = (0, import_hooks_legacy.legacyBuildRunHook)(staticSequelizeHooks);
  static beforeInit = (0, import_hooks_legacy.legacyBuildAddHook)(staticSequelizeHooks, "beforeInit");
  static afterInit = (0, import_hooks_legacy.legacyBuildAddHook)(staticSequelizeHooks, "afterInit");
  get hooks() {
    return instanceSequelizeHooks.getFor(this);
  }
  addHook = (0, import_hooks_legacy.legacyBuildAddAnyHook)(instanceSequelizeHooks);
  removeHook = (0, import_hooks_legacy.legacyBuildRemoveHook)(instanceSequelizeHooks);
  hasHook = (0, import_hooks_legacy.legacyBuildHasHook)(instanceSequelizeHooks);
  hasHooks = (0, import_hooks_legacy.legacyBuildHasHook)(instanceSequelizeHooks);
  runHooks = (0, import_hooks_legacy.legacyBuildRunHook)(instanceSequelizeHooks);
  beforeQuery = (0, import_hooks_legacy.legacyBuildAddHook)(instanceSequelizeHooks, "beforeQuery");
  afterQuery = (0, import_hooks_legacy.legacyBuildAddHook)(instanceSequelizeHooks, "afterQuery");
  beforeBulkSync = (0, import_hooks_legacy.legacyBuildAddHook)(instanceSequelizeHooks, "beforeBulkSync");
  afterBulkSync = (0, import_hooks_legacy.legacyBuildAddHook)(instanceSequelizeHooks, "afterBulkSync");
  beforeConnect = (0, import_hooks_legacy.legacyBuildAddHook)(instanceSequelizeHooks, "beforeConnect");
  afterConnect = (0, import_hooks_legacy.legacyBuildAddHook)(instanceSequelizeHooks, "afterConnect");
  beforeDisconnect = (0, import_hooks_legacy.legacyBuildAddHook)(instanceSequelizeHooks, "beforeDisconnect");
  afterDisconnect = (0, import_hooks_legacy.legacyBuildAddHook)(instanceSequelizeHooks, "afterDisconnect");
  beforeDefine = (0, import_hooks_legacy.legacyBuildAddHook)(instanceSequelizeHooks, "beforeDefine");
  afterDefine = (0, import_hooks_legacy.legacyBuildAddHook)(instanceSequelizeHooks, "afterDefine");
  beforePoolAcquire = (0, import_hooks_legacy.legacyBuildAddHook)(instanceSequelizeHooks, "beforePoolAcquire");
  afterPoolAcquire = (0, import_hooks_legacy.legacyBuildAddHook)(instanceSequelizeHooks, "afterPoolAcquire");
  beforeValidate = (0, import_hooks_legacy.legacyBuildAddHook)(instanceSequelizeHooks, "beforeValidate");
  afterValidate = (0, import_hooks_legacy.legacyBuildAddHook)(instanceSequelizeHooks, "afterValidate");
  validationFailed = (0, import_hooks_legacy.legacyBuildAddHook)(instanceSequelizeHooks, "validationFailed");
  beforeCreate = (0, import_hooks_legacy.legacyBuildAddHook)(instanceSequelizeHooks, "beforeCreate");
  afterCreate = (0, import_hooks_legacy.legacyBuildAddHook)(instanceSequelizeHooks, "afterCreate");
  beforeDestroy = (0, import_hooks_legacy.legacyBuildAddHook)(instanceSequelizeHooks, "beforeDestroy");
  afterDestroy = (0, import_hooks_legacy.legacyBuildAddHook)(instanceSequelizeHooks, "afterDestroy");
  beforeRestore = (0, import_hooks_legacy.legacyBuildAddHook)(instanceSequelizeHooks, "beforeRestore");
  afterRestore = (0, import_hooks_legacy.legacyBuildAddHook)(instanceSequelizeHooks, "afterRestore");
  beforeUpdate = (0, import_hooks_legacy.legacyBuildAddHook)(instanceSequelizeHooks, "beforeUpdate");
  afterUpdate = (0, import_hooks_legacy.legacyBuildAddHook)(instanceSequelizeHooks, "afterUpdate");
  beforeUpsert = (0, import_hooks_legacy.legacyBuildAddHook)(instanceSequelizeHooks, "beforeUpsert");
  afterUpsert = (0, import_hooks_legacy.legacyBuildAddHook)(instanceSequelizeHooks, "afterUpsert");
  beforeSave = (0, import_hooks_legacy.legacyBuildAddHook)(instanceSequelizeHooks, "beforeSave");
  afterSave = (0, import_hooks_legacy.legacyBuildAddHook)(instanceSequelizeHooks, "afterSave");
  beforeBulkCreate = (0, import_hooks_legacy.legacyBuildAddHook)(instanceSequelizeHooks, "beforeBulkCreate");
  afterBulkCreate = (0, import_hooks_legacy.legacyBuildAddHook)(instanceSequelizeHooks, "afterBulkCreate");
  beforeBulkDestroy = (0, import_hooks_legacy.legacyBuildAddHook)(instanceSequelizeHooks, "beforeBulkDestroy");
  afterBulkDestroy = (0, import_hooks_legacy.legacyBuildAddHook)(instanceSequelizeHooks, "afterBulkDestroy");
  beforeBulkRestore = (0, import_hooks_legacy.legacyBuildAddHook)(instanceSequelizeHooks, "beforeBulkRestore");
  afterBulkRestore = (0, import_hooks_legacy.legacyBuildAddHook)(instanceSequelizeHooks, "afterBulkRestore");
  beforeBulkUpdate = (0, import_hooks_legacy.legacyBuildAddHook)(instanceSequelizeHooks, "beforeBulkUpdate");
  afterBulkUpdate = (0, import_hooks_legacy.legacyBuildAddHook)(instanceSequelizeHooks, "afterBulkUpdate");
  beforeCount = (0, import_hooks_legacy.legacyBuildAddHook)(instanceSequelizeHooks, "beforeCount");
  beforeFind = (0, import_hooks_legacy.legacyBuildAddHook)(instanceSequelizeHooks, "beforeFind");
  beforeFindAfterExpandIncludeAll = (0, import_hooks_legacy.legacyBuildAddHook)(instanceSequelizeHooks, "beforeFindAfterExpandIncludeAll");
  beforeFindAfterOptions = (0, import_hooks_legacy.legacyBuildAddHook)(instanceSequelizeHooks, "beforeFindAfterOptions");
  afterFind = (0, import_hooks_legacy.legacyBuildAddHook)(instanceSequelizeHooks, "afterFind");
  beforeSync = (0, import_hooks_legacy.legacyBuildAddHook)(instanceSequelizeHooks, "beforeSync");
  afterSync = (0, import_hooks_legacy.legacyBuildAddHook)(instanceSequelizeHooks, "afterSync");
  beforeAssociate = (0, import_hooks_legacy.legacyBuildAddHook)(instanceSequelizeHooks, "beforeAssociate");
  afterAssociate = (0, import_hooks_legacy.legacyBuildAddHook)(instanceSequelizeHooks, "afterAssociate");
  #transactionCls;
  /**
   * The QueryInterface instance, dialect dependant.
   */
  get queryInterface() {
    return this.dialect.queryInterface;
  }
  /**
   * The QueryGenerator instance, dialect dependant.
   */
  get queryGenerator() {
    return this.dialect.queryGenerator;
  }
  _setupTransactionCls() {
    this.#transactionCls = new import_node_async_hooks.AsyncLocalStorage();
  }
  addModels(models) {
    const registeredModels = models.filter((model) => (0, import_model.initDecoratedModel)(
      model,
      // @ts-expect-error -- remove once this class has been merged back with the Sequelize class
      this
    ));
    for (const model of registeredModels) {
      (0, import_associations.initDecoratedAssociations)(
        model,
        // @ts-expect-error -- remove once this class has been merged back with the Sequelize class
        this
      );
    }
  }
  /**
   * Escape value to be used in raw SQL.
   *
   * If you are using this to use the value in a {@link literal}, consider using {@link sql} instead, which automatically
   * escapes interpolated values.
   *
   * @param value The value to escape
   * @param options
   */
  escape(value, options) {
    return this.dialect.queryGenerator.escape(value, options);
  }
  /**
   * Returns the transaction that is associated to the current asynchronous operation.
   * This method returns undefined if no transaction is active in the current asynchronous operation,
   * or if {@link Options.disableClsTransactions} is true.
   */
  getCurrentClsTransaction() {
    var _a;
    return (_a = this.#transactionCls) == null ? void 0 : _a.getStore();
  }
  async transaction(optionsOrCallback, maybeCallback) {
    let options;
    let callback;
    if (typeof optionsOrCallback === "function") {
      callback = optionsOrCallback;
      options = {};
    } else {
      callback = maybeCallback;
      options = optionsOrCallback;
    }
    if (!callback) {
      throw new Error("sequelize.transaction requires a callback. If you wish to start an unmanaged transaction, please use sequelize.startUnmanagedTransaction instead");
    }
    const nestMode = options.nestMode ?? this.options.defaultTransactionNestMode;
    const normalizedOptions = (0, import_transaction.normalizeTransactionOptions)(this, options);
    if (nestMode === import_transaction.TransactionNestMode.separate) {
      delete normalizedOptions.transaction;
    } else {
      (0, import_model_internals.setTransactionFromCls)(normalizedOptions, this);
      if (normalizedOptions.transaction) {
        (0, import_transaction.assertTransactionIsCompatibleWithOptions)(normalizedOptions.transaction, normalizedOptions);
      }
    }
    const transaction = nestMode === import_transaction.TransactionNestMode.reuse && normalizedOptions.transaction ? normalizedOptions.transaction : new import_transaction.Transaction(
      // @ts-expect-error -- will be fixed once this class has been merged back with the Sequelize class
      this,
      normalizedOptions
    );
    const isReusedTransaction = transaction === normalizedOptions.transaction;
    const wrappedCallback = async () => {
      if (isReusedTransaction) {
        return callback(transaction);
      }
      await transaction.prepareEnvironment();
      let result;
      try {
        result = await callback(transaction);
      } catch (error) {
        try {
          await transaction.rollback();
        } catch {
        }
        throw error;
      }
      await transaction.commit();
      return result;
    };
    const cls = this.#transactionCls;
    if (!cls) {
      return wrappedCallback();
    }
    return cls.run(transaction, wrappedCallback);
  }
  /**
   * We highly recommend using {@link Sequelize#transaction} instead.
   * If you really want to use the manual solution, don't forget to commit or rollback your transaction once you are done with it.
   *
   * Transactions started by this method are not automatically passed to queries. You must pass the transaction object manually,
   * even if {@link Options.disableClsTransactions} is false.
   *
   * @example
   * ```ts
   * try {
   *   const transaction = await sequelize.startUnmanagedTransaction();
   *   const user = await User.findOne(..., { transaction });
   *   await user.update(..., { transaction });
   *   await transaction.commit();
   * } catch(err) {
   *   await transaction.rollback();
   * }
   * ```
   *
   * @param options
   */
  async startUnmanagedTransaction(options) {
    const transaction = new import_transaction.Transaction(
      // @ts-expect-error -- remove once this class has been merged back with the Sequelize class
      this,
      options
    );
    await transaction.prepareEnvironment();
    return transaction;
  }
  /**
   * A slower alternative to {@link truncate} that uses DELETE FROM instead of TRUNCATE,
   * but which works with foreign key constraints in dialects that don't support TRUNCATE CASCADE (postgres),
   * or temporarily disabling foreign key constraints (mysql, mariadb, sqlite).
   *
   * @param options
   */
  async destroyAll(options) {
    const sortedModels = this.modelManager.getModelsTopoSortedByForeignKey();
    const models = sortedModels || this.modelManager.models;
    if (options && "limit" in options) {
      throw new Error("sequelize.destroyAll does not support the limit option.");
    }
    if (options && "truncate" in options) {
      throw new Error("sequelize.destroyAll does not support the truncate option. Use sequelize.truncate instead.");
    }
    for (const model of models) {
      await model.destroy({ ...options, where: {} });
    }
  }
  /**
   * Truncate all models registered in this instance.
   * This is done by calling {@link Model.truncate} on each model.
   *
   * @param options The options passed to {@link Model.truncate}, plus "withoutForeignKeyChecks".
   */
  async truncate(options) {
    const sortedModels = this.modelManager.getModelsTopoSortedByForeignKey();
    const models = sortedModels || this.modelManager.models;
    const hasCyclicDependencies = sortedModels == null;
    if (hasCyclicDependencies && !(options == null ? void 0 : options.cascade) && !(options == null ? void 0 : options.withoutForeignKeyChecks)) {
      throw new Error('Sequelize#truncate: Some of your models have cyclic references (foreign keys). You need to use the "cascade" or "withoutForeignKeyChecks" options to be able to delete rows from models that have cyclic references.');
    }
    if (options == null ? void 0 : options.withoutForeignKeyChecks) {
      if (!this.dialect.supports.constraints.foreignKeyChecksDisableable) {
        throw new Error(`Sequelize#truncate: ${this.dialect.name} does not support disabling foreign key checks. The "withoutForeignKeyChecks" option cannot be used.`);
      }
      return this.queryInterface.withoutForeignKeyChecks(options, async (connection) => {
        const truncateOptions = { ...options, connection };
        await Promise.all(models.map(async (model) => model.truncate(truncateOptions)));
      });
    }
    if (options == null ? void 0 : options.cascade) {
      for (const model of models) {
        await model.truncate(options);
      }
      return;
    }
    await Promise.all(models.map(async (model) => model.truncate(options)));
  }
  async withConnection(optionsOrCallback, maybeCallback) {
    let options;
    let callback;
    if (typeof optionsOrCallback === "function") {
      callback = optionsOrCallback;
      options = { type: "write" };
    } else {
      callback = maybeCallback;
      options = { type: "write", ...optionsOrCallback };
    }
    const connection = await this.connectionManager.getConnection(options);
    try {
      return await callback(connection);
    } finally {
      if (options.destroyConnection) {
        await this.connectionManager.destroyConnection(connection);
      } else {
        this.connectionManager.releaseConnection(connection);
      }
    }
  }
  /**
   * Alias of {@link AbstractQueryInterface#createSchema}
   *
   * @param schema Name of the schema
   * @param options
   */
  async createSchema(schema, options) {
    return this.queryInterface.createSchema(schema, options);
  }
  /**
   * Alias of {@link AbstractQueryInterface#showAllSchemas}
   *
   * @param options
   */
  async showAllSchemas(options) {
    return this.queryInterface.showAllSchemas(options);
  }
  /**
   * Alias of {@link AbstractQueryInterface#dropSchema}
   *
   * @param schema
   * @param options
   */
  async dropSchema(schema, options) {
    return this.queryInterface.dropSchema(schema, options);
  }
  /**
   * Alias of {@link AbstractQueryInterface#dropAllSchemas}
   *
   * @param options
   */
  async dropAllSchemas(options) {
    return this.queryInterface.dropAllSchemas(options);
  }
  /**
   * Throws if the database version hasn't been loaded yet.
   * It is automatically loaded the first time Sequelize connects to your database.
   *
   * You can use {@link Sequelize#authenticate} to cause a first connection.
   *
   * @returns current version of the dialect that is internally loaded
   */
  getDatabaseVersion() {
    if (this.options.databaseVersion == null) {
      throw new Error("The current database version is unknown. Please call `sequelize.authenticate()` first to fetch it, or manually configure it through options.");
    }
    return this.options.databaseVersion;
  }
  /**
   * Alias of {@link AbstractQueryInterface#fetchDatabaseVersion}
   *
   * @param options
   */
  async fetchDatabaseVersion(options) {
    return this.queryInterface.fetchDatabaseVersion(options);
  }
}
//# sourceMappingURL=sequelize-typescript.js.map
