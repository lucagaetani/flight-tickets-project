"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var sequelize_exports = {};
__export(sequelize_exports, {
  Sequelize: () => Sequelize,
  and: () => and,
  or: () => or
});
module.exports = __toCommonJS(sequelize_exports);
var import_retry_as_promised = __toESM(require("retry-as-promised"));
var import_data_types_utils = require("./dialects/abstract/data-types-utils");
var import_association_path = require("./expression-builders/association-path");
var import_attribute = require("./expression-builders/attribute");
var import_identifier = require("./expression-builders/identifier");
var import_json_path = require("./expression-builders/json-path");
var import_value = require("./expression-builders/value");
var import_list = require("./expression-builders/list");
var import_sql = require("./expression-builders/sql");
var import_cast = require("./expression-builders/cast.js");
var import_col = require("./expression-builders/col.js");
var import_fn = require("./expression-builders/fn.js");
var import_json = require("./expression-builders/json.js");
var import_literal = require("./expression-builders/literal.js");
var import_where = require("./expression-builders/where.js");
var import_model_internals = require("./model-internals.js");
var import_sequelize_typescript = require("./sequelize-typescript");
var import_sqlite_utils = require("./dialects/sqlite/sqlite-utils");
var import_transaction = require("./transaction.js");
var import_check = require("./utils/check.js");
var import_deprecations = require("./utils/deprecations");
var import_model_utils = require("./utils/model-utils");
var import_sql2 = require("./utils/sql");
var import_string = require("./utils/string");
var import_url = require("./utils/url");
var import_import_models = require("./import-models.js");
var import_defaults = __toESM(require("lodash/defaults"));
var import_defaultsDeep = __toESM(require("lodash/defaultsDeep"));
var import_isPlainObject = __toESM(require("lodash/isPlainObject"));
var import_map = __toESM(require("lodash/map"));
const { Model } = require("./model");
const DataTypes = require("./data-types");
const { ConstraintChecking, Deferrable } = require("./deferrable");
const { ModelManager } = require("./model-manager");
const { QueryTypes } = require("./query-types");
const { TableHints } = require("./table-hints");
const { IndexHints } = require("./index-hints");
const sequelizeErrors = require("./errors");
const { Association } = require("./associations/index");
const Validator = require("./utils/validator-extras").validator;
const { Op } = require("./operators");
const deprecations = require("./utils/deprecations");
const { AbstractQueryInterface } = require("./dialects/abstract/query-interface");
const { BelongsTo } = require("./associations/belongs-to");
const { HasOne } = require("./associations/has-one");
const { BelongsToMany } = require("./associations/belongs-to-many");
const { HasMany } = require("./associations/has-many");
require("./utils/dayjs");
class Sequelize extends import_sequelize_typescript.SequelizeTypeScript {
  /**
   * Instantiate sequelize with name of database, username and password.
   *
   * @example
   * // without password / with blank password
   * const sequelize = new Sequelize('database', 'username', null, {
   *   dialect: 'mysql'
   * })
   *
   * // with password and options
   * const sequelize = new Sequelize('my_database', 'john', 'doe', {
   *   dialect: 'postgres'
   * })
   *
   * // with database, username, and password in the options object
   * const sequelize = new Sequelize({ database, username, password, dialect: 'mssql' });
   *
   * // with uri
   * const sequelize = new Sequelize('mysql://localhost:3306/database', {})
   *
   * // option examples
   * const sequelize = new Sequelize('database', 'username', 'password', {
   *   // the sql dialect of the database
   *   // currently supported: 'mysql', 'sqlite', 'postgres', 'mssql'
   *   dialect: 'mysql',
   *
   *   // custom host; default: localhost
   *   host: 'my.server.tld',
   *   // for postgres, you can also specify an absolute path to a directory
   *   // containing a UNIX socket to connect over
   *   // host: '/sockets/psql_sockets'.
   *
   *   // custom port; default: dialect default
   *   port: 12345,
   *
   *   // custom protocol; default: 'tcp'
   *   // postgres only, useful for Heroku
   *   protocol: null,
   *
   *   // disable logging or provide a custom logging function; default: console.log
   *   logging: false,
   *
   *   // you can also pass any dialect options to the underlying dialect library
   *   // - default is empty
   *   // - currently supported: 'mysql', 'postgres', 'mssql'
   *   dialectOptions: {
   *     socketPath: '/Applications/MAMP/tmp/mysql/mysql.sock',
   *   },
   *
   *   // the storage engine for sqlite
   *   // - default ':memory:'
   *   storage: 'path/to/database.sqlite',
   *
   *   // disable inserting undefined values as NULL
   *   // - default: false
   *   omitNull: true,
   *
   *   // a flag for using a native library or not.
   *   // in the case of 'pg' -- set this to true will allow SSL support
   *   // - default: false
   *   native: true,
   *
   *   // A flag that defines if connection should be over ssl or not
   *   // - default: undefined
   *   ssl: true,
   *
   *   // Specify options, which are used when sequelize.define is called.
   *   // The following example:
   *   //   define: { timestamps: false }
   *   // is basically the same as:
   *   //   Model.init(attributes, { timestamps: false });
   *   //   sequelize.define(name, attributes, { timestamps: false });
   *   // so defining the timestamps for each model will be not necessary
   *   define: {
   *     underscored: false,
   *     freezeTableName: false,
   *     charset: 'utf8',
   *     dialectOptions: {
   *       collate: 'utf8_general_ci'
   *     },
   *     timestamps: true
   *   },
   *
   *   // similar for sync: you can define this to always force sync for models
   *   sync: { force: true },
   *
   *   // pool configuration used to pool database connections
   *   pool: {
   *     max: 5,
   *     idle: 30000,
   *     acquire: 60000,
   *   },
   *
   *   // isolation level of each transaction
   *   // defaults to dialect default
   *   isolationLevel: Transaction.ISOLATION_LEVELS.REPEATABLE_READ
   * })
   *
   * @param {string}   [database] The name of the database
   * @param {string}   [username=null] The username which is used to authenticate against the database.
   * @param {string}   [password=null] The password which is used to authenticate against the database. Supports SQLCipher encryption for SQLite.
   * @param {object}   [options={}] An object with options.
   * @param {string}   [options.host='localhost'] The host of the relational database.
   * @param {number}   [options.port] The port of the relational database.
   * @param {string}   [options.username=null] The username which is used to authenticate against the database.
   * @param {string}   [options.password=null] The password which is used to authenticate against the database.
   * @param {string}   [options.database=null] The name of the database.
   * @param {string}   [options.dialect] The dialect of the database you are connecting to. One of mysql, postgres, sqlite, db2, mariadb and mssql.
   * @param {string}   [options.dialectModule=null] If specified, use this dialect library. For example, if you want to use pg.js instead of pg when connecting to a pg database, you should specify 'require("pg.js")' here
   * @param {string}   [options.dialectModulePath=null] If specified, load the dialect library from this path. For example, if you want to use pg.js instead of pg when connecting to a pg database, you should specify '/path/to/pg.js' here
   * @param {object}   [options.dialectOptions] An object of additional options, which are passed directly to the connection library
   * @param {string}   [options.storage] Only used by sqlite. Defaults to ':memory:'
   * @param {string}   [options.protocol='tcp'] The protocol of the relational database.
   * @param {object}   [options.define={}] Default options for model definitions. See {@link Model.init}.
   * @param {object}   [options.query={}] Default options for sequelize.query
   * @param {string}   [options.schema=null] A schema to use
   * @param {object}   [options.set={}] Default options for sequelize.set
   * @param {object}   [options.sync={}] Default options for sequelize.sync
   * @param {string}   [options.timezone='+00:00'] The timezone used when converting a date from the database into a JavaScript date. The timezone is also used to SET TIMEZONE when connecting to the server, to ensure that the result of NOW, CURRENT_TIMESTAMP and other time related functions have in the right timezone. For best cross platform performance use the format +/-HH:MM. Will also accept string versions of timezones supported by Intl.Locale (e.g. 'America/Los_Angeles'); this is useful to capture daylight savings time changes.
   * @param {boolean}  [options.keepDefaultTimezone=false] A flag that defines if the default timezone is used to convert dates from the database.
   * @param {number|null} [options.defaultTimestampPrecision] The precision for the `createdAt`/`updatedAt`/`deletedAt` DATETIME columns that Sequelize adds to models. Can be a number between 0 and 6, or null to use the default precision of the database. Defaults to 6.
   * @param {string|boolean} [options.clientMinMessages='warning'] (Deprecated) The PostgreSQL `client_min_messages` session parameter. Set to `false` to not override the database's default.
   * @param {boolean}  [options.standardConformingStrings=true] The PostgreSQL `standard_conforming_strings` session parameter. Set to `false` to not set the option. WARNING: Setting this to false may expose vulnerabilities and is not recommended!
   * @param {Function} [options.logging=console.log] A function that gets executed every time Sequelize would log something. Function may receive multiple parameters but only first one is printed by `console.log`. To print all values use `(...msg) => console.log(msg)`
   * @param {boolean}  [options.benchmark=false] Pass query execution time in milliseconds as second argument to logging function (options.logging).
   * @param {string}   [options.queryLabel] A label to annotate queries in log output.
   * @param {boolean}  [options.omitNull=false] A flag that defines if null values should be passed as values to CREATE/UPDATE SQL queries or not.
   * @param {boolean}  [options.native=false] A flag that defines if native library shall be used or not. Currently only has an effect for postgres
   * @param {boolean}  [options.ssl=undefined] A flag that defines if connection should be over ssl or not
   * @param {boolean}  [options.replication=false] Use read / write replication. To enable replication, pass an object, with two properties, read and write. Write should be an object (a single server for handling writes), and read an array of object (several servers to handle reads). Each read/write server can have the following properties: `host`, `port`, `username`, `password`, `database`.  Connection strings can be used instead of objects.
   * @param {object}   [options.pool] sequelize connection pool configuration
   * @param {number}   [options.pool.max=5] Maximum number of connection in pool
   * @param {number}   [options.pool.min=0] Minimum number of connection in pool
   * @param {number}   [options.pool.idle=10000] The maximum time, in milliseconds, that a connection can be idle before being released.
   * @param {number}   [options.pool.acquire=60000] The maximum time, in milliseconds, that pool will try to get connection before throwing error
   * @param {number}   [options.pool.evict=1000] The time interval, in milliseconds, after which sequelize-pool will remove idle connections.
   * @param {Function} [options.pool.validate] A function that validates a connection. Called with client. The default function checks that client is an object, and that its state is not disconnected
   * @param {number}   [options.pool.maxUses=Infinity] The number of times a connection can be used before discarding it for a replacement, [`used for eventual cluster rebalancing`](https://github.com/sequelize/sequelize-pool).
   * @param {boolean}  [options.quoteIdentifiers=true] Set to `false` to make table names and attributes case-insensitive on Postgres and skip double quoting of them.  WARNING: Setting this to false may expose vulnerabilities and is not recommended!
   * @param {string}   [options.transactionType='DEFERRED'] Set the default transaction type. See `Sequelize.Transaction.TYPES` for possible options. Sqlite only.
   * @param {string}   [options.isolationLevel] Set the default transaction isolation level. See `Sequelize.Transaction.ISOLATION_LEVELS` for possible options.
   * @param {object}   [options.retry] Set of flags that control when a query is automatically retried. Accepts all options for [`retry-as-promised`](https://github.com/mickhansen/retry-as-promised).
   * @param {Array}    [options.retry.match] Only retry a query if the error matches one of these strings.
   * @param {number}   [options.retry.max] How many times a failing query is automatically retried.  Set to 0 to disable retrying on SQL_BUSY error.
   * @param {number}   [options.retry.timeout] Maximum duration, in milliseconds, to retry until an error is thrown.
   * @param {number}   [options.retry.backoffBase=100] Initial backoff duration, in milliseconds.
   * @param {number}   [options.retry.backoffExponent=1.1] Exponent to increase backoff duration after each retry.
   * @param {Function} [options.retry.report] Function that is executed after each retry, called with a message and the current retry options.
   * @param {string}   [options.retry.name='unknown'] Name used when composing error/reporting messages.
   * @param {boolean}  [options.noTypeValidation=false] Run built-in type validators on insert and update, and select with where clause, e.g. validate that arguments passed to integer fields are integer-like.
   * @param {object}   [options.hooks] An object of global hook functions that are called before and after certain lifecycle events. Global hooks will run after any model-specific hooks defined for the same event (See `Sequelize.Model.init()` for a list).  Additionally, `beforeConnect()`, `afterConnect()`, `beforeDisconnect()`, and `afterDisconnect()` hooks may be defined here.
   * @param {boolean}  [options.minifyAliases=false] A flag that defines if aliases should be minified (mostly useful to avoid Postgres alias character limit of 64)
   * @param {boolean}  [options.logQueryParameters=false] A flag that defines if show bind parameters in log.
   */
  constructor(database, username, password, options) {
    super();
    if (arguments.length === 1 && (0, import_isPlainObject.default)(database)) {
      options = database;
    } else if (arguments.length === 1 && typeof database === "string" || arguments.length === 2 && (0, import_isPlainObject.default)(username)) {
      options = username ? { ...username } : /* @__PURE__ */ Object.create(null);
      (0, import_defaultsDeep.default)(options, (0, import_url.parseConnectionString)(arguments[0]));
    } else {
      options = options ? { ...options } : /* @__PURE__ */ Object.create(null);
      (0, import_defaults.default)(options, {
        database,
        username,
        password
      });
    }
    Sequelize.hooks.runSync("beforeInit", options);
    if (options.pool === false) {
      throw new Error("Support for pool:false was removed in v4.0");
    }
    this.options = {
      dialect: null,
      dialectModule: null,
      dialectModulePath: null,
      dialectOptions: /* @__PURE__ */ Object.create(null),
      host: "localhost",
      protocol: "tcp",
      define: {},
      query: {},
      sync: {},
      timezone: "+00:00",
      keepDefaultTimezone: false,
      standardConformingStrings: true,
      logging: console.debug,
      omitNull: false,
      native: false,
      replication: false,
      ssl: void 0,
      // TODO [>7]: remove this option
      quoteIdentifiers: true,
      hooks: {},
      retry: {
        max: 5,
        match: [
          "SQLITE_BUSY: database is locked"
        ]
      },
      transactionType: import_transaction.TransactionType.DEFERRED,
      isolationLevel: null,
      databaseVersion: null,
      noTypeValidation: false,
      benchmark: false,
      minifyAliases: false,
      logQueryParameters: false,
      disableClsTransactions: false,
      defaultTransactionNestMode: import_transaction.TransactionNestMode.reuse,
      defaultTimestampPrecision: 6,
      ...options,
      pool: (0, import_defaults.default)(options.pool || {}, {
        max: 5,
        min: 0,
        idle: 1e4,
        acquire: 6e4,
        evict: 1e3
      })
    };
    if (!this.options.disableClsTransactions) {
      this._setupTransactionCls();
    }
    if (!this.options.dialect) {
      throw new Error("Dialect needs to be explicitly supplied as of v4.0.0");
    }
    if (this.options.dialect === "postgresql") {
      this.options.dialect = "postgres";
    }
    if (this.options.logging === true) {
      deprecations.noTrueLogging();
      this.options.logging = console.debug;
    }
    if (this.options.quoteIdentifiers === false) {
      deprecations.alwaysQuoteIdentifiers();
    }
    if (options.hooks) {
      this.hooks.addListeners(options.hooks);
    }
    let Dialect;
    switch (this.getDialect()) {
      case "mariadb":
        Dialect = require("./dialects/mariadb").MariaDbDialect;
        break;
      case "mssql":
        Dialect = require("./dialects/mssql").MssqlDialect;
        break;
      case "mysql":
        Dialect = require("./dialects/mysql").MysqlDialect;
        break;
      case "postgres":
        Dialect = require("./dialects/postgres").PostgresDialect;
        break;
      case "sqlite":
        Dialect = require("./dialects/sqlite").SqliteDialect;
        break;
      case "ibmi":
        Dialect = require("./dialects/ibmi").IBMiDialect;
        break;
      case "db2":
        Dialect = require("./dialects/db2").Db2Dialect;
        break;
      case "snowflake":
        Dialect = require("./dialects/snowflake").SnowflakeDialect;
        break;
      default:
        throw new Error(`The dialect ${this.getDialect()} is not supported. Supported dialects: mariadb, mssql, mysql, postgres, sqlite, ibmi, db2 and snowflake.`);
    }
    if (!this.options.port) {
      this.options.port = Dialect.getDefaultPort();
    } else {
      this.options.port = Number(this.options.port);
    }
    const connectionConfig = {
      database: this.options.database,
      username: this.options.username,
      password: this.options.password || null,
      host: this.options.host,
      port: this.options.port,
      protocol: this.options.protocol,
      ssl: this.options.ssl,
      dialectOptions: this.options.dialectOptions
    };
    if (!this.options.replication) {
      this.options.replication = /* @__PURE__ */ Object.create(null);
    }
    if ((0, import_check.isString)(this.options.replication.write)) {
      this.options.replication.write = (0, import_url.parseConnectionString)(this.options.replication.write);
    }
    this.options.replication.write = (0, import_defaults.default)(this.options.replication.write ?? {}, connectionConfig);
    this.options.replication.write.port = Number(this.options.replication.write.port);
    if (!this.options.replication.read) {
      this.options.replication.read = [];
    } else if (!Array.isArray(this.options.replication.read)) {
      this.options.replication.read = [this.options.replication.read];
    }
    this.options.replication.read = this.options.replication.read.map((readEntry) => {
      if ((0, import_check.isString)(readEntry)) {
        readEntry = (0, import_url.parseConnectionString)(readEntry);
      }
      readEntry.port = Number(readEntry.port);
      return (0, import_defaults.default)(readEntry, connectionConfig);
    });
    this.config = {
      ...connectionConfig,
      pool: this.options.pool,
      native: this.options.native,
      replication: this.options.replication,
      dialectModule: this.options.dialectModule,
      dialectModulePath: this.options.dialectModulePath,
      keepDefaultTimezone: this.options.keepDefaultTimezone
    };
    this.dialect = new Dialect(this);
    if ("typeValidation" in options) {
      throw new Error("The typeValidation has been renamed to noTypeValidation, and is false by default");
    }
    if (!this.dialect.supports.globalTimeZoneConfig && this.options.timezone !== "+00:00") {
      throw new Error(`Setting a custom timezone is not supported by ${this.dialect.name}, dates are always returned as UTC. Please remove the custom timezone option.`);
    }
    if (this.options.operatorsAliases) {
      throw new Error("String based operators have been removed. Please use Symbol operators, read more at https://sequelize.org/docs/v7/core-concepts/model-querying-basics/#deprecated-operator-aliases");
    }
    this.models = {};
    this.modelManager = new ModelManager(this);
    this.connectionManager = this.dialect.connectionManager;
    if (options.models) {
      this.addModels(options.models);
    }
    Sequelize.hooks.runSync("afterInit", this);
  }
  /**
   * Returns the specified dialect.
   *
   * @returns {string} The specified dialect.
   */
  // TODO [>=8]: rename to getDialectName or remove
  getDialect() {
    return this.options.dialect;
  }
  /**
   * Returns the database name.
   *
   * @returns {string} The database name.
   */
  getDatabaseName() {
    return this.config.database;
  }
  /**
   * Returns an instance of AbstractQueryInterface.
   *
   * @returns {AbstractQueryInterface} An instance (singleton) of AbstractQueryInterface.
   */
  // TODO [>=8]: deprecate & remove
  getQueryInterface() {
    return this.queryInterface;
  }
  /**
   * Define a new model, representing a table in the database.
   *
   * The table columns are defined by the object that is given as the second argument. Each key of the object represents a column
   *
   * @param {string} modelName The name of the model. The model will be stored in `sequelize.models` under this name
   * @param {object} attributes An object, where each attribute is a column of the table. See {@link Model.init}
   * @param {object} [options] These options are merged with the default define options provided to the Sequelize constructor and passed to Model.init()
   *
   * @see
   * {@link Model.init} for a more comprehensive specification of the `options` and `attributes` objects.
   * @see
   * <a href="/master/manual/model-basics.html">Model Basics</a> guide
   *
   * @returns {Model} Newly defined model
   *
   * @example
   * sequelize.define('modelName', {
   *   columnA: {
   *       type: DataTypes.BOOLEAN,
   *       validate: {
   *         is: ["[a-z]",'i'],        // will only allow letters
   *         max: 23,                  // only allow values <= 23
   *         isIn: {
   *           args: [['en', 'zh']],
   *           msg: "Must be English or Chinese"
   *         }
   *       },
   *       field: 'column_a'
   *   },
   *   columnB: DataTypes.STRING,
   *   columnC: 'MY VERY OWN COLUMN TYPE'
   * });
   *
   * sequelize.models.modelName // The model will now be available in models under the name given to define
   */
  define(modelName, attributes = {}, options = {}) {
    options.modelName = modelName;
    options.sequelize = this;
    const model = class extends Model {
    };
    model.init(attributes, options);
    return model;
  }
  /**
   * Fetch a Model which is already defined
   *
   * @param {string} modelName The name of a model defined with Sequelize.define
   *
   * @throws Will throw an error if the model is not defined (that is, if sequelize#isDefined returns false)
   * @returns {Model} Specified model
   */
  model(modelName) {
    if (!this.isDefined(modelName)) {
      throw new Error(`${modelName} has not been defined`);
    }
    return this.modelManager.getModel(modelName);
  }
  /**
   * Checks whether a model with the given name is defined
   *
   * @param {string} modelName The name of a model defined with Sequelize.define
   *
   * @returns {boolean} Returns true if model is already defined, otherwise false
   */
  isDefined(modelName) {
    return this.modelManager.models.some((model) => model.name === modelName);
  }
  /**
   * Execute a query on the DB, optionally bypassing all the Sequelize goodness.
   *
   * By default, the function will return two arguments: an array of results, and a metadata object, containing number of affected rows etc.
   *
   * If you are running a type of query where you don't need the metadata, for example a `SELECT` query, you can pass in a query type to make sequelize format the results:
   *
   * ```js
   * const [results, metadata] = await sequelize.query('SELECT...'); // Raw query - use array destructuring
   *
   * const results = await sequelize.query('SELECT...', { type: sequelize.QueryTypes.SELECT }); // SELECT query - no destructuring
   * ```
   *
   * @param {string}          sql
   * @param {object}          [options={}] Query options.
   * @param {boolean}         [options.raw] If true, sequelize will not try to format the results of the query, or build an instance of a model from the result
   * @param {Transaction}     [options.transaction=null] The transaction that the query should be executed under
   * @param {QueryTypes}      [options.type='RAW'] The type of query you are executing. The query type affects how results are formatted before they are passed back. The type is a string, but `Sequelize.QueryTypes` is provided as convenience shortcuts.
   * @param {boolean}         [options.nest=false] If true, transforms objects with `.` separated property names into nested objects using [dottie.js](https://github.com/mickhansen/dottie.js). For example { 'user.username': 'john' } becomes { user: { username: 'john' }}. When `nest` is true, the query type is assumed to be `'SELECT'`, unless otherwise specified
   * @param {boolean}         [options.plain=false] Sets the query type to `SELECT` and return a single row
   * @param {object|Array}    [options.replacements] Either an object of named parameter replacements in the format `:param` or an array of unnamed replacements to replace `?` in your SQL.
   * @param {object|Array}    [options.bind] Either an object of named bind parameter in the format `_param` or an array of unnamed bind parameter to replace `$1, $2, ...` in your SQL.
   * @param {boolean}         [options.useMaster=false] Force the query to use the write pool, regardless of the query type.
   * @param {Function}        [options.logging=false] A function that gets executed while running the query to log the sql.
   * @param {Model}           [options.instance] A sequelize model instance whose Model is to be used to build the query result
   * @param {ModelStatic<Model>}    [options.model] A sequelize model used to build the returned model instances
   * @param {object}          [options.retry] Set of flags that control when a query is automatically retried. Accepts all options for [`retry-as-promised`](https://github.com/mickhansen/retry-as-promised).
   * @param {Array}           [options.retry.match] Only retry a query if the error matches one of these strings.
   * @param {Integer}         [options.retry.max] How many times a failing query is automatically retried.
   * @param {number}          [options.retry.timeout] Maximum duration, in milliseconds, to retry until an error is thrown.
   * @param {number}          [options.retry.backoffBase=100] Initial backoff duration, in milliseconds.
   * @param {number}          [options.retry.backoffExponent=1.1] Exponent to increase backoff duration after each retry.
   * @param {Function}        [options.retry.report] Function that is executed after each retry, called with a message and the current retry options.
   * @param {string}          [options.retry.name='unknown'] Name used when composing error/reporting messages.
   * @param {string}          [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)
   * @param {boolean}         [options.supportsSearchPath] If false do not prepend the query with the search_path (Postgres only)
   * @param {boolean}         [options.mapToModel=false] Map returned fields to model's fields if `options.model` or `options.instance` is present. Mapping will occur before building the model instance.
   * @param {object}          [options.fieldMap] Map returned fields to arbitrary names for `SELECT` query type.
   * @param {boolean}         [options.rawErrors=false] Set to `true` to cause errors coming from the underlying connection/database library to be propagated unmodified and unformatted. Else, the default behavior (=false) is to reinterpret errors as sequelize.errors.BaseError objects.
   *
   * @returns {Promise}
   *
   * @see {@link Model.build} for more information about instance option.
   */
  async query(sql2, options) {
    options = { ...this.options.query, ...options };
    if (typeof sql2 === "object") {
      throw new TypeError('"sql" cannot be an object. Pass a string instead, and pass bind and replacement parameters through the "options" parameter');
    }
    sql2 = sql2.trim();
    if (options.replacements) {
      sql2 = (0, import_sql2.injectReplacements)(sql2, this.dialect, options.replacements);
    }
    delete options.replacements;
    return this.queryRaw(sql2, options);
  }
  async queryRaw(sql2, options) {
    var _a;
    if (typeof sql2 !== "string") {
      throw new TypeError("Sequelize#rawQuery requires a string as the first parameter.");
    }
    if (options != null && "replacements" in options) {
      throw new TypeError(`Sequelize#rawQuery does not accept the "replacements" options.
Only bind parameters can be provided, in the dialect-specific syntax.
Use Sequelize#query if you wish to use replacements.`);
    }
    options = { ...this.options.query, ...options, bindParameterOrder: null };
    let bindParameters;
    let bindParameterOrder;
    if (options.bind != null) {
      const isBindArray = Array.isArray(options.bind);
      if (!(0, import_isPlainObject.default)(options.bind) && !isBindArray) {
        throw new TypeError("options.bind must be either a plain object (for named parameters) or an array (for numeric parameters)");
      }
      const mappedResult = (0, import_sql2.mapBindParameters)(sql2, this.dialect);
      for (const parameterName of mappedResult.parameterSet) {
        if (isBindArray) {
          if (!/[1-9][0-9]*/.test(parameterName) || options.bind.length < Number(parameterName)) {
            throw new Error(`Query includes bind parameter "$${parameterName}", but no value has been provided for that bind parameter.`);
          }
        } else if (!(parameterName in options.bind)) {
          throw new Error(`Query includes bind parameter "$${parameterName}", but no value has been provided for that bind parameter.`);
        }
      }
      sql2 = mappedResult.sql;
      options.bindParameterOrder = mappedResult.bindOrder;
      if (mappedResult.bindOrder == null) {
        bindParameters = options.bind;
      } else {
        bindParameters = mappedResult.bindOrder.map((key) => {
          if (isBindArray) {
            return options.bind[key - 1];
          }
          return options.bind[key];
        });
      }
    }
    if (options.instance && !options.model) {
      options.model = options.instance.constructor;
    }
    if (!options.instance && !options.model) {
      options.raw = true;
    }
    if (options.mapToModel) {
      options.fieldMap = (_a = options.model) == null ? void 0 : _a.fieldAttributeMap;
    }
    options = (0, import_defaults.default)(options, {
      logging: Object.hasOwn(this.options, "logging") ? this.options.logging : console.debug,
      searchPath: Object.hasOwn(this.options, "searchPath") ? this.options.searchPath : "DEFAULT"
    });
    if (!options.type) {
      if (options.model || options.nest || options.plain) {
        options.type = QueryTypes.SELECT;
      } else {
        options.type = QueryTypes.RAW;
      }
    }
    if (!this.dialect.supports.searchPath || !this.options.dialectOptions || !this.options.dialectOptions.prependSearchPath || options.supportsSearchPath === false) {
      delete options.searchPath;
    } else if (!options.searchPath) {
      options.searchPath = "DEFAULT";
    }
    const checkTransaction = () => {
      if (options.transaction && options.transaction.finished && !options.completesTransaction) {
        const error = new Error(`${options.transaction.finished} has been called on this transaction(${options.transaction.id}), you can no longer use it. (The rejected query is attached as the 'sql' property of this error)`);
        error.sql = sql2;
        throw error;
      }
    };
    (0, import_model_internals.setTransactionFromCls)(options, this);
    const retryOptions = { ...this.options.retry, ...options.retry };
    return await (0, import_retry_as_promised.default)(async () => {
      checkTransaction();
      const connection = options.transaction ? options.transaction.getConnection() : options.connection ? options.connection : await this.connectionManager.getConnection({
        useMaster: options.useMaster,
        type: options.type === "SELECT" ? "read" : "write"
      });
      if (this.options.dialect === "db2" && options.alter && options.alter.drop === false) {
        connection.dropTable = false;
      }
      const query = new this.dialect.Query(connection, this, options);
      try {
        await this.hooks.runAsync("beforeQuery", options, query);
        checkTransaction();
        return await query.run(sql2, bindParameters, { minifyAliases: options.minifyAliases });
      } finally {
        await this.hooks.runAsync("afterQuery", options, query);
        if (!options.transaction && !options.connection) {
          this.connectionManager.releaseConnection(connection);
        }
      }
    }, retryOptions);
  }
  /**
   * Execute a query which would set an environment or user variable. The variables are set per connection, so this function needs a transaction.
   * Only works for MySQL or MariaDB.
   *
   * @param {object} variables Object with multiple variables.
   * @param {object} [options] query options.
   *
   * @returns {Promise}
   */
  async setSessionVariables(variables, options) {
    options = { ...this.options.setSessionVariables, ...options };
    if (!["mysql", "mariadb"].includes(this.options.dialect)) {
      throw new Error("sequelize.setSessionVariables is only supported for mysql or mariadb");
    }
    (0, import_model_internals.setTransactionFromCls)(options, this);
    if ((!options.transaction || !(options.transaction instanceof import_transaction.Transaction)) && !options.connection) {
      throw new Error("You must specify either options.transaction or options.connection, as sequelize.setSessionVariables is used to set the session options of a connection");
    }
    options.raw = true;
    options.plain = true;
    options.type = "SET";
    const query = `SET ${(0, import_map.default)(variables, (v, k) => `@${k} := ${typeof v === "string" ? `"${v}"` : v}`).join(", ")}`;
    return await this.query(query, options);
  }
  /**
   * Sync all defined models to the DB.
   *
   * @param {object} [options={}] sync options
   * @param {boolean} [options.force=false] If force is true, each Model will run `DROP TABLE IF EXISTS`, before it tries to create its own table
   * @param {RegExp} [options.match] Match a regex against the database name before syncing, a safety check for cases where force: true is used in tests but not live code
   * @param {boolean|Function} [options.logging=console.log] A function that logs sql queries, or false for no logging
   * @param {string} [options.schema='public'] The schema that the tables should be created in. This can be overridden for each table in sequelize.define
   * @param {string} [options.searchPath=DEFAULT] An optional parameter to specify the schema search_path (Postgres only)
   * @param {boolean} [options.hooks=true] If hooks is true then beforeSync, afterSync, beforeBulkSync, afterBulkSync hooks will be called
   * @param {boolean|object} [options.alter=false] Alters tables to fit models. Provide an object for additional configuration. Not recommended for production use. If not further configured deletes data in columns that were removed or had their type changed in the model.
   * @param {boolean} [options.alter.drop=true] Prevents any drop statements while altering a table when set to `false`
   *
   * @returns {Promise}
   */
  async sync(options) {
    options = {
      ...this.options,
      ...this.options.sync,
      ...options,
      hooks: options ? options.hooks !== false : true
    };
    if (options.match && !options.match.test(this.config.database)) {
      throw new Error(`Database "${this.config.database}" does not match sync match parameter "${options.match}"`);
    }
    if (options.hooks) {
      await this.hooks.runAsync("beforeBulkSync", options);
    }
    if (options.force) {
      await this.drop({ ...options, cascade: this.dialect.supports.dropTable.cascade || void 0 });
    }
    if (this.modelManager.models.length === 0) {
      await this.authenticate(options);
    } else {
      const models = this.modelManager.getModelsTopoSortedByForeignKey();
      if (models == null) {
        return this._syncModelsWithCyclicReferences(options);
      }
      models.reverse();
      for (const model of models) {
        await model.sync(options);
      }
    }
    if (options.hooks) {
      await this.hooks.runAsync("afterBulkSync", options);
    }
    return this;
  }
  /**
   * Used instead of sync() when two models reference each-other, so their foreign keys cannot be created immediately.
   *
   * @param {object} options - sync options
   * @private
   */
  async _syncModelsWithCyclicReferences(options) {
    if (this.dialect.name === "sqlite") {
      await (0, import_sqlite_utils.withSqliteForeignKeysOff)(this, options, async () => {
        for (const model of this.modelManager.models) {
          await model.sync(options);
        }
      });
      return;
    }
    for (const model of this.modelManager.models) {
      await model.sync({ ...options, withoutForeignKeyConstraints: true });
    }
    for (const model of this.modelManager.models) {
      await model.sync({ ...options, force: false, alter: true });
    }
  }
  /**
   * Drop all tables defined through this sequelize instance.
   * This is done by calling {@link Model.drop} on each model.
   *
   * @param {object} [options] The options passed to each call to Model.drop
   * @param {boolean|Function} [options.logging] A function that logs sql queries, or false for no logging
   *
   * @returns {Promise}
   */
  async drop(options) {
    if (options && options.cascade) {
      for (const model of this.modelManager.models) {
        await model.drop(options);
      }
    }
    const sortedModels = this.modelManager.getModelsTopoSortedByForeignKey();
    if (sortedModels) {
      for (const model of sortedModels) {
        await model.drop(options);
      }
    }
    if (this.dialect.name === "sqlite") {
      await (0, import_sqlite_utils.withSqliteForeignKeysOff)(this, options, async () => {
        for (const model of this.modelManager.models) {
          await model.drop(options);
        }
      });
      return;
    }
    for (const model of this.modelManager.models) {
      const foreignKeys = await this.queryInterface.showConstraints(model, { ...options, constraintType: "FOREIGN KEY" });
      await Promise.all(foreignKeys.map((foreignKey) => {
        return this.queryInterface.removeConstraint(model, foreignKey.constraintName, options);
      }));
    }
    for (const model of this.modelManager.models) {
      await model.drop(options);
    }
  }
  /**
   * Test the connection by trying to authenticate. It runs `SELECT 1+1 AS result` query.
   *
   * @param {object} [options={}] query options
   *
   * @returns {Promise}
   */
  async authenticate(options) {
    options = {
      raw: true,
      plain: true,
      type: QueryTypes.SELECT,
      ...options
    };
    await this.query(`SELECT 1+1 AS result${this.options.dialect === "ibmi" ? " FROM SYSIBM.SYSDUMMY1" : ""}`, options);
  }
  /**
   * Get the fn for random based on the dialect
   *
   * @returns {Fn}
   */
  random() {
    if (["postgres", "sqlite", "snowflake"].includes(this.getDialect())) {
      return (0, import_fn.fn)("RANDOM");
    }
    return (0, import_fn.fn)("RAND");
  }
  // Global exports
  static Fn = import_fn.Fn;
  static Col = import_col.Col;
  static Cast = import_cast.Cast;
  static Literal = import_literal.Literal;
  static Where = import_where.Where;
  static List = import_list.List;
  static Identifier = import_identifier.Identifier;
  static Attribute = import_attribute.Attribute;
  static Value = import_value.Value;
  static AssociationPath = import_association_path.AssociationPath;
  static JsonPath = import_json_path.JsonPath;
  static sql = import_sql.sql;
  // these are all available on the "sql" object, but are exposed for backwards compatibility
  static fn = import_fn.fn;
  static col = import_col.col;
  static cast = import_cast.cast;
  static literal = import_literal.literal;
  static json = import_json.json;
  static where = import_where.where;
  static and = and;
  static or = or;
  static isModelStatic = import_model_utils.isModelStatic;
  static isSameInitialModel = import_model_utils.isSameInitialModel;
  static importModels = import_import_models.importModels;
  static TransactionNestMode = import_transaction.TransactionNestMode;
  static TransactionType = import_transaction.TransactionType;
  static Lock = import_transaction.Lock;
  static IsolationLevel = import_transaction.IsolationLevel;
  log(...args) {
    let options;
    const last = args.at(-1);
    if (last && (0, import_isPlainObject.default)(last) && Object.hasOwn(last, "logging")) {
      options = last;
      if (options.logging === console.log || options.logging === console.debug) {
        args.splice(-1, 1);
      }
    } else {
      options = this.options;
    }
    if (options.logging) {
      if (options.logging === true) {
        deprecations.noTrueLogging();
        options.logging = console.debug;
      }
      if ((this.options.benchmark || options.benchmark) && options.logging === console.debug) {
        args = [`${args[0]} Elapsed time: ${args[1]}ms`];
      }
      options.logging(...args);
    }
  }
  /**
   * Close all connections used by this sequelize instance, and free all references so the instance can be garbage collected.
   *
   * Normally this is done on process exit, so you only need to call this method if you are creating multiple instances, and want
   * to garbage collect some of them.
   *
   * @returns {Promise}
   */
  close() {
    return this.connectionManager.close();
  }
  normalizeDataType(Type) {
    return (0, import_data_types_utils.normalizeDataType)(Type, this.dialect);
  }
  normalizeAttribute(attribute) {
    if (!(0, import_isPlainObject.default)(attribute)) {
      attribute = { type: attribute };
    } else {
      attribute = { ...attribute };
    }
    if (attribute.values) {
      throw new TypeError(`
The "values" property has been removed from column definitions. The following is no longer supported:

sequelize.define('MyModel', {
  roles: {
    type: DataTypes.ENUM,
    values: ['admin', 'user'],
  },
});

Instead, define enum values like this:

sequelize.define('MyModel', {
  roles: {
    type: DataTypes.ENUM(['admin', 'user']),
  },
});

Remove the "values" property to resolve this issue.
        `.trim());
    }
    if (!attribute.type) {
      return attribute;
    }
    attribute.type = this.normalizeDataType(attribute.type);
    return attribute;
  }
}
Sequelize.prototype.fn = Sequelize.fn;
Sequelize.prototype.col = Sequelize.col;
Sequelize.prototype.cast = Sequelize.cast;
Sequelize.prototype.literal = Sequelize.literal;
Sequelize.prototype.and = Sequelize.and;
Sequelize.prototype.or = Sequelize.or;
Sequelize.prototype.json = Sequelize.json;
Sequelize.prototype.where = Sequelize.where;
Sequelize.prototype.validate = Sequelize.prototype.authenticate;
Object.defineProperty(Sequelize, "version", {
  enumerable: true,
  get() {
    return require("../package.json").version;
  }
});
Sequelize.Op = Op;
Sequelize.TableHints = TableHints;
Sequelize.IndexHints = IndexHints;
Sequelize.Transaction = import_transaction.Transaction;
Sequelize.GeoJsonType = require("./geo-json").GeoJsonType;
Sequelize.prototype.Sequelize = Sequelize;
Sequelize.prototype.QueryTypes = Sequelize.QueryTypes = QueryTypes;
Sequelize.prototype.Validator = Sequelize.Validator = Validator;
Sequelize.Model = Model;
Sequelize.AbstractQueryInterface = AbstractQueryInterface;
Sequelize.BelongsTo = BelongsTo;
Sequelize.HasOne = HasOne;
Sequelize.HasMany = HasMany;
Sequelize.BelongsToMany = BelongsToMany;
Sequelize.DataTypes = DataTypes;
for (const dataTypeName in DataTypes) {
  Object.defineProperty(Sequelize, dataTypeName, {
    get() {
      (0, import_deprecations.noSequelizeDataType)();
      return DataTypes[dataTypeName];
    }
  });
}
Sequelize.Deferrable = Deferrable;
Sequelize.ConstraintChecking = ConstraintChecking;
Sequelize.prototype.Association = Sequelize.Association = Association;
Sequelize.useInflection = import_string.useInflection;
for (const error of Object.keys(sequelizeErrors)) {
  Sequelize[error] = sequelizeErrors[error];
}
function and(...args) {
  return { [Op.and]: args };
}
function or(...args) {
  if (args.length === 1) {
    return { [Op.or]: args[0] };
  }
  return { [Op.or]: args };
}
//# sourceMappingURL=sequelize.js.map
