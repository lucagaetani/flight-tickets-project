"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var model_manager_exports = {};
__export(model_manager_exports, {
  ModelManager: () => ModelManager
});
module.exports = __toCommonJS(model_manager_exports);
var import_defaults = __toESM(require("lodash/defaults"));
var import_toposort_class = __toESM(require("toposort-class"));
class ModelManager {
  #sequelize;
  constructor(sequelize) {
    this.models = [];
    this.#sequelize = sequelize;
  }
  addModel(model) {
    this.models.push(model);
    this.#sequelize.models[model.name] = model;
    return model;
  }
  removeModel(modelToRemove) {
    this.models = this.models.filter(
      (model) => model.name !== modelToRemove.name
    );
    delete this.#sequelize.models[modelToRemove.name];
  }
  getModel(modelName) {
    return this.models.find((model) => model.name === modelName);
  }
  findModel(callback) {
    return this.models.find(callback);
  }
  hasModel(targetModel) {
    return this.models.includes(targetModel);
  }
  get all() {
    return this.models;
  }
  /**
   * Returns an array that lists every model, sorted in order
   * of foreign key references: The first model is a model that is depended upon,
   * the last model is a model that is not depended upon.
   *
   * If there is a cyclic dependency, this returns null.
   */
  getModelsTopoSortedByForeignKey() {
    const models = /* @__PURE__ */ new Map();
    const sorter = new import_toposort_class.default();
    const queryGenerator = this.#sequelize.queryGenerator;
    for (const model of this.models) {
      let deps = [];
      const tableName = queryGenerator.quoteTable(model);
      models.set(tableName, model);
      const { attributes } = model.modelDefinition;
      for (const attrName of attributes.keys()) {
        const attribute = attributes.get(attrName);
        if (!(attribute == null ? void 0 : attribute.references)) {
          continue;
        }
        const dep = queryGenerator.quoteTable(attribute.references.table);
        deps.push(dep);
      }
      deps = deps.filter((dep) => tableName !== dep);
      sorter.add(tableName, deps);
    }
    let sorted;
    try {
      sorted = sorter.sort();
    } catch (error) {
      if (error instanceof Error && !error.message.startsWith("Cyclic dependency found.")) {
        throw error;
      }
      return null;
    }
    return sorted.map((modelName) => {
      return models.get(modelName);
    }).filter(Boolean);
  }
  /**
   * Iterate over Models in an order suitable for e.g. creating tables.
   * Will take foreign key constraints into account so that dependencies are visited before dependents.
   *
   * @param iterator method to execute on each model
   * @param options
   * @param options.reverse
   * @private
   *
   * @deprecated
   */
  forEachModel(iterator, options) {
    const sortedModels = this.getModelsTopoSortedByForeignKey();
    if (sortedModels == null) {
      throw new Error("Cyclic dependency found.");
    }
    options = (0, import_defaults.default)(options || {}, {
      reverse: true
    });
    if (options.reverse) {
      sortedModels.reverse();
    }
    for (const model of sortedModels) {
      iterator(model);
    }
  }
}
//# sourceMappingURL=model-manager.js.map
