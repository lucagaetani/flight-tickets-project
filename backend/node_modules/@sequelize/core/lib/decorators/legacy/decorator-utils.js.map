{
  "version": 3,
  "sources": ["../../../src/decorators/legacy/decorator-utils.ts"],
  "sourcesContent": ["export type PropertyOrGetterDescriptor = (\n  target: Object,\n  propertyName: string | symbol,\n  propertyDescriptor?: PropertyDescriptor,\n) => void;\n\nexport interface OptionalParameterizedPropertyDecorator<T> {\n  // @Decorator()\n  (): PropertyOrGetterDescriptor;\n  // @Decorator(value)\n  (options: T): PropertyOrGetterDescriptor;\n  // @Decorator\n  (target: Object, propertyName: string | symbol, propertyDescriptor?: PropertyDescriptor): void;\n}\n\nexport interface RequiredParameterizedPropertyDecorator<T> {\n  // @Decorator(value)\n  (options: T): PropertyOrGetterDescriptor;\n}\n\nexport const DECORATOR_NO_DEFAULT = Symbol('DECORATOR_NO_DEFAULT');\n\n/**\n * Creates a decorator that MUST receive a parameter\n *\n * @param name\n * @param callback The callback that will be executed once the decorator is applied.\n */\nexport function createParameterizedPropertyDecorator<T>(\n  name: string,\n  callback: (\n    option: T,\n    target: Object,\n    propertyName: string | symbol,\n    propertyDescriptor: PropertyDescriptor | undefined,\n  ) => void,\n): RequiredParameterizedPropertyDecorator<T> {\n  return createOptionallyParameterizedPropertyDecorator(name, DECORATOR_NO_DEFAULT, callback);\n}\n\n/**\n * Creates a decorator that can optionally receive a parameter\n *\n * @param name\n * @param defaultValue The value to use if no parameter is provided.\n * @param callback The callback that will be executed once the decorator is applied.\n */\nexport function createOptionallyParameterizedPropertyDecorator<T>(\n  name: string,\n  defaultValue: T | typeof DECORATOR_NO_DEFAULT,\n  callback: (\n    option: T,\n    target: Object,\n    propertyName: string | symbol,\n    propertyDescriptor: PropertyDescriptor | undefined,\n  ) => void,\n): OptionalParameterizedPropertyDecorator<T> {\n  return function decorator(...args: [] | [options: T] | Parameters<PropertyOrGetterDescriptor>) {\n    // note: cannot use <= 1, because TypeScript uses this to infer the type of \"args\".\n    if (args.length === 0 || args.length === 1) {\n      return function parameterizedDecorator(\n        target: Object,\n        propertyName: string | symbol,\n        propertyDescriptor?: PropertyDescriptor | undefined,\n      ) {\n        const value = args[0] ?? defaultValue;\n        if (value === DECORATOR_NO_DEFAULT) {\n          throw new Error(`Decorator @${name} requires an argument (used on ${getPropertyName(target, propertyName)})`);\n        }\n\n        callback(value, target, propertyName, propertyDescriptor ?? Object.getOwnPropertyDescriptor(target, propertyName));\n      };\n    }\n\n    if (defaultValue === DECORATOR_NO_DEFAULT) {\n      throw new Error(`Decorator @${name} requires an argument (used on ${getPropertyName(args[0], args[1])})`);\n    }\n\n    callback(defaultValue, args[0], args[1], args[2] ?? Object.getOwnPropertyDescriptor(args[0], args[1]));\n\n    // this method only returns something if args.length === 1, but typescript doesn't understand it\n    return undefined as unknown as PropertyOrGetterDescriptor;\n  };\n}\n\nexport function throwMustBeStaticProperty(decoratorName: string, target: Object, propertyName: string | symbol): never {\n  throw new TypeError(\n    `Decorator @${decoratorName} has been used on ${getPropertyName(target, propertyName)}, which is an instance property. This decorator can only be used on static properties, setters and getters.`,\n  );\n}\n\nexport function throwMustBeModel(decoratorName: string, target: Object, propertyName: string | symbol): never {\n  throw new TypeError(\n    `Decorator @${decoratorName} has been used on ${getPropertyName(target, propertyName)}, but class \"${getClassName(target)}\" does not extend Model. This decorator can only be used on models.`,\n  );\n}\n\nexport function throwMustBeInstanceProperty(decoratorName: string, target: Object, propertyName: string | symbol): never {\n  throw new TypeError(\n    `Decorator @${decoratorName} has been used on ${getPropertyName(target, propertyName)}, which is static. This decorator can only be used on instance properties, setters and getters.`,\n  );\n}\n\nexport function throwMustBeMethod(decoratorName: string, target: Object, propertyName: string | symbol): never {\n  throw new TypeError(\n    `Decorator @${decoratorName} has been used on ${getPropertyName(target, propertyName)}, which is not a method. This decorator can only be used on methods.`,\n  );\n}\n\nexport function throwMustBeAttribute(decoratorName: string, target: Object, propertyName: string | symbol): never {\n  throw new TypeError(\n    `Decorator @${decoratorName} has been used on ${getPropertyName(target, propertyName)}, which is a symbol field. Symbol Model Attributes are not currently supported. We welcome a PR that implements this feature.`,\n  );\n}\n\nexport function getPropertyName(obj: object, property: string | symbol): string {\n  if (typeof obj === 'function') {\n    return `${obj.name}.${String(property)}`;\n  }\n\n  return `${obj.constructor.name}#${String(property)}`;\n}\n\nexport function getClassName(obj: object): string {\n  if (typeof obj === 'function') {\n    return obj.name;\n  }\n\n  return obj.constructor.name;\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAoBO,MAAM,uBAAuB,OAAO,sBAAsB;AAQ1D,SAAS,qCACd,MACA,UAM2C;AAC3C,SAAO,+CAA+C,MAAM,sBAAsB,QAAQ;AAC5F;AASO,SAAS,+CACd,MACA,cACA,UAM2C;AAC3C,SAAO,SAAS,aAAa,MAAkE;AAE7F,QAAI,KAAK,WAAW,KAAK,KAAK,WAAW,GAAG;AAC1C,aAAO,SAAS,uBACd,QACA,cACA,oBACA;AACA,cAAM,QAAQ,KAAK,CAAC,KAAK;AACzB,YAAI,UAAU,sBAAsB;AAClC,gBAAM,IAAI,MAAM,cAAc,sCAAsC,gBAAgB,QAAQ,YAAY,IAAI;AAAA,QAC9G;AAEA,iBAAS,OAAO,QAAQ,cAAc,sBAAsB,OAAO,yBAAyB,QAAQ,YAAY,CAAC;AAAA,MACnH;AAAA,IACF;AAEA,QAAI,iBAAiB,sBAAsB;AACzC,YAAM,IAAI,MAAM,cAAc,sCAAsC,gBAAgB,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC,IAAI;AAAA,IAC1G;AAEA,aAAS,cAAc,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,KAAK,OAAO,yBAAyB,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC;AAGrG,WAAO;AAAA,EACT;AACF;AAEO,SAAS,0BAA0B,eAAuB,QAAgB,cAAsC;AACrH,QAAM,IAAI;AAAA,IACR,cAAc,kCAAkC,gBAAgB,QAAQ,YAAY;AAAA,EACtF;AACF;AAEO,SAAS,iBAAiB,eAAuB,QAAgB,cAAsC;AAC5G,QAAM,IAAI;AAAA,IACR,cAAc,kCAAkC,gBAAgB,QAAQ,YAAY,iBAAiB,aAAa,MAAM;AAAA,EAC1H;AACF;AAEO,SAAS,4BAA4B,eAAuB,QAAgB,cAAsC;AACvH,QAAM,IAAI;AAAA,IACR,cAAc,kCAAkC,gBAAgB,QAAQ,YAAY;AAAA,EACtF;AACF;AAEO,SAAS,kBAAkB,eAAuB,QAAgB,cAAsC;AAC7G,QAAM,IAAI;AAAA,IACR,cAAc,kCAAkC,gBAAgB,QAAQ,YAAY;AAAA,EACtF;AACF;AAEO,SAAS,qBAAqB,eAAuB,QAAgB,cAAsC;AAChH,QAAM,IAAI;AAAA,IACR,cAAc,kCAAkC,gBAAgB,QAAQ,YAAY;AAAA,EACtF;AACF;AAEO,SAAS,gBAAgB,KAAa,UAAmC;AAC9E,MAAI,OAAO,QAAQ,YAAY;AAC7B,WAAO,GAAG,IAAI,QAAQ,OAAO,QAAQ;AAAA,EACvC;AAEA,SAAO,GAAG,IAAI,YAAY,QAAQ,OAAO,QAAQ;AACnD;AAEO,SAAS,aAAa,KAAqB;AAChD,MAAI,OAAO,QAAQ,YAAY;AAC7B,WAAO,IAAI;AAAA,EACb;AAEA,SAAO,IAAI,YAAY;AACzB;",
  "names": []
}
