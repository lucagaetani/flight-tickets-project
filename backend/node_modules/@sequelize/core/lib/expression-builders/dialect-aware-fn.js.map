{
  "version": 3,
  "sources": ["../../src/expression-builders/dialect-aware-fn.ts"],
  "sourcesContent": ["import type { Class } from 'type-fest';\nimport type { AbstractDialect } from '../dialects/abstract/index.js';\nimport type { EscapeOptions } from '../dialects/abstract/query-generator-typescript.js';\nimport type { Expression } from '../sequelize.js';\nimport { BaseSqlExpression } from './base-sql-expression.js';\nimport { JsonPath } from './json-path.js';\n\n/**\n * Unlike {@link Fn}, this class does not accept a function name.\n * It must instead be extended by a class that implements the {@link apply} method, in which\n * the function name is provided.\n *\n * The goal of this class is to allow dialect-specific functions to be used in a cross-dialect way.\n * For instance, an extension of this class could be used to represent the `LOWER` function in a cross-dialect way,\n * by generating the correct SQL function name based on which dialect is used.\n */\nexport abstract class DialectAwareFn extends BaseSqlExpression {\n  readonly args: readonly Expression[];\n\n  constructor(...args: DialectAwareFn['args']) {\n    super();\n    this.args = args;\n\n    if (this.args.length > this.maxArgCount) {\n      throw new Error(`Too many arguments provided to ${this.constructor.name} function. Expected ${this.maxArgCount} or less, but got ${this.args.length}.`);\n    }\n\n    if (this.args.length < this.minArgCount) {\n      throw new Error(`Too few arguments provided to ${this.constructor.name} function. Expected ${this.minArgCount} or more, but got ${this.args.length}.`);\n    }\n  }\n\n  get maxArgCount() {\n    return Number.POSITIVE_INFINITY;\n  }\n\n  get minArgCount() {\n    return 0;\n  }\n\n  abstract apply(dialect: AbstractDialect, options?: EscapeOptions): string;\n\n  static build<M extends DialectAwareFn>(this: Class<M>, ...args: DialectAwareFn['args']): M {\n    return new this(...args);\n  }\n}\n\n/**\n * Unquotes JSON values.\n */\nexport class Unquote extends DialectAwareFn {\n  get maxArgCount() {\n    return 1;\n  }\n\n  get minArgCount() {\n    return 1;\n  }\n\n  apply(dialect: AbstractDialect, options?: EscapeOptions): string {\n    const arg = this.args[0];\n\n    if (arg instanceof JsonPath) {\n      return dialect.queryGenerator.jsonPathExtractionQuery(\n        dialect.queryGenerator.escape(arg.expression),\n        arg.path,\n        true,\n      );\n    }\n\n    return dialect.queryGenerator.formatUnquoteJson(arg, options);\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA,iCAAkC;AAClC,uBAAyB;AAWlB,MAAe,uBAAuB,6CAAkB;AAAA,EACpD;AAAA,EAET,eAAe,MAA8B;AAC3C,UAAM;AACN,SAAK,OAAO;AAEZ,QAAI,KAAK,KAAK,SAAS,KAAK,aAAa;AACvC,YAAM,IAAI,MAAM,kCAAkC,KAAK,YAAY,2BAA2B,KAAK,gCAAgC,KAAK,KAAK,SAAS;AAAA,IACxJ;AAEA,QAAI,KAAK,KAAK,SAAS,KAAK,aAAa;AACvC,YAAM,IAAI,MAAM,iCAAiC,KAAK,YAAY,2BAA2B,KAAK,gCAAgC,KAAK,KAAK,SAAS;AAAA,IACvJ;AAAA,EACF;AAAA,EAEA,IAAI,cAAc;AAChB,WAAO,OAAO;AAAA,EAChB;AAAA,EAEA,IAAI,cAAc;AAChB,WAAO;AAAA,EACT;AAAA,EAIA,OAAO,SAAmD,MAAiC;AACzF,WAAO,IAAI,KAAK,GAAG,IAAI;AAAA,EACzB;AACF;AAKO,MAAM,gBAAgB,eAAe;AAAA,EAC1C,IAAI,cAAc;AAChB,WAAO;AAAA,EACT;AAAA,EAEA,IAAI,cAAc;AAChB,WAAO;AAAA,EACT;AAAA,EAEA,MAAM,SAA0B,SAAiC;AAC/D,UAAM,MAAM,KAAK,KAAK,CAAC;AAEvB,QAAI,eAAe,2BAAU;AAC3B,aAAO,QAAQ,eAAe;AAAA,QAC5B,QAAQ,eAAe,OAAO,IAAI,UAAU;AAAA,QAC5C,IAAI;AAAA,QACJ;AAAA,MACF;AAAA,IACF;AAEA,WAAO,QAAQ,eAAe,kBAAkB,KAAK,OAAO;AAAA,EAC9D;AACF;",
  "names": []
}
