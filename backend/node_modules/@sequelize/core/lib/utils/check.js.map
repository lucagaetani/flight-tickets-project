{
  "version": 3,
  "sources": ["../../src/utils/check.ts"],
  "sourcesContent": ["import pickBy from 'lodash/pickBy';\nimport { BaseError } from '../errors/index.js';\nimport { Where } from '../expression-builders/where.js';\n\nexport function isNullish(val: unknown): val is null | undefined {\n  return val == null;\n}\n\nexport function isNodeError(val: unknown): val is NodeJS.ErrnoException {\n  return val instanceof Error && 'code' in val;\n}\n\nexport function isIterable(val: unknown): val is Iterable<unknown> {\n  // @ts-expect-error -- TS does not allow accessing Symbol.iterator like this.\n  return val != null && val[Symbol.iterator];\n}\n\n/**\n * Some dialects emit an Error with a string code, that are not ErrnoException.\n * This serves as a more generic check for those cases.\n *\n * @param val The value to check\n */\nexport function isErrorWithStringCode(val: unknown): val is Error & { code: string } {\n  return val instanceof Error\n    // @ts-expect-error -- 'code' doesn't exist on Error, but it's dynamically added by Node\n    && typeof val.code === 'string';\n}\n\nexport function assertIsErrorWithStringCode(val: unknown): asserts val is Error & { code: string } {\n  if (!isErrorWithStringCode(val)) {\n    throw new Error('Expected Error with string \"code\" property');\n  }\n}\n\nexport function isError(val: unknown): val is Error {\n  return val instanceof Error;\n}\n\nexport function assertCaughtError(val: unknown): asserts val is Error {\n  if (!isError(val)) {\n    throw new BaseError('A non-error value was thrown', { cause: val });\n  }\n}\n\nexport function isString(val: unknown): val is string {\n  return typeof val === 'string';\n}\n\nexport function isBigInt(val: unknown): val is bigint {\n  return typeof val === 'bigint';\n}\n\nexport function isNumber(val: unknown): val is number {\n  return typeof val === 'number';\n}\n\n/**\n * Works like lodash's isPlainObject, but has better typings\n *\n * @param value The value to check\n */\nexport function isPlainObject(value: unknown): value is object {\n  if (value === null || typeof value !== 'object') {\n    return false;\n  }\n\n  const prototype = Object.getPrototypeOf(value);\n\n  return prototype === null || prototype === Object.prototype;\n}\n\n/**\n * This function is the same as {@link isPlainObject}, but types the result as a Record / Dictionary.\n * This function won't be necessary starting with TypeScript 4.9, thanks to improvements to the TS object type,\n * but we have to keep it until we drop support for TS < 4.9.\n *\n * @param value\n */\nexport function isDictionary(value: unknown): value is Record<PropertyKey, unknown> {\n  return isPlainObject(value);\n}\n\n/**\n * Returns whether `value` is using the nested syntax for attributes.\n *\n * @param value The attribute reference to check.\n *\n * @example\n * ```javascript\n * isColString('$id$'); // true\n * isColString('$project.name$'); // true\n * isColString('name'); // false\n * ```\n */\nexport function isColString(value: string): boolean {\n  return (\n    typeof value === 'string'\n    && value.startsWith('$')\n    && value.endsWith('$')\n  );\n}\n\nexport function canTreatArrayAsAnd(arr: unknown[]): arr is Array<object | Where> {\n  return arr.some(arg => isPlainObject(arg) || arg instanceof Where);\n}\n\n/**\n * For use in per-dialect implementation of methods to warn the user when they use an option that TypeScript declares as valid,\n * but that the dialect they use does not support.\n *\n * @param methodName The name of the method that received the options\n * @param dialectName The name of the dialect to which the implementation belongs\n * @param allSupportableOptions All options that this method *can* support. The ones that are declared in TypeScript typings.\n * @param supportedOptions The subset of options that this dialect *actually does* support.\n * @param receivedOptions The user provided options that were passed to the method.\n */\nexport function rejectInvalidOptions(\n  methodName: string,\n  dialectName: string,\n  allSupportableOptions: Set<string>,\n  supportedOptions: Set<string>,\n  receivedOptions: object,\n): void {\n  const receivedOptionNames = Object.keys(pickBy(receivedOptions));\n  const unsupportedOptions = receivedOptionNames.filter(optionName => {\n    return allSupportableOptions.has(optionName) && !supportedOptions.has(optionName);\n  });\n\n  if (unsupportedOptions.length > 0) {\n    throw buildInvalidOptionReceivedError(methodName, dialectName, unsupportedOptions);\n  }\n}\n\nexport function buildInvalidOptionReceivedError(methodName: string, dialectName: string, invalidOptions: string[]): Error {\n  return new Error(`The following options are not supported by ${methodName} in ${dialectName}: ${invalidOptions.join(', ')}`);\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,oBAAmB;AACnB,oBAA0B;AAC1B,mBAAsB;AAEf,SAAS,UAAU,KAAuC;AAC/D,SAAO,OAAO;AAChB;AAEO,SAAS,YAAY,KAA4C;AACtE,SAAO,eAAe,SAAS,UAAU;AAC3C;AAEO,SAAS,WAAW,KAAwC;AAEjE,SAAO,OAAO,QAAQ,IAAI,OAAO,QAAQ;AAC3C;AAQO,SAAS,sBAAsB,KAA+C;AACnF,SAAO,eAAe,SAEjB,OAAO,IAAI,SAAS;AAC3B;AAEO,SAAS,4BAA4B,KAAuD;AACjG,MAAI,CAAC,sBAAsB,GAAG,GAAG;AAC/B,UAAM,IAAI,MAAM,4CAA4C;AAAA,EAC9D;AACF;AAEO,SAAS,QAAQ,KAA4B;AAClD,SAAO,eAAe;AACxB;AAEO,SAAS,kBAAkB,KAAoC;AACpE,MAAI,CAAC,QAAQ,GAAG,GAAG;AACjB,UAAM,IAAI,wBAAU,gCAAgC,EAAE,OAAO,IAAI,CAAC;AAAA,EACpE;AACF;AAEO,SAAS,SAAS,KAA6B;AACpD,SAAO,OAAO,QAAQ;AACxB;AAEO,SAAS,SAAS,KAA6B;AACpD,SAAO,OAAO,QAAQ;AACxB;AAEO,SAAS,SAAS,KAA6B;AACpD,SAAO,OAAO,QAAQ;AACxB;AAOO,SAAS,cAAc,OAAiC;AAC7D,MAAI,UAAU,QAAQ,OAAO,UAAU,UAAU;AAC/C,WAAO;AAAA,EACT;AAEA,QAAM,YAAY,OAAO,eAAe,KAAK;AAE7C,SAAO,cAAc,QAAQ,cAAc,OAAO;AACpD;AASO,SAAS,aAAa,OAAuD;AAClF,SAAO,cAAc,KAAK;AAC5B;AAcO,SAAS,YAAY,OAAwB;AAClD,SACE,OAAO,UAAU,YACd,MAAM,WAAW,GAAG,KACpB,MAAM,SAAS,GAAG;AAEzB;AAEO,SAAS,mBAAmB,KAA8C;AAC/E,SAAO,IAAI,KAAK,SAAO,cAAc,GAAG,KAAK,eAAe,kBAAK;AACnE;AAYO,SAAS,qBACd,YACA,aACA,uBACA,kBACA,iBACM;AACN,QAAM,sBAAsB,OAAO,SAAK,cAAAA,SAAO,eAAe,CAAC;AAC/D,QAAM,qBAAqB,oBAAoB,OAAO,gBAAc;AAClE,WAAO,sBAAsB,IAAI,UAAU,KAAK,CAAC,iBAAiB,IAAI,UAAU;AAAA,EAClF,CAAC;AAED,MAAI,mBAAmB,SAAS,GAAG;AACjC,UAAM,gCAAgC,YAAY,aAAa,kBAAkB;AAAA,EACnF;AACF;AAEO,SAAS,gCAAgC,YAAoB,aAAqB,gBAAiC;AACxH,SAAO,IAAI,MAAM,8CAA8C,iBAAiB,gBAAgB,eAAe,KAAK,IAAI,GAAG;AAC7H;",
  "names": ["pickBy"]
}
