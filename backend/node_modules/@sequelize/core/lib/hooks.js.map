{
  "version": 3,
  "sources": ["../src/hooks.ts"],
  "sourcesContent": ["import { Multimap } from './utils/multimap.js';\nimport type { AllowArray, Nullish } from './utils/types.js';\n\nexport type AsyncHookReturn = Promise<void> | void;\n\ntype HookParameters<Hook> = Hook extends (...args2: any) => any\n  ? Parameters<Hook>\n  : never;\n\ntype OnRunHook<HookConfig extends {}> = <HookName extends keyof HookConfig>(\n  eventTarget: object,\n  isAsync: boolean,\n  hookName: HookName,\n  args: HookParameters<HookConfig[HookName]>\n) => AsyncHookReturn;\n\n/**\n * @private\n */\nexport class HookHandler<HookConfig extends {}> {\n  #validHookNames: Array<keyof HookConfig>;\n  #eventTarget: object;\n  #listeners = new Multimap<PropertyKey, { listenerName: Nullish<string>, callback: HookConfig[keyof HookConfig] }>();\n  #onRunHook: OnRunHook<HookConfig> | undefined;\n\n  constructor(\n    eventTarget: object,\n    validHookNames: Array<keyof HookConfig>,\n    onRunHook?: OnRunHook<HookConfig>,\n  ) {\n    this.#eventTarget = eventTarget;\n    this.#validHookNames = validHookNames;\n    this.#onRunHook = onRunHook;\n  }\n\n  removeListener<HookName extends keyof HookConfig>(\n    hookName: HookName,\n    listenerOrListenerName: string | HookConfig[HookName],\n  ): void {\n    this.#assertValidHookName(hookName);\n\n    if (typeof listenerOrListenerName === 'string') {\n      const listener = this.#getNamedListener(hookName, listenerOrListenerName);\n      if (listener) {\n        this.#listeners.delete(hookName, listener);\n      }\n    } else {\n      const listeners = this.#listeners.getAll(hookName);\n      for (const listener of listeners) {\n        if (listener.callback === listenerOrListenerName) {\n          this.#listeners.delete(hookName, listener);\n        }\n      }\n    }\n  }\n\n  removeAllListeners() {\n    this.#listeners.clear();\n  }\n\n  #getNamedListener<HookName extends keyof HookConfig>(\n    hookName: HookName,\n    listenerName: string,\n  ): { listenerName: Nullish<string>, callback: HookConfig[keyof HookConfig] } | null {\n    const listeners = this.#listeners.getAll(hookName);\n    for (const listener of listeners) {\n      if (listener.listenerName === listenerName) {\n        return listener;\n      }\n    }\n\n    return null;\n  }\n\n  hasListeners(hookName: keyof HookConfig): boolean {\n    this.#assertValidHookName(hookName);\n\n    return this.#listeners.count(hookName) > 0;\n  }\n\n  getListenerCount(hookName: keyof HookConfig): number {\n    this.#assertValidHookName(hookName);\n\n    return this.#listeners.count(hookName);\n  }\n\n  runSync<HookName extends keyof HookConfig>(\n    hookName: HookName,\n    ...args: HookConfig[HookName] extends (...args2: any) => any\n      ? Parameters<HookConfig[HookName]>\n      : never\n  ): void {\n    this.#assertValidHookName(hookName);\n\n    const listeners = this.#listeners.getAll(hookName);\n    for (const listener of listeners) {\n      // @ts-expect-error -- callback can by any hook type (due to coming from the map), args is the args of a specific hook. Too hard to type properly.\n      const out = listener.callback(...args);\n\n      if (out && 'then' in out) {\n        throw new Error(`${listener.listenerName ? `Listener ${listener.listenerName}` : `An unnamed listener`} of hook ${String(hookName)} on ${getName(this.#eventTarget)} returned a Promise, but the hook is synchronous.`);\n      }\n    }\n\n    if (this.#onRunHook) {\n      void this.#onRunHook(this.#eventTarget, false, hookName, args);\n    }\n  }\n\n  async runAsync<HookName extends keyof HookConfig>(\n    hookName: HookName,\n    ...args: HookConfig[HookName] extends (...args2: any) => any\n      ? Parameters<HookConfig[HookName]>\n      : never\n  ): Promise<void> {\n    this.#assertValidHookName(hookName);\n\n    const listeners = this.#listeners.getAll(hookName);\n    for (const listener of listeners) {\n      /* eslint-disable no-await-in-loop */\n      // @ts-expect-error -- callback can by any hook type (due to coming from the map), args is the args of a specific hook. Too hard to type properly.\n      await listener.callback(...args);\n      /* eslint-enable no-await-in-loop */\n    }\n\n    if (this.#onRunHook) {\n      await this.#onRunHook(this.#eventTarget, true, hookName, args);\n    }\n  }\n\n  /**\n   * Registers a listener for a hook.\n   *\n   * Returns a function that can be called to deregister the listener.\n   *\n   * @param hookName\n   * @param listener\n   * @param listenerName\n   */\n  addListener<HookName extends keyof HookConfig>(\n    hookName: HookName,\n    listener: HookConfig[HookName],\n    listenerName?: string,\n  ): () => void {\n    this.#assertValidHookName(hookName);\n\n    if (listenerName) {\n      const existingListener = this.#getNamedListener(hookName, listenerName);\n\n      if (existingListener) {\n        throw new Error(`Named listener ${listenerName} already exists for hook ${String(hookName)} on ${getName(this.#eventTarget)}.`);\n      }\n    }\n\n    this.#listeners.append(hookName, { callback: listener, listenerName });\n\n    return () => {\n      this.removeListener(hookName, listenerName || listener);\n    };\n  }\n\n  addListeners(listeners: {\n    [Key in keyof HookConfig]?: AllowArray<HookConfig[Key] | { name: string | symbol, callback: HookConfig[Key] }>\n  }) {\n    for (const hookName of this.#validHookNames) {\n      const hookListeners = listeners[hookName];\n      if (!hookListeners) {\n        continue;\n      }\n\n      const hookListenersArray = Array.isArray(hookListeners) ? hookListeners : [hookListeners];\n      for (const listener of hookListenersArray) {\n        if (typeof listener === 'function') {\n          this.addListener(hookName, listener);\n        } else {\n          this.addListener(hookName, listener.callback, listener.name);\n        }\n      }\n    }\n  }\n\n  #assertValidHookName(hookName: any) {\n    if (!this.#validHookNames.includes(hookName)) {\n      throw new Error(`Target ${getName(this.#eventTarget)} does not support a hook named \"${String(hookName)}\".`);\n    }\n  }\n}\n\nexport class HookHandlerBuilder<HookConfig extends {}> {\n  #validHookNames: Array<keyof HookConfig>;\n  #hookHandlers = new WeakMap<object, HookHandler<HookConfig>>();\n  #onRunHook: OnRunHook<HookConfig> | undefined;\n\n  constructor(validHookNames: Array<keyof HookConfig>, onRunHook?: OnRunHook<HookConfig>) {\n    this.#validHookNames = validHookNames;\n    this.#onRunHook = onRunHook;\n  }\n\n  getFor(target: object): HookHandler<HookConfig> {\n    let hookHandler = this.#hookHandlers.get(target);\n    if (!hookHandler) {\n      hookHandler = new HookHandler<HookConfig>(target, this.#validHookNames, this.#onRunHook);\n      this.#hookHandlers.set(target, hookHandler);\n    }\n\n    return hookHandler;\n  }\n}\n\nfunction getName(obj: object) {\n  if (typeof obj === 'function') {\n    return `[class ${obj.name}]`;\n  }\n\n  return `[instance ${obj.constructor.name}]`;\n}\n"],
  "mappings": "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",
  "names": []
}
