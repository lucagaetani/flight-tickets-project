{
  "version": 3,
  "sources": ["../src/model-manager.ts"],
  "sourcesContent": ["'use strict';\n\nimport defaults from 'lodash/defaults';\n// @ts-expect-error -- toposort-class definition will be added to sequelize/toposort later\nimport Toposort from 'toposort-class';\nimport type { ModelStatic } from './model';\nimport type { Sequelize } from './sequelize';\n\nexport class ModelManager {\n  #sequelize: Sequelize;\n  declare models: ModelStatic[];\n\n  constructor(sequelize: Sequelize) {\n    this.models = [];\n    this.#sequelize = sequelize;\n  }\n\n  addModel<T extends ModelStatic>(model: T): T {\n    this.models.push(model);\n    this.#sequelize.models[model.name] = model;\n\n    return model;\n  }\n\n  removeModel(modelToRemove: ModelStatic): void {\n    this.models = this.models.filter(\n      model => model.name !== modelToRemove.name,\n    );\n\n    delete this.#sequelize.models[modelToRemove.name];\n  }\n\n  getModel(modelName: string): ModelStatic | undefined {\n    return this.models.find(model => model.name === modelName);\n  }\n\n  findModel(\n    callback: (model: ModelStatic) => boolean,\n  ): ModelStatic | undefined {\n    return this.models.find(callback);\n  }\n\n  hasModel(targetModel: ModelStatic): boolean {\n    return this.models.includes(targetModel);\n  }\n\n  get all(): ModelStatic[] {\n    return this.models;\n  }\n\n  /**\n   * Returns an array that lists every model, sorted in order\n   * of foreign key references: The first model is a model that is depended upon,\n   * the last model is a model that is not depended upon.\n   *\n   * If there is a cyclic dependency, this returns null.\n   */\n  getModelsTopoSortedByForeignKey(): ModelStatic[] | null {\n    const models = new Map();\n    const sorter = new Toposort();\n\n    const queryGenerator = this.#sequelize.queryGenerator;\n\n    for (const model of this.models) {\n      let deps = [];\n      const tableName = queryGenerator.quoteTable(model);\n\n      models.set(tableName, model);\n\n      const { attributes } = model.modelDefinition;\n      for (const attrName of attributes.keys()) {\n        const attribute = attributes.get(attrName);\n\n        if (!attribute?.references) {\n          continue;\n        }\n\n        const dep = queryGenerator.quoteTable(attribute.references.table);\n        deps.push(dep);\n      }\n\n      deps = deps.filter(dep => tableName !== dep);\n\n      sorter.add(tableName, deps);\n    }\n\n    let sorted;\n    try {\n      sorted = sorter.sort();\n    } catch (error: unknown) {\n      if (\n        error instanceof Error\n        && !error.message.startsWith('Cyclic dependency found.')\n      ) {\n        throw error;\n      }\n\n      return null;\n    }\n\n    return sorted\n      .map((modelName: string) => {\n        return models.get(modelName);\n      })\n      .filter(Boolean);\n  }\n\n  /**\n   * Iterate over Models in an order suitable for e.g. creating tables.\n   * Will take foreign key constraints into account so that dependencies are visited before dependents.\n   *\n   * @param iterator method to execute on each model\n   * @param options\n   * @param options.reverse\n   * @private\n   *\n   * @deprecated\n   */\n  forEachModel(\n    iterator: (model: ModelStatic) => void,\n    options?: { reverse?: boolean },\n  ) {\n    const sortedModels = this.getModelsTopoSortedByForeignKey();\n    if (sortedModels == null) {\n      throw new Error('Cyclic dependency found.');\n    }\n\n    options = defaults(options || {}, {\n      reverse: true,\n    });\n\n    if (options.reverse) {\n      sortedModels.reverse();\n    }\n\n    for (const model of sortedModels) {\n      iterator(model);\n    }\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA,sBAAqB;AAErB,4BAAqB;AAId,MAAM,aAAa;AAAA,EACxB;AAAA,EAGA,YAAY,WAAsB;AAChC,SAAK,SAAS,CAAC;AACf,SAAK,aAAa;AAAA,EACpB;AAAA,EAEA,SAAgC,OAAa;AAC3C,SAAK,OAAO,KAAK,KAAK;AACtB,SAAK,WAAW,OAAO,MAAM,IAAI,IAAI;AAErC,WAAO;AAAA,EACT;AAAA,EAEA,YAAY,eAAkC;AAC5C,SAAK,SAAS,KAAK,OAAO;AAAA,MACxB,WAAS,MAAM,SAAS,cAAc;AAAA,IACxC;AAEA,WAAO,KAAK,WAAW,OAAO,cAAc,IAAI;AAAA,EAClD;AAAA,EAEA,SAAS,WAA4C;AACnD,WAAO,KAAK,OAAO,KAAK,WAAS,MAAM,SAAS,SAAS;AAAA,EAC3D;AAAA,EAEA,UACE,UACyB;AACzB,WAAO,KAAK,OAAO,KAAK,QAAQ;AAAA,EAClC;AAAA,EAEA,SAAS,aAAmC;AAC1C,WAAO,KAAK,OAAO,SAAS,WAAW;AAAA,EACzC;AAAA,EAEA,IAAI,MAAqB;AACvB,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,kCAAwD;AACtD,UAAM,SAAS,oBAAI,IAAI;AACvB,UAAM,SAAS,IAAI,sBAAAA,QAAS;AAE5B,UAAM,iBAAiB,KAAK,WAAW;AAEvC,eAAW,SAAS,KAAK,QAAQ;AAC/B,UAAI,OAAO,CAAC;AACZ,YAAM,YAAY,eAAe,WAAW,KAAK;AAEjD,aAAO,IAAI,WAAW,KAAK;AAE3B,YAAM,EAAE,WAAW,IAAI,MAAM;AAC7B,iBAAW,YAAY,WAAW,KAAK,GAAG;AACxC,cAAM,YAAY,WAAW,IAAI,QAAQ;AAEzC,YAAI,EAAC,uCAAW,aAAY;AAC1B;AAAA,QACF;AAEA,cAAM,MAAM,eAAe,WAAW,UAAU,WAAW,KAAK;AAChE,aAAK,KAAK,GAAG;AAAA,MACf;AAEA,aAAO,KAAK,OAAO,SAAO,cAAc,GAAG;AAE3C,aAAO,IAAI,WAAW,IAAI;AAAA,IAC5B;AAEA,QAAI;AACJ,QAAI;AACF,eAAS,OAAO,KAAK;AAAA,IACvB,SAAS,OAAP;AACA,UACE,iBAAiB,SACd,CAAC,MAAM,QAAQ,WAAW,0BAA0B,GACvD;AACA,cAAM;AAAA,MACR;AAEA,aAAO;AAAA,IACT;AAEA,WAAO,OACJ,IAAI,CAAC,cAAsB;AAC1B,aAAO,OAAO,IAAI,SAAS;AAAA,IAC7B,CAAC,EACA,OAAO,OAAO;AAAA,EACnB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAaA,aACE,UACA,SACA;AACA,UAAM,eAAe,KAAK,gCAAgC;AAC1D,QAAI,gBAAgB,MAAM;AACxB,YAAM,IAAI,MAAM,0BAA0B;AAAA,IAC5C;AAEA,kBAAU,gBAAAC,SAAS,WAAW,CAAC,GAAG;AAAA,MAChC,SAAS;AAAA,IACX,CAAC;AAED,QAAI,QAAQ,SAAS;AACnB,mBAAa,QAAQ;AAAA,IACvB;AAEA,eAAW,SAAS,cAAc;AAChC,eAAS,KAAK;AAAA,IAChB;AAAA,EACF;AACF;",
  "names": ["Toposort", "defaults"]
}
