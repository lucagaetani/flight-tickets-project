{
  "version": 3,
  "sources": ["../src/model-internals.ts"],
  "sourcesContent": ["import NodeUtil from 'node:util';\nimport type { IndexOptions } from './dialects/abstract/query-interface.js';\nimport { EagerLoadingError } from './errors';\nimport type { Transactionable } from './model';\nimport type { Sequelize } from './sequelize';\nimport { isModelStatic } from './utils/model-utils.js';\n// TODO: strictly type this file during the TS migration of model.js\n\n// The goal of this file is to include the different private methods that are currently present on the Model class.\n// This reduces the risk of having a user implement a static method with the same name as us in their Model subclass,\n// it also prevents accessing internal methods.\n\nexport function _validateIncludedElements(options: any, tableNames: any = {}) {\n  if (!isModelStatic(options.model)) {\n    throw new TypeError('options.model must be provided, and a Model subclass.');\n  }\n\n  const ModelSubclass = options.model;\n\n  options.includeNames = [];\n  options.includeMap = {};\n\n  /* Legacy */\n  options.hasSingleAssociation = false;\n  options.hasMultiAssociation = false;\n\n  if (!options.parent) {\n    options.topModel = options.model;\n    options.topLimit = options.limit;\n  }\n\n  options.include = options.include.map((include: any) => {\n    include = ModelSubclass._conformInclude(include, options.model);\n    include.parent = options;\n    include.topLimit = options.topLimit;\n\n    ModelSubclass._validateIncludedElement.call(options.model, include, tableNames, options);\n\n    if (include.duplicating === undefined) {\n      include.duplicating = include.association.isMultiAssociation;\n    }\n\n    include.hasDuplicating = include.hasDuplicating || include.duplicating;\n    include.hasRequired = include.hasRequired || include.required;\n\n    options.hasDuplicating = options.hasDuplicating || include.hasDuplicating;\n    options.hasRequired = options.hasRequired || include.required;\n\n    options.hasWhere = options.hasWhere || include.hasWhere || Boolean(include.where);\n\n    return include;\n  });\n\n  for (const include of options.include) {\n    include.hasParentWhere = options.hasParentWhere || Boolean(options.where);\n    include.hasParentRequired = options.hasParentRequired || Boolean(options.required);\n\n    if (include.subQuery !== false && options.hasDuplicating && options.topLimit) {\n      if (include.duplicating) {\n        include.subQuery = include.subQuery || false;\n        include.subQueryFilter = include.hasRequired;\n      } else {\n        include.subQuery = include.hasRequired;\n        include.subQueryFilter = false;\n      }\n    } else {\n      include.subQuery = include.subQuery || false;\n      if (include.duplicating) {\n        include.subQueryFilter = include.subQuery;\n      } else {\n        include.subQueryFilter = false;\n        include.subQuery = include.subQuery || include.hasParentRequired && include.hasRequired && !include.separate;\n      }\n    }\n\n    options.includeMap[include.as] = include;\n    options.includeNames.push(include.as);\n\n    // Set top level options\n    if (options.topModel === options.model && options.subQuery === undefined && options.topLimit) {\n      if (include.subQuery) {\n        options.subQuery = include.subQuery;\n      } else if (include.hasDuplicating) {\n        options.subQuery = true;\n      }\n    }\n\n    /* Legacy */\n    options.hasIncludeWhere = options.hasIncludeWhere || include.hasIncludeWhere || Boolean(include.where);\n    options.hasIncludeRequired = options.hasIncludeRequired || include.hasIncludeRequired || Boolean(include.required);\n\n    if (include.association.isMultiAssociation || include.hasMultiAssociation) {\n      options.hasMultiAssociation = true;\n    }\n\n    if (include.association.isSingleAssociation || include.hasSingleAssociation) {\n      options.hasSingleAssociation = true;\n    }\n  }\n\n  if (options.topModel === options.model && options.subQuery === undefined) {\n    options.subQuery = false;\n  }\n\n  return options;\n}\n\nexport function combineIncludes(a: any, b: any): any {\n  if (a == null) {\n    return b;\n  }\n\n  if (b == null) {\n    return a;\n  }\n\n  if (!Array.isArray(a) || !Array.isArray(b)) {\n    throw new TypeError('Includes should have already been normalized before calling this method, but it received something else than an array.');\n  }\n\n  const combinedIncludes = [...a];\n\n  for (const newInclude of b) {\n    const existingIndex = combinedIncludes.findIndex(include => {\n      if (!include.association || !newInclude.association) {\n        throw new TypeError('Include should have been normalized');\n      }\n\n      return include.association === newInclude.association;\n    });\n\n    if (existingIndex === -1) {\n      combinedIncludes.push(newInclude);\n      continue;\n    }\n\n    const ModelClass = newInclude.model;\n    // _assignOptions *must* be called on the class of the Include's Model,\n    //  otherwise the Include's includes won't be checked correctly.\n    ModelClass._assignOptions(combinedIncludes[existingIndex], newInclude);\n  }\n\n  return combinedIncludes;\n}\n\nexport function throwInvalidInclude(include: any): never {\n  throw new EagerLoadingError(`Invalid Include received. Include has to be either a Model, an Association, the name of an association, or a plain object compatible with IncludeOptions.\nGot ${NodeUtil.inspect(include)} instead`);\n}\n\nexport function setTransactionFromCls(options: Transactionable, sequelize: Sequelize): void {\n  if (options.transaction && (options.connection && options.connection !== options.transaction.getConnection())) {\n    throw new Error(`You are using mismatching \"transaction\" and \"connection\" options. Please pass either one of them, or make sure they're both using the same connection.`);\n  }\n\n  if (options.transaction === undefined && options.connection == null) {\n    options.transaction = sequelize.getCurrentClsTransaction();\n  }\n\n  if (options.connection) {\n    const clsTransaction = sequelize.getCurrentClsTransaction();\n    const transactionConnection = clsTransaction?.getConnectionIfExists();\n    if (transactionConnection && transactionConnection === options.connection) {\n      options.transaction = clsTransaction;\n    }\n  } else {\n    options.connection = options.transaction?.getConnectionIfExists();\n  }\n}\n\nexport function conformIndex(index: IndexOptions): IndexOptions {\n  if (!index.fields) {\n    throw new Error('Missing \"fields\" property for index definition');\n  }\n\n  index = { ...index };\n\n  if (index.type && index.type.toLowerCase() === 'unique') {\n    index.unique = true;\n    delete index.type;\n  }\n\n  return index;\n}\n"],
  "mappings": "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",
  "names": ["NodeUtil"]
}
