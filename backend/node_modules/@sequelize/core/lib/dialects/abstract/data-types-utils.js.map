{
  "version": 3,
  "sources": ["../../../src/dialects/abstract/data-types-utils.ts"],
  "sourcesContent": ["import NodeUtils from 'node:util';\nimport { BaseError, ValidationErrorItem } from '../../errors/index.js';\nimport type { Model } from '../../model.js';\nimport type { DataType, DataTypeClass, DataTypeClassOrInstance, DataTypeInstance } from './data-types.js';\nimport { AbstractDataType } from './data-types.js';\nimport type { AbstractDialect } from './index.js';\n\nexport function isDataType(value: any): value is DataType {\n  return isDataTypeClass(value) || value instanceof AbstractDataType;\n}\n\nexport function isDataTypeClass(value: any): value is DataTypeClass {\n  return typeof value === 'function' && value.prototype instanceof AbstractDataType;\n}\n\nexport function cloneDataType(value: DataTypeInstance | string): DataTypeInstance | string {\n  if (typeof value === 'string') {\n    return value;\n  }\n\n  return value.clone();\n}\n\nexport function normalizeDataType(Type: DataTypeClassOrInstance, dialect: AbstractDialect): AbstractDataType<unknown>;\nexport function normalizeDataType(Type: string, dialect: AbstractDialect): string;\nexport function normalizeDataType(\n  Type: DataTypeClassOrInstance | string,\n  dialect: AbstractDialect,\n): AbstractDataType<unknown> | string {\n  if (typeof Type === 'string') {\n    return Type;\n  }\n\n  if (typeof Type !== 'function' && !(Type instanceof AbstractDataType)) {\n    throw new TypeError(`Expected type to be a string, a DataType class, or a DataType instance, but got ${NodeUtils.inspect(Type)}.`);\n  }\n\n  const type = dataTypeClassOrInstanceToInstance(Type);\n\n  if (!type.belongsToDialect(dialect)) {\n    return type.toDialectDataType(dialect);\n  }\n\n  return type;\n}\n\nexport function dataTypeClassOrInstanceToInstance(Type: DataTypeClassOrInstance): DataTypeInstance {\n  return typeof Type === 'function'\n    ? new Type()\n    : Type;\n}\n\nexport function validateDataType(\n  value: unknown,\n  type: AbstractDataType<any>,\n  attributeName: string = '[unnamed]',\n  modelInstance: Model<any> | null = null,\n): ValidationErrorItem | null {\n  try {\n    type.validate(value);\n\n    return null;\n  } catch (error) {\n    if (!(error instanceof ValidationErrorItem)) {\n      throw new BaseError(`Validation encountered an unexpected error while validating attribute ${attributeName}. (Note: If this error is intended, ${type.constructor.name}#validate must throw an instance of ValidationErrorItem instead)`, {\n        cause: error,\n      });\n    }\n\n    error.path = attributeName;\n    error.value = value;\n    error.instance = modelInstance;\n    // @ts-expect-error -- untyped constructor\n    error.validatorKey = `${type.constructor.getDataTypeId()} validator`;\n\n    return error;\n  }\n}\n\nexport function attributeTypeToSql(type: AbstractDataType<any> | string): string {\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  if (type instanceof AbstractDataType) {\n    return type.toSql();\n  }\n\n  throw new Error('attributeTypeToSql received a type that is neither a string or an instance of AbstractDataType');\n}\n\nexport function getDataTypeParser(dialect: AbstractDialect, dataType: DataTypeClassOrInstance): (value: unknown) => unknown {\n  const type = normalizeDataType(dataType, dialect);\n\n  return (value: unknown) => {\n    return type.parseDatabaseValue(value);\n  };\n}\n\nexport function throwUnsupportedDataType(dialect: AbstractDialect, typeName: string): never {\n  throw new Error(`${dialect.name} does not support the ${typeName} data type.\nSee https://sequelize.org/docs/v7/other-topics/other-data-types/ for a list of supported data types.`);\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAAsB;AACtB,oBAA+C;AAG/C,wBAAiC;AAG1B,SAAS,WAAW,OAA+B;AACxD,SAAO,gBAAgB,KAAK,KAAK,iBAAiB;AACpD;AAEO,SAAS,gBAAgB,OAAoC;AAClE,SAAO,OAAO,UAAU,cAAc,MAAM,qBAAqB;AACnE;AAEO,SAAS,cAAc,OAA6D;AACzF,MAAI,OAAO,UAAU,UAAU;AAC7B,WAAO;AAAA,EACT;AAEA,SAAO,MAAM,MAAM;AACrB;AAIO,SAAS,kBACd,MACA,SACoC;AACpC,MAAI,OAAO,SAAS,UAAU;AAC5B,WAAO;AAAA,EACT;AAEA,MAAI,OAAO,SAAS,cAAc,EAAE,gBAAgB,qCAAmB;AACrE,UAAM,IAAI,UAAU,mFAAmF,iBAAAA,QAAU,QAAQ,IAAI,IAAI;AAAA,EACnI;AAEA,QAAM,OAAO,kCAAkC,IAAI;AAEnD,MAAI,CAAC,KAAK,iBAAiB,OAAO,GAAG;AACnC,WAAO,KAAK,kBAAkB,OAAO;AAAA,EACvC;AAEA,SAAO;AACT;AAEO,SAAS,kCAAkC,MAAiD;AACjG,SAAO,OAAO,SAAS,aACnB,IAAI,KAAK,IACT;AACN;AAEO,SAAS,iBACd,OACA,MACA,gBAAwB,aACxB,gBAAmC,MACP;AAC5B,MAAI;AACF,SAAK,SAAS,KAAK;AAEnB,WAAO;AAAA,EACT,SAAS,OAAP;AACA,QAAI,EAAE,iBAAiB,oCAAsB;AAC3C,YAAM,IAAI,wBAAU,yEAAyE,oDAAoD,KAAK,YAAY,wEAAwE;AAAA,QACxO,OAAO;AAAA,MACT,CAAC;AAAA,IACH;AAEA,UAAM,OAAO;AACb,UAAM,QAAQ;AACd,UAAM,WAAW;AAEjB,UAAM,eAAe,GAAG,KAAK,YAAY,cAAc;AAEvD,WAAO;AAAA,EACT;AACF;AAEO,SAAS,mBAAmB,MAA8C;AAC/E,MAAI,OAAO,SAAS,UAAU;AAC5B,WAAO;AAAA,EACT;AAEA,MAAI,gBAAgB,oCAAkB;AACpC,WAAO,KAAK,MAAM;AAAA,EACpB;AAEA,QAAM,IAAI,MAAM,gGAAgG;AAClH;AAEO,SAAS,kBAAkB,SAA0B,UAAgE;AAC1H,QAAM,OAAO,kBAAkB,UAAU,OAAO;AAEhD,SAAO,CAAC,UAAmB;AACzB,WAAO,KAAK,mBAAmB,KAAK;AAAA,EACtC;AACF;AAEO,SAAS,yBAAyB,SAA0B,UAAyB;AAC1F,QAAM,IAAI,MAAM,GAAG,QAAQ,6BAA6B;AAAA,qGAC2C;AACrG;",
  "names": ["NodeUtils"]
}
