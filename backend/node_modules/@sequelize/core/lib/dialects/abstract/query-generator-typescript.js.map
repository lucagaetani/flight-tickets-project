{
  "version": 3,
  "sources": ["../../../src/dialects/abstract/query-generator-typescript.ts"],
  "sourcesContent": ["import NodeUtil from 'node:util';\nimport isObject from 'lodash/isObject';\nimport type { Class } from 'type-fest';\nimport { ConstraintChecking, Deferrable } from '../../deferrable.js';\nimport { AssociationPath } from '../../expression-builders/association-path.js';\nimport { Attribute } from '../../expression-builders/attribute.js';\nimport { BaseSqlExpression } from '../../expression-builders/base-sql-expression.js';\nimport { Cast } from '../../expression-builders/cast.js';\nimport { Col } from '../../expression-builders/col.js';\nimport { DialectAwareFn } from '../../expression-builders/dialect-aware-fn.js';\nimport { Fn } from '../../expression-builders/fn.js';\nimport { Identifier } from '../../expression-builders/identifier.js';\nimport { JsonPath } from '../../expression-builders/json-path.js';\nimport { List } from '../../expression-builders/list.js';\nimport { Literal } from '../../expression-builders/literal.js';\nimport { Value } from '../../expression-builders/value.js';\nimport { Where } from '../../expression-builders/where.js';\nimport { IndexHints } from '../../index-hints.js';\nimport type { Attributes, Model, ModelStatic } from '../../model.js';\nimport { Op } from '../../operators.js';\nimport type { BindOrReplacements, Expression, Sequelize } from '../../sequelize.js';\nimport { bestGuessDataTypeOfVal } from '../../sql-string.js';\nimport { TableHints } from '../../table-hints.js';\nimport { isDictionary, isNullish, isPlainObject, isString, rejectInvalidOptions } from '../../utils/check.js';\nimport { noOpCol } from '../../utils/deprecations.js';\nimport { quoteIdentifier } from '../../utils/dialect.js';\nimport { joinSQLFragments } from '../../utils/join-sql-fragments.js';\nimport { isModelStatic } from '../../utils/model-utils.js';\nimport { EMPTY_OBJECT } from '../../utils/object.js';\nimport { injectReplacements } from '../../utils/sql.js';\nimport { attributeTypeToSql, validateDataType } from './data-types-utils.js';\nimport { AbstractDataType } from './data-types.js';\nimport type { BindParamOptions, DataType } from './data-types.js';\nimport type { AbstractQueryGenerator } from './query-generator.js';\nimport type {\n  AddConstraintQueryOptions,\n  DropTableQueryOptions,\n  GetConstraintSnippetQueryOptions,\n  ListSchemasQueryOptions,\n  ListTablesQueryOptions,\n  QuoteTableOptions,\n  RemoveColumnQueryOptions,\n  RemoveConstraintQueryOptions,\n  ShowConstraintsQueryOptions,\n} from './query-generator.types.js';\nimport type { TableName, TableNameWithSchema } from './query-interface.js';\nimport type { WhereOptions } from './where-sql-builder-types.js';\nimport { PojoWhere, WhereSqlBuilder, wrapAmbiguousWhere } from './where-sql-builder.js';\nimport type { AbstractDialect } from './index.js';\n\nexport type TableNameOrModel = TableName | ModelStatic;\n\n// keep REMOVE_INDEX_QUERY_SUPPORTABLE_OPTIONS updated when modifying this\nexport interface RemoveIndexQueryOptions {\n  concurrently?: boolean;\n  ifExists?: boolean;\n  cascade?: boolean;\n}\n\nexport const DROP_TABLE_QUERY_SUPPORTABLE_OPTIONS = new Set<keyof DropTableQueryOptions>(['cascade']);\nexport const LIST_TABLES_QUERY_SUPPORTABLE_OPTIONS = new Set<keyof ListTablesQueryOptions>(['schema']);\nexport const QUOTE_TABLE_SUPPORTABLE_OPTIONS = new Set<keyof QuoteTableOptions>(['indexHints', 'tableHints']);\nexport const REMOVE_COLUMN_QUERY_SUPPORTABLE_OPTIONS = new Set<keyof RemoveColumnQueryOptions>(['ifExists', 'cascade']);\nexport const REMOVE_CONSTRAINT_QUERY_SUPPORTABLE_OPTIONS = new Set<keyof RemoveConstraintQueryOptions>(['ifExists', 'cascade']);\nexport const REMOVE_INDEX_QUERY_SUPPORTABLE_OPTIONS = new Set<keyof RemoveIndexQueryOptions>(['concurrently', 'ifExists', 'cascade']);\nexport const SHOW_CONSTRAINTS_QUERY_SUPPORTABLE_OPTIONS = new Set<keyof ShowConstraintsQueryOptions>(['columnName', 'constraintName', 'constraintType']);\n\nexport interface QueryGeneratorOptions {\n  sequelize: Sequelize;\n  dialect: AbstractDialect;\n}\n\n/**\n * Options accepted by {@link AbstractQueryGeneratorTypeScript#escape}\n */\nexport interface EscapeOptions extends FormatWhereOptions {\n  readonly type?: DataType | undefined;\n}\n\nexport interface FormatWhereOptions extends Bindable {\n  /**\n   * These are used to inline replacements into the query, when one is found inside of a {@link Literal}.\n   */\n  readonly replacements?: BindOrReplacements | undefined;\n\n  /**\n   * The model of the main alias. Used to determine the type & column name of attributes referenced in the where clause.\n   */\n  readonly model?: ModelStatic | undefined;\n\n  /**\n   * The alias of the main table corresponding to {@link FormatWhereOptions.model}.\n   * Used as the prefix for attributes that do not reference an association, e.g.\n   *\n   * ```ts\n   * const where = { name: 'foo' };\n   * ```\n   *\n   * will produce\n   *\n   * ```sql\n   * WHERE \"<mainAlias>\".\"name\" = 'foo'\n   * ```\n   */\n  readonly mainAlias?: string | undefined;\n}\n\n/**\n * Methods that support this option are functions that add values to the query.\n * If {@link Bindable.bindParam} is specified, the value will be added to the query as a bind parameter.\n * If it is not specified, the value will be added to the query as a literal.\n */\nexport interface Bindable {\n  bindParam?: ((value: unknown) => string) | undefined;\n}\n\n// DO NOT MAKE THIS CLASS PUBLIC!\n/**\n * This is a temporary class used to progressively migrate the AbstractQueryGenerator class to TypeScript by slowly moving its functions here.\n * Always use {@link AbstractQueryGenerator} instead.\n */\nexport class AbstractQueryGeneratorTypeScript {\n\n  protected readonly whereSqlBuilder: WhereSqlBuilder;\n  readonly dialect: AbstractDialect;\n  protected readonly sequelize: Sequelize;\n\n  constructor(options: QueryGeneratorOptions) {\n    if (!options.sequelize) {\n      throw new Error('QueryGenerator initialized without options.sequelize');\n    }\n\n    if (!options.dialect) {\n      throw new Error('QueryGenerator initialized without options.dialect');\n    }\n\n    this.sequelize = options.sequelize;\n    this.dialect = options.dialect;\n    // TODO: remove casting once all AbstractQueryGenerator functions are moved here\n    this.whereSqlBuilder = new WhereSqlBuilder(this as unknown as AbstractQueryGenerator);\n  }\n\n  protected get options() {\n    return this.sequelize.options;\n  }\n\n  protected _getTechnicalSchemaNames(): string[] {\n    return [];\n  }\n\n  listSchemasQuery(_options?: ListSchemasQueryOptions): string {\n    if (this.dialect.supports.schemas) {\n      throw new Error(`${this.dialect.name} declares supporting schema but listSchemasQuery is not implemented.`);\n    }\n\n    throw new Error(`Schemas are not supported in ${this.dialect.name}.`);\n  }\n\n  describeTableQuery(tableName: TableNameOrModel) {\n    return `DESCRIBE ${this.quoteTable(tableName)};`;\n  }\n\n  dropTableQuery(tableName: TableNameOrModel, options?: DropTableQueryOptions): string {\n    const DROP_TABLE_QUERY_SUPPORTED_OPTIONS = new Set<keyof DropTableQueryOptions>();\n\n    if (this.dialect.supports.dropTable.cascade) {\n      DROP_TABLE_QUERY_SUPPORTED_OPTIONS.add('cascade');\n    }\n\n    if (options) {\n      rejectInvalidOptions(\n        'dropTableQuery',\n        this.dialect.name,\n        DROP_TABLE_QUERY_SUPPORTABLE_OPTIONS,\n        DROP_TABLE_QUERY_SUPPORTED_OPTIONS,\n        options,\n      );\n    }\n\n    return joinSQLFragments([\n      'DROP TABLE IF EXISTS',\n      this.quoteTable(tableName),\n      options?.cascade ? 'CASCADE' : '',\n    ]);\n  }\n\n  listTablesQuery(_options?: ListTablesQueryOptions): string {\n    throw new Error(`listTablesQuery has not been implemented in ${this.dialect.name}.`);\n  }\n\n  removeColumnQuery(tableName: TableNameOrModel, columnName: string, options?: RemoveColumnQueryOptions): string {\n    if (options) {\n      const REMOVE_COLUMN_QUERY_SUPPORTED_OPTIONS = new Set<keyof RemoveColumnQueryOptions>();\n\n      if (this.dialect.supports.removeColumn.cascade) {\n        REMOVE_COLUMN_QUERY_SUPPORTED_OPTIONS.add('cascade');\n      }\n\n      if (this.dialect.supports.removeColumn.ifExists) {\n        REMOVE_COLUMN_QUERY_SUPPORTED_OPTIONS.add('ifExists');\n      }\n\n      rejectInvalidOptions(\n        'removeColumnQuery',\n        this.dialect.name,\n        REMOVE_COLUMN_QUERY_SUPPORTABLE_OPTIONS,\n        REMOVE_COLUMN_QUERY_SUPPORTED_OPTIONS,\n        options,\n      );\n    }\n\n    return joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(tableName),\n      'DROP COLUMN',\n      options?.ifExists ? 'IF EXISTS' : '',\n      this.quoteIdentifier(columnName),\n      options?.cascade ? 'CASCADE' : '',\n    ]);\n  }\n\n  addConstraintQuery(tableName: TableNameOrModel, options: AddConstraintQueryOptions): string {\n    if (!this.dialect.supports.constraints.add) {\n      throw new Error(`Add constraint queries are not supported by ${this.dialect.name} dialect`);\n    }\n\n    return joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(tableName),\n      'ADD',\n      this._getConstraintSnippet(tableName, options),\n    ]);\n  }\n\n  _getConstraintSnippet(tableName: TableNameOrModel, options: GetConstraintSnippetQueryOptions) {\n    const quotedFields = options.fields.map(field => {\n      if (typeof field === 'string') {\n        return this.quoteIdentifier(field);\n      }\n\n      if (field instanceof BaseSqlExpression) {\n        return this.formatSqlExpression(field);\n      }\n\n      if (field.attribute) {\n        throw new Error('The field.attribute property has been removed. Use the field.name property instead');\n      }\n\n      if (!field.name) {\n        throw new Error(`The following index field has no name: ${field}`);\n      }\n\n      return this.quoteIdentifier(field.name);\n    });\n\n    const constraintNameParts = options.name ? null : options.fields.map(field => {\n      if (typeof field === 'string') {\n        return field;\n      }\n\n      if (field instanceof BaseSqlExpression) {\n        throw new TypeError(`The constraint name must be provided explicitly if one of Sequelize's method (literal(), col(), etc\u2026) is used in the constraint's fields`);\n      }\n\n      return field.name;\n    });\n\n    let constraintSnippet;\n    const table = this.extractTableDetails(tableName);\n    const fieldsSqlQuotedString = quotedFields.join(', ');\n    const fieldsSqlString = constraintNameParts?.join('_');\n\n    switch (options.type.toUpperCase()) {\n      case 'CHECK': {\n        if (!this.dialect.supports.constraints.check) {\n          throw new Error(`Check constraints are not supported by ${this.dialect.name} dialect`);\n        }\n\n        const constraintName = this.quoteIdentifier(options.name || `${table.tableName}_${fieldsSqlString}_ck`);\n        constraintSnippet = `CONSTRAINT ${constraintName} CHECK (${this.whereItemsQuery(options.where)})`;\n        break;\n      }\n\n      case 'UNIQUE': {\n        if (!this.dialect.supports.constraints.unique) {\n          throw new Error(`Unique constraints are not supported by ${this.dialect.name} dialect`);\n        }\n\n        const constraintName = this.quoteIdentifier(options.name || `${table.tableName}_${fieldsSqlString}_uk`);\n        constraintSnippet = `CONSTRAINT ${constraintName} UNIQUE (${fieldsSqlQuotedString})`;\n        if (options.deferrable) {\n          constraintSnippet += ` ${this._getDeferrableConstraintSnippet(options.deferrable)}`;\n        }\n\n        break;\n      }\n\n      case 'DEFAULT': {\n        if (!this.dialect.supports.constraints.default) {\n          throw new Error(`Default constraints are not supported by ${this.dialect.name} dialect`);\n        }\n\n        if (options.defaultValue === undefined) {\n          throw new Error('Default value must be specified for DEFAULT CONSTRAINT');\n        }\n\n        const constraintName = this.quoteIdentifier(options.name || `${table.tableName}_${fieldsSqlString}_df`);\n        constraintSnippet = `CONSTRAINT ${constraintName} DEFAULT (${this.escape(options.defaultValue, options)}) FOR ${quotedFields[0]}`;\n        break;\n      }\n\n      case 'PRIMARY KEY': {\n        if (!this.dialect.supports.constraints.primaryKey) {\n          throw new Error(`Primary key constraints are not supported by ${this.dialect.name} dialect`);\n        }\n\n        const constraintName = this.quoteIdentifier(options.name || `${table.tableName}_${fieldsSqlString}_pk`);\n        constraintSnippet = `CONSTRAINT ${constraintName} PRIMARY KEY (${fieldsSqlQuotedString})`;\n        if (options.deferrable) {\n          constraintSnippet += ` ${this._getDeferrableConstraintSnippet(options.deferrable)}`;\n        }\n\n        break;\n      }\n\n      case 'FOREIGN KEY': {\n        if (!this.dialect.supports.constraints.foreignKey) {\n          throw new Error(`Foreign key constraints are not supported by ${this.dialect.name} dialect`);\n        }\n\n        const references = options.references;\n        if (!references || !references.table || !(references.field || references.fields)) {\n          throw new Error('Invalid foreign key constraint options. `references` object with `table` and `field` must be specified');\n        }\n\n        const referencedTable = this.extractTableDetails(references.table);\n        const constraintName = this.quoteIdentifier(options.name || `${table.tableName}_${fieldsSqlString}_${referencedTable.tableName}_fk`);\n        const quotedReferences\n          = references.field !== undefined\n          ? this.quoteIdentifier(references.field)\n          : references.fields!.map(f => this.quoteIdentifier(f)).join(', ');\n        const referencesSnippet = `${this.quoteTable(referencedTable)} (${quotedReferences})`;\n        constraintSnippet = `CONSTRAINT ${constraintName} `;\n        constraintSnippet += `FOREIGN KEY (${fieldsSqlQuotedString}) REFERENCES ${referencesSnippet}`;\n        if (options.onUpdate) {\n          if (!this.dialect.supports.constraints.onUpdate) {\n            throw new Error(`Foreign key constraint with onUpdate is not supported by ${this.dialect.name} dialect`);\n          }\n\n          constraintSnippet += ` ON UPDATE ${options.onUpdate.toUpperCase()}`;\n        }\n\n        if (options.onDelete) {\n          constraintSnippet += ` ON DELETE ${options.onDelete.toUpperCase()}`;\n        }\n\n        if (options.deferrable) {\n          constraintSnippet += ` ${this._getDeferrableConstraintSnippet(options.deferrable)}`;\n        }\n\n        break;\n      }\n\n      default: {\n        throw new Error(`Constraint type ${options.type} is not supported by ${this.dialect.name} dialect`);\n      }\n    }\n\n    return constraintSnippet;\n  }\n\n  protected _getDeferrableConstraintSnippet(deferrable: Deferrable) {\n    if (!this.dialect.supports.constraints.deferrable) {\n      throw new Error(`Deferrable constraints are not supported by ${this.dialect.name} dialect`);\n    }\n\n    switch (deferrable) {\n      case Deferrable.INITIALLY_DEFERRED: {\n        return 'DEFERRABLE INITIALLY DEFERRED';\n      }\n\n      case Deferrable.INITIALLY_IMMEDIATE: {\n        return 'DEFERRABLE INITIALLY IMMEDIATE';\n      }\n\n      case Deferrable.NOT: {\n        return 'NOT DEFERRABLE';\n      }\n\n      default: {\n        throw new Error(`Unknown constraint checking behavior ${deferrable}`);\n      }\n    }\n  }\n\n  removeConstraintQuery(tableName: TableNameOrModel, constraintName: string, options?: RemoveConstraintQueryOptions) {\n    if (!this.dialect.supports.constraints.remove) {\n      throw new Error(`Remove constraint queries are not supported by ${this.dialect.name} dialect`);\n    }\n\n    if (options) {\n      const REMOVE_CONSTRAINT_QUERY_SUPPORTED_OPTIONS = new Set<keyof RemoveConstraintQueryOptions>();\n      const { removeOptions } = this.dialect.supports.constraints;\n      if (removeOptions.cascade) {\n        REMOVE_CONSTRAINT_QUERY_SUPPORTED_OPTIONS.add('cascade');\n      }\n\n      if (removeOptions.ifExists) {\n        REMOVE_CONSTRAINT_QUERY_SUPPORTED_OPTIONS.add('ifExists');\n      }\n\n      rejectInvalidOptions(\n        'removeConstraintQuery',\n        this.dialect.name,\n        REMOVE_CONSTRAINT_QUERY_SUPPORTABLE_OPTIONS,\n        REMOVE_CONSTRAINT_QUERY_SUPPORTED_OPTIONS,\n        options,\n      );\n    }\n\n    return joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(tableName),\n      'DROP CONSTRAINT',\n      options?.ifExists ? 'IF EXISTS' : '',\n      this.quoteIdentifier(constraintName),\n      options?.cascade ? 'CASCADE' : '',\n    ]);\n  }\n\n  setConstraintCheckingQuery(type: ConstraintChecking): string;\n  setConstraintCheckingQuery(type: Class<ConstraintChecking>, constraints?: readonly string[]): string;\n  setConstraintCheckingQuery(type: ConstraintChecking | Class<ConstraintChecking>, constraints?: readonly string[]) {\n    if (!this.dialect.supports.constraints.deferrable) {\n      throw new Error(`Deferrable constraints are not supported by ${this.dialect.name} dialect`);\n    }\n\n    let constraintFragment = 'ALL';\n    if (type instanceof ConstraintChecking) {\n      if (type.constraints?.length) {\n        constraintFragment = type.constraints.map(constraint => this.quoteIdentifier(constraint)).join(', ');\n      }\n\n      return `SET CONSTRAINTS ${constraintFragment} ${type.toString()}`;\n    }\n\n    if (constraints?.length) {\n      constraintFragment = constraints.map(constraint => this.quoteIdentifier(constraint)).join(', ');\n    }\n\n    return `SET CONSTRAINTS ${constraintFragment} ${type.toString()}`;\n  }\n\n  showConstraintsQuery(_tableName: TableNameOrModel, _options?: ShowConstraintsQueryOptions): string {\n    throw new Error(`showConstraintsQuery has not been implemented in ${this.dialect.name}.`);\n  }\n\n  showIndexesQuery(_tableName: TableNameOrModel): string {\n    throw new Error(`showIndexesQuery has not been implemented in ${this.dialect.name}.`);\n  }\n\n  removeIndexQuery(\n    _tableName: TableNameOrModel,\n    _indexNameOrAttributes: string | string [],\n    _options?: RemoveIndexQueryOptions,\n  ): string {\n    throw new Error(`removeIndexQuery has not been implemented in ${this.dialect.name}.`);\n  }\n\n  /**\n   * Generates an SQL query that returns all foreign keys of a table or the foreign key constraint of a given column.\n   *\n   * @deprecated Use {@link showConstraintsQuery} instead.\n   * @param _tableName The table or associated model.\n   * @param _columnName The name of the column. Not supported by SQLite.\n   * @returns The generated SQL query.\n   */\n  getForeignKeyQuery(_tableName: TableNameOrModel, _columnName?: string): Error {\n    throw new Error(`getForeignKeyQuery has been deprecated. Use showConstraintsQuery instead.`);\n  }\n\n  /**\n   * Generates an SQL query that drops a foreign key constraint.\n   *\n   * @deprecated Use {@link removeConstraintQuery} instead.\n   * @param _tableName The table or associated model.\n   * @param _foreignKey The name of the foreign key constraint.\n   */\n  dropForeignKeyQuery(_tableName: TableNameOrModel, _foreignKey: string): Error {\n    throw new Error(`dropForeignKeyQuery has been deprecated. Use removeConstraintQuery instead.`);\n  }\n\n  // TODO: rename to \"normalizeTable\" & move to sequelize class\n  extractTableDetails(\n    tableNameOrModel: TableNameOrModel,\n    options?: { schema?: string, delimiter?: string },\n  ): TableNameWithSchema {\n    const tableNameObject = isModelStatic(tableNameOrModel) ? tableNameOrModel.getTableName()\n      : isString(tableNameOrModel) ? { tableName: tableNameOrModel }\n      : tableNameOrModel;\n\n    if (!isPlainObject(tableNameObject)) {\n      throw new Error(`Invalid input received, got ${NodeUtil.inspect(tableNameOrModel)}, expected a Model Class, a TableNameWithSchema object, or a table name string`);\n    }\n\n    // @ts-expect-error -- TODO: this is added by getTableName on model, and must be removed\n    delete tableNameObject.toString;\n\n    return {\n      ...tableNameObject,\n      schema: options?.schema || tableNameObject.schema || this.options.schema || this.dialect.getDefaultSchema(),\n      delimiter: options?.delimiter || tableNameObject.delimiter || '.',\n    };\n  }\n\n  /**\n   * Quote table name with optional alias and schema attribution\n   *\n   * @param param table string or object\n   * @param options options\n   */\n  quoteTable(param: TableNameOrModel, options?: QuoteTableOptions): string {\n    const QUOTE_TABLE_SUPPORTED_OPTIONS = new Set<keyof QuoteTableOptions>();\n    if (this.dialect.supports.indexHints) {\n      QUOTE_TABLE_SUPPORTED_OPTIONS.add('indexHints');\n    }\n\n    if (this.dialect.supports.tableHints) {\n      QUOTE_TABLE_SUPPORTED_OPTIONS.add('tableHints');\n    }\n\n    rejectInvalidOptions('quoteTable', this.dialect.name, QUOTE_TABLE_SUPPORTABLE_OPTIONS, QUOTE_TABLE_SUPPORTED_OPTIONS, { ...options });\n\n    if (isModelStatic(param)) {\n      param = param.getTableName();\n    }\n\n    const tableName = this.extractTableDetails(param);\n\n    if (isObject(param) && ('as' in param || 'name' in param)) {\n      throw new Error('parameters \"as\" and \"name\" are not allowed in the first parameter of quoteTable, pass them as the second parameter.');\n    }\n\n    let sql = '';\n\n    if (this.dialect.supports.schemas) {\n      // Some users sync the same set of tables in different schemas for various reasons\n      // They then set `searchPath` when running a query to use different schemas.\n      // See https://github.com/sequelize/sequelize/pull/15274#discussion_r1020770364\n      // For this reason, we treat the default schema as equivalent to \"no schema specified\"\n      if (tableName.schema && tableName.schema !== this.dialect.getDefaultSchema()) {\n        sql += `${this.quoteIdentifier(tableName.schema)}.`;\n      }\n\n      sql += this.quoteIdentifier(tableName.tableName);\n    } else {\n      const fakeSchemaPrefix = (tableName.schema && tableName.schema !== this.dialect.getDefaultSchema())\n        ? tableName.schema + (tableName.delimiter || '.')\n        : '';\n\n      sql += this.quoteIdentifier(fakeSchemaPrefix + tableName.tableName);\n    }\n\n    if (options?.alias) {\n      sql += ` AS ${this.quoteIdentifier(options.alias === true ? tableName.tableName : options.alias)}`;\n    }\n\n    if (options?.indexHints) {\n      for (const hint of options.indexHints) {\n        if (IndexHints[hint.type]) {\n          sql += ` ${IndexHints[hint.type]} INDEX (${hint.values.map(indexName => this.quoteIdentifier(indexName)).join(',')})`;\n        } else {\n          throw new Error(`The index hint type \"${hint.type}\" is invalid or not supported by dialect \"${this.dialect.name}\".`);\n        }\n      }\n    }\n\n    if (options?.tableHints) {\n      const hints: TableHints[] = [];\n      for (const hint of options.tableHints) {\n        if (TableHints[hint]) {\n          hints.push(TableHints[hint]);\n        } else {\n          throw new Error(`The table hint \"${hint}\" is invalid or not supported by dialect \"${this.dialect.name}\".`);\n        }\n      }\n\n      if (hints.length) {\n        sql += ` WITH (${hints.join(', ')})`;\n      }\n    }\n\n    return sql;\n  }\n\n  /**\n   * Adds quotes to identifier\n   *\n   * @param identifier\n   * @param _force\n   */\n  // TODO: memoize last result\n  quoteIdentifier(identifier: string, _force?: boolean) {\n    return quoteIdentifier(identifier, this.dialect.TICK_CHAR_LEFT, this.dialect.TICK_CHAR_RIGHT);\n  }\n\n  isSameTable(tableA: TableNameOrModel, tableB: TableNameOrModel) {\n    if (tableA === tableB) {\n      return true;\n    }\n\n    tableA = this.extractTableDetails(tableA);\n    tableB = this.extractTableDetails(tableB);\n\n    return tableA.tableName === tableB.tableName && tableA.schema === tableB.schema;\n  }\n\n  whereQuery<M extends Model>(where: WhereOptions<Attributes<M>>, options?: FormatWhereOptions) {\n    const query = this.whereItemsQuery(where, options);\n    if (query && query.length > 0) {\n      return `WHERE ${query}`;\n    }\n\n    return '';\n  }\n\n  whereItemsQuery<M extends Model>(where: WhereOptions<Attributes<M>> | undefined, options?: FormatWhereOptions) {\n    return this.whereSqlBuilder.formatWhereOptions(where, options);\n  }\n\n  formatSqlExpression(piece: BaseSqlExpression, options?: EscapeOptions): string {\n    if (piece instanceof Literal) {\n      return this.formatLiteral(piece, options);\n    }\n\n    if (piece instanceof Fn) {\n      return this.formatFn(piece, options);\n    }\n\n    if (piece instanceof List) {\n      return this.escapeList(piece.values, options);\n    }\n\n    if (piece instanceof Value) {\n      return this.escape(piece.value, options);\n    }\n\n    if (piece instanceof Identifier) {\n      return this.quoteIdentifier(piece.value);\n    }\n\n    if (piece instanceof Cast) {\n      return this.formatCast(piece, options);\n    }\n\n    if (piece instanceof Col) {\n      return this.formatCol(piece, options);\n    }\n\n    if (piece instanceof Attribute) {\n      return this.formatAttribute(piece, options);\n    }\n\n    if (piece instanceof Where) {\n      if (piece.where instanceof PojoWhere) {\n        return this.whereSqlBuilder.formatPojoWhere(piece.where, options);\n      }\n\n      return this.whereSqlBuilder.formatWhereOptions(piece.where, options);\n    }\n\n    if (piece instanceof JsonPath) {\n      return this.formatJsonPath(piece, options);\n    }\n\n    if (piece instanceof AssociationPath) {\n      return this.formatAssociationPath(piece);\n    }\n\n    if (piece instanceof DialectAwareFn) {\n      return this.formatDialectAwareFn(piece, options);\n    }\n\n    throw new Error(`Unknown sequelize method ${piece.constructor.name}`);\n  }\n\n  protected formatAssociationPath(associationPath: AssociationPath): string {\n    return `${this.quoteIdentifier(associationPath.associationPath.join('->'))}.${this.quoteIdentifier(associationPath.attributeName)}`;\n  }\n\n  protected formatJsonPath(jsonPathVal: JsonPath, options?: EscapeOptions): string {\n    const value = this.escape(jsonPathVal.expression, options);\n\n    if (jsonPathVal.path.length === 0) {\n      return value;\n    }\n\n    return this.jsonPathExtractionQuery(value, jsonPathVal.path, false);\n  }\n\n  /**\n   * The goal of this method is to execute the equivalent of json_unquote for the current dialect.\n   *\n   * @param _arg\n   * @param _options\n   */\n  formatUnquoteJson(_arg: Expression, _options: EscapeOptions | undefined): string {\n    if (!this.dialect.supports.jsonOperations) {\n      throw new Error(`Unquoting JSON is not supported by ${this.dialect.name} dialect.`);\n    }\n\n    throw new Error(`formatUnquoteJson has not been implemented in ${this.dialect.name}.`);\n  }\n\n  /**\n   * @param _sqlExpression \u26A0\uFE0F This is not an identifier, it's a raw SQL expression. It will be inlined in the query.\n   * @param _path The JSON path, where each item is one level of the path\n   * @param _unquote Whether the result should be unquoted (depending on dialect: ->> and #>> operators, json_unquote function). Defaults to `false`.\n   */\n  jsonPathExtractionQuery(_sqlExpression: string, _path: ReadonlyArray<number | string>, _unquote: boolean): string {\n    if (!this.dialect.supports.jsonOperations) {\n      throw new Error(`JSON Paths are not supported in ${this.dialect.name}.`);\n    }\n\n    throw new Error(`jsonPathExtractionQuery has not been implemented in ${this.dialect.name}.`);\n  }\n\n  protected formatLiteral(piece: Literal, options?: EscapeOptions): string {\n    const sql = piece.val.map(part => {\n      if (part instanceof BaseSqlExpression) {\n        return this.formatSqlExpression(part, options);\n      }\n\n      return part;\n    }).join('');\n\n    if (options?.replacements) {\n      return injectReplacements(sql, this.dialect, options.replacements, {\n        onPositionalReplacement: () => {\n          throw new TypeError(`The following literal includes positional replacements (?).\nOnly named replacements (:name) are allowed in literal() because we cannot guarantee the order in which they will be evaluated:\n\u279C literal(${JSON.stringify(sql)})`);\n        },\n      });\n    }\n\n    return sql;\n  }\n\n  protected formatAttribute(piece: Attribute, options?: EscapeOptions): string {\n    const model = options?.model;\n\n    // This handles special attribute syntaxes like $association.references$, json.paths, and attribute::casting\n    const columnName = model?.modelDefinition.getColumnNameLoose(piece.attributeName)\n      ?? piece.attributeName;\n\n    if (options?.mainAlias) {\n      return `${this.quoteIdentifier(options.mainAlias)}.${this.quoteIdentifier(columnName)}`;\n    }\n\n    return this.quoteIdentifier(columnName);\n  }\n\n  protected formatFn(piece: Fn, options?: EscapeOptions): string {\n    // arguments of a function can be anything, it's not necessarily the type of the attribute,\n    // so we need to remove the type from their escape options\n    const argEscapeOptions = piece.args.length > 0 && options?.type ? { ...options, type: undefined } : options;\n    const args = piece.args.map(arg => {\n      return this.escape(arg, argEscapeOptions);\n    }).join(', ');\n\n    return `${piece.fn}(${args})`;\n  }\n\n  protected formatDialectAwareFn(piece: DialectAwareFn, options?: EscapeOptions): string {\n    // arguments of a function can be anything, it's not necessarily the type of the attribute,\n    // so we need to remove the type from their escape options\n    const argEscapeOptions = piece.args.length > 0 && options?.type ? { ...options, type: undefined } : options;\n\n    return piece.apply(this.dialect, argEscapeOptions);\n  }\n\n  protected formatCast(cast: Cast, options?: EscapeOptions) {\n    const type = this.sequelize.normalizeDataType(cast.type);\n\n    const castSql = wrapAmbiguousWhere(cast.expression, this.escape(cast.expression, { ...options, type }));\n    const targetSql = attributeTypeToSql(type).toUpperCase();\n\n    // TODO: if we're casting to the same SQL DataType, we could skip the SQL cast (but keep the JS cast)\n    //  This is useful because sometimes you want to cast the Sequelize DataType to another Sequelize DataType,\n    //  but they are both the same SQL type, so a SQL cast would be redundant.\n\n    return `CAST(${castSql} AS ${targetSql})`;\n  }\n\n  protected formatCol(piece: Col, options?: EscapeOptions) {\n    // TODO: can this be removed?\n    if (piece.identifiers.length === 1 && piece.identifiers[0].startsWith('*')) {\n      return '*';\n    }\n\n    // Weird legacy behavior\n    const identifiers = piece.identifiers.length === 1 ? piece.identifiers[0] : piece.identifiers;\n\n    // TODO: use quoteIdentifiers?\n    // @ts-expect-error -- quote is declared on child class\n    return this.quote(identifiers, options?.model, undefined, options);\n  }\n\n  /**\n   * Escapes a value (e.g. a string, number or date) as an SQL value (as opposed to an identifier).\n   *\n   * @param value The value to escape\n   * @param options The options to use when escaping the value\n   */\n  escape(value: unknown, options: EscapeOptions = EMPTY_OBJECT): string {\n    if (isDictionary(value) && Op.col in value) {\n      noOpCol();\n      value = new Col(value[Op.col] as string);\n    }\n\n    if (value instanceof BaseSqlExpression) {\n      return this.formatSqlExpression(value, options);\n    }\n\n    if (value === undefined) {\n      throw new TypeError('\"undefined\" cannot be escaped');\n    }\n\n    let { type } = options;\n    if (type != null) {\n      type = this.sequelize.normalizeDataType(type);\n    }\n\n    if (\n      value === null\n      // we handle null values ourselves by default, unless the data type explicitly accepts null\n      && (!(type instanceof AbstractDataType) || !type.acceptsNull())\n    ) {\n      if (options.bindParam) {\n        return options.bindParam(null);\n      }\n\n      return 'NULL';\n    }\n\n    if (type == null || typeof type === 'string') {\n      type = bestGuessDataTypeOfVal(value, this.dialect);\n    } else {\n      type = this.sequelize.normalizeDataType(type);\n    }\n\n    this.validate(value, type);\n\n    if (options.bindParam) {\n      return type.getBindParamSql(value, options as BindParamOptions);\n    }\n\n    return type.escape(value);\n  }\n\n  /**\n   * Validate a value against a field specification\n   *\n   * @param value The value to validate\n   * @param type The DataType to validate against\n   */\n  validate(value: unknown, type: DataType) {\n    if (this.sequelize.options.noTypeValidation || isNullish(value)) {\n      return;\n    }\n\n    if (isString(type)) {\n      return;\n    }\n\n    type = this.sequelize.normalizeDataType(type);\n\n    const error = validateDataType(value, type);\n    if (error) {\n      throw error;\n    }\n  }\n\n  /**\n   * Escapes an array of values (e.g. strings, numbers or dates) as an SQL List of values.\n   *\n   * @param values The list of values to escape\n   * @param options\n   *\n   * @example\n   * ```ts\n   * const values = [1, 2, 3];\n   * queryGenerator.escapeList([1, 2, 3]); // '(1, 2, 3)'\n   */\n  escapeList(values: unknown[], options?: EscapeOptions): string {\n    return `(${values.map(value => this.escape(value, options)).join(', ')})`;\n  }\n\n  getToggleForeignKeyChecksQuery(_enable: boolean): string {\n    throw new Error(`${this.dialect.name} does not support toggling foreign key checks`);\n  }\n\n  versionQuery(): string {\n    throw new Error(`${this.dialect.name} did not implement versionQuery`);\n  }\n\n  tableExistsQuery(tableName: TableNameOrModel): string {\n    const table = this.extractTableDetails(tableName);\n\n    return `SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE' AND TABLE_NAME = ${this.escape(table.tableName)} AND TABLE_SCHEMA = ${this.escape(table.schema)}`;\n  }\n}\n"],
  "mappings": "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",
  "names": ["NodeUtil", "isObject"]
}
