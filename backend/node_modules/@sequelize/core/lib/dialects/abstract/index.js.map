{
  "version": 3,
  "sources": ["../../../src/dialects/abstract/index.ts"],
  "sourcesContent": ["import cloneDeep from 'lodash/cloneDeep';\nimport merge from 'lodash/merge';\nimport type { Class } from 'type-fest';\nimport type { Dialect, Sequelize } from '../../sequelize.js';\nimport { logger } from '../../utils/logger.js';\nimport type { DeepPartial } from '../../utils/types.js';\nimport type { AbstractConnectionManager } from './connection-manager.js';\nimport type { AbstractDataType } from './data-types.js';\nimport * as BaseDataTypes from './data-types.js';\nimport type { AbstractQueryGenerator } from './query-generator.js';\nimport type { AbstractQueryInterface } from './query-interface.js';\nimport type { AbstractQuery } from './query.js';\n\nexport interface SupportableNumericOptions {\n  zerofill: boolean;\n  /** Whether this dialect supports the unsigned option natively */\n  unsigned: boolean;\n}\n\nexport interface SupportableDecimalNumberOptions extends SupportableNumericOptions {\n  /** Whether NaN can be inserted in a column that uses this DataType. */\n  NaN: boolean;\n  /** Whether Infinity/-Infinity can be inserted in a column that uses this DataType. */\n  infinity: boolean;\n}\n\nexport interface SupportableFloatOptions extends SupportableDecimalNumberOptions {\n  /** Whether scale & precision can be specified as parameters */\n  scaleAndPrecision: boolean;\n}\n\nexport interface SupportableExactDecimalOptions extends SupportableDecimalNumberOptions {\n  /**\n   * Whether this dialect supports unconstrained numeric/decimal columns. i.e. columns where numeric values of any length can be stored.\n   * The SQL standard requires that \"NUMERIC\" with no option be equal to \"NUMERIC(0,0)\", but some dialects (postgres)\n   * interpret it as an unconstrained numeric.\n   */\n  unconstrained: boolean;\n\n  /**\n   * Whether this dialect supports constrained numeric/decimal columns. i.e. columns where numeric values of any length can be stored.\n   */\n  constrained: boolean;\n}\n\nexport type DialectSupports = {\n  'DEFAULT': boolean,\n  'DEFAULT VALUES': boolean,\n  'VALUES ()': boolean,\n  // TODO: rename to `update.limit`\n  'LIMIT ON UPDATE': boolean,\n  'ON DUPLICATE KEY': boolean,\n  'ORDER NULLS': boolean,\n  'UNION': boolean,\n  'UNION ALL': boolean,\n  'RIGHT JOIN': boolean,\n  EXCEPTION: boolean,\n\n  forShare?: 'LOCK IN SHARE MODE' | 'FOR SHARE' | undefined,\n  lock: boolean,\n  lockOf: boolean,\n  lockKey: boolean,\n  lockOuterJoinFailure: boolean,\n  skipLocked: boolean,\n  finalTable: boolean,\n\n  /* does the dialect support returning values for inserted/updated fields */\n  returnValues: false | 'output' | 'returning',\n\n  /* features specific to autoIncrement values */\n  autoIncrement: {\n    /* does the dialect require modification of insert queries when inserting auto increment fields */\n    identityInsert: boolean,\n\n    /* does the dialect support inserting default/null values for autoincrement fields */\n    defaultValue: boolean,\n\n    /* does the dialect support updating autoincrement fields */\n    update: boolean,\n  },\n  /* Do we need to say DEFAULT for bulk insert */\n  bulkDefault: boolean,\n  /**\n   * Whether this dialect has native support for schemas.\n   * For the purposes of Sequelize, a Schema is considered to be a grouping of tables.\n   * For instance, in MySQL, \"CREATE DATABASE\" creates what we consider to be a schema.\n   */\n  schemas: boolean,\n  /**\n   * Whether this dialect has native support for having multiple databases per instance (in the postgres or mssql sense).\n   * For the purposes of Sequelize, a database is considered to be a grouping of schemas.\n   * For instance, in MySQL, \"CREATE DATABASE\" creates what we consider to be a schema,\n   * so we do not consider that MySQL supports this option.\n   */\n  multiDatabases: boolean,\n  transactions: boolean,\n  settingIsolationLevelDuringTransaction: boolean,\n  transactionOptions: {\n    type: boolean,\n  },\n  migrations: boolean,\n  upserts: boolean,\n  inserts: {\n    ignoreDuplicates: string, /* dialect specific words for INSERT IGNORE or DO NOTHING */\n    updateOnDuplicate: boolean | string, /* whether dialect supports ON DUPLICATE KEY UPDATE */\n    onConflictDoNothing: string, /* dialect specific words for ON CONFLICT DO NOTHING */\n    onConflictWhere: boolean, /* whether dialect supports ON CONFLICT WHERE */\n    conflictFields: boolean, /* whether the dialect supports specifying conflict fields or not */\n  },\n  constraints: {\n    restrict: boolean,\n    /**\n     * This dialect supports marking a column's constraints as deferrable.\n     * e.g. 'DEFERRABLE' and 'INITIALLY DEFERRED'\n     */\n    deferrable: boolean,\n    unique: boolean,\n    default: boolean,\n    check: boolean,\n    foreignKey: boolean,\n    /** Whether this dialect supports disabling foreign key checks for the current session */\n    foreignKeyChecksDisableable: boolean,\n    primaryKey: boolean,\n    onUpdate: boolean,\n    add: boolean,\n    remove: boolean,\n    removeOptions: {\n      cascade: boolean,\n      ifExists: boolean,\n    },\n  },\n  index: {\n    collate: boolean,\n    length: boolean,\n    parser: boolean,\n    concurrently: boolean,\n    type: boolean,\n    using: boolean | number,\n    functionBased: boolean,\n    operator: boolean,\n    where: boolean,\n    include: boolean,\n  },\n  groupedLimit: boolean,\n  indexViaAlter: boolean,\n  alterColumn: {\n    /**\n     * Can \"ALTER TABLE x ALTER COLUMN y\" add UNIQUE to the column in this dialect?\n     */\n    unique: boolean,\n  },\n  dataTypes: {\n    CHAR: boolean,\n    /**\n     * Whether this dialect provides a binary collation on text, varchar & char columns.\n     */\n    COLLATE_BINARY: boolean,\n    /** This dialect supports case-insensitive text */\n    CITEXT: boolean,\n    /** Options supportable by all int types (from tinyint to bigint) */\n    INTS: SupportableNumericOptions,\n    /** @deprecated */\n    REAL: SupportableFloatOptions,\n    /** This dialect supports 4 byte long floating point numbers */\n    FLOAT: SupportableFloatOptions,\n    /** This dialect supports 8 byte long floating point numbers */\n    DOUBLE: SupportableFloatOptions,\n    /** This dialect supports arbitrary precision numbers */\n    DECIMAL: false | SupportableExactDecimalOptions,\n    /**\n     * The dialect is considered to support JSON if it provides either:\n     * - A JSON data type.\n     * - An SQL function that can be used as a CHECK constraint on a text column, to ensure its contents are valid JSON.\n     */\n    JSON: boolean,\n    JSONB: boolean,\n    ARRAY: boolean,\n    RANGE: boolean,\n    GEOMETRY: boolean,\n    GEOGRAPHY: boolean,\n    HSTORE: boolean,\n    TSVECTOR: boolean,\n    CIDR: boolean,\n    INET: boolean,\n    MACADDR: boolean,\n    DATETIME: {\n      /** Whether \"infinity\" is a valid value in this dialect's DATETIME data type */\n      infinity: boolean,\n    },\n    DATEONLY: {\n      /** Whether \"infinity\" is a valid value in this dialect's DATEONLY data type */\n      infinity: boolean,\n    },\n    TIME: {\n      /** Whether the dialect supports TIME(precision) */\n      precision: boolean,\n    },\n  },\n  REGEXP: boolean,\n  /**\n   * Case-insensitive regexp operator support ('~*' in postgres).\n   */\n  IREGEXP: boolean,\n  /** Whether this dialect supports SQL JSON functions */\n  jsonOperations: boolean,\n  /** Whether this dialect supports returning quoted & unquoted JSON strings  */\n  jsonExtraction: {\n    unquoted: boolean,\n    quoted: boolean,\n  },\n  tmpTableTrigger: boolean,\n  indexHints: boolean,\n  tableHints: boolean,\n  searchPath: boolean,\n  /**\n   * This dialect supports E-prefixed strings, e.g. \"E'foo'\", which\n   * enables the ability to use backslash escapes inside of the string.\n   */\n  escapeStringConstants: boolean,\n\n  /** Whether this dialect supports changing the global timezone option */\n  globalTimeZoneConfig: boolean,\n  dropTable: {\n    cascade: boolean,\n  },\n  maxExecutionTimeHint: {\n    select: boolean,\n  },\n  truncate: {\n    cascade: boolean,\n  },\n  removeColumn: {\n    cascade: boolean,\n    ifExists: boolean,\n  },\n};\n\ntype TypeParser = (...params: any[]) => unknown;\n\nexport abstract class AbstractDialect {\n  /**\n   * List of features this dialect supports.\n   *\n   * Important: Dialect implementations inherit these values.\n   * When changing a default, ensure the implementations still properly declare which feature they support.\n   */\n  static readonly supports: DialectSupports = {\n    DEFAULT: true,\n    'DEFAULT VALUES': false,\n    'VALUES ()': false,\n    'LIMIT ON UPDATE': false,\n    'ON DUPLICATE KEY': true,\n    'ORDER NULLS': false,\n    UNION: true,\n    'UNION ALL': true,\n    'RIGHT JOIN': true,\n    EXCEPTION: false,\n    lock: false,\n    lockOf: false,\n    lockKey: false,\n    lockOuterJoinFailure: false,\n    skipLocked: false,\n    finalTable: false,\n    returnValues: false,\n    autoIncrement: {\n      identityInsert: false,\n      defaultValue: true,\n      update: true,\n    },\n    bulkDefault: false,\n    schemas: false,\n    multiDatabases: false,\n    transactions: true,\n    settingIsolationLevelDuringTransaction: true,\n    transactionOptions: {\n      type: false,\n    },\n    migrations: true,\n    upserts: true,\n    inserts: {\n      ignoreDuplicates: '',\n      updateOnDuplicate: false,\n      onConflictDoNothing: '',\n      onConflictWhere: false,\n      conflictFields: false,\n    },\n    constraints: {\n      restrict: true,\n      deferrable: false,\n      unique: true,\n      default: false,\n      check: true,\n      foreignKey: true,\n      foreignKeyChecksDisableable: false,\n      primaryKey: true,\n      onUpdate: true,\n      add: true,\n      remove: true,\n      removeOptions: {\n        cascade: false,\n        ifExists: false,\n      },\n    },\n    index: {\n      collate: true,\n      length: false,\n      parser: false,\n      concurrently: false,\n      type: false,\n      using: true,\n      functionBased: false,\n      operator: false,\n      where: false,\n      include: false,\n    },\n    groupedLimit: true,\n    indexViaAlter: false,\n    alterColumn: {\n      unique: true,\n    },\n    dataTypes: {\n      CHAR: true,\n      COLLATE_BINARY: false,\n      CITEXT: false,\n      INTS: { zerofill: false, unsigned: false },\n      FLOAT: { NaN: false, infinity: false, zerofill: false, unsigned: false, scaleAndPrecision: false },\n      REAL: { NaN: false, infinity: false, zerofill: false, unsigned: false, scaleAndPrecision: false },\n      DOUBLE: { NaN: false, infinity: false, zerofill: false, unsigned: false, scaleAndPrecision: false },\n      DECIMAL: { constrained: true, unconstrained: false, NaN: false, infinity: false, zerofill: false, unsigned: false },\n      CIDR: false,\n      MACADDR: false,\n      INET: false,\n      JSON: false,\n      JSONB: false,\n      ARRAY: false,\n      RANGE: false,\n      GEOMETRY: false,\n      GEOGRAPHY: false,\n      HSTORE: false,\n      TSVECTOR: false,\n      DATETIME: {\n        infinity: false,\n      },\n      DATEONLY: {\n        infinity: false,\n      },\n      TIME: {\n        precision: true,\n      },\n    },\n    jsonOperations: false,\n    jsonExtraction: {\n      unquoted: false,\n      quoted: false,\n    },\n    REGEXP: false,\n    IREGEXP: false,\n    tmpTableTrigger: false,\n    indexHints: false,\n    tableHints: false,\n    searchPath: false,\n    escapeStringConstants: false,\n    globalTimeZoneConfig: false,\n    dropTable: {\n      cascade: false,\n    },\n    maxExecutionTimeHint: {\n      select: false,\n    },\n    truncate: {\n      cascade: false,\n    },\n    removeColumn: {\n      cascade: false,\n      ifExists: false,\n    },\n  };\n\n  protected static extendSupport(supportsOverwrite: DeepPartial<DialectSupports>): DialectSupports {\n    return merge(cloneDeep(this.supports) ?? {}, supportsOverwrite);\n  }\n\n  readonly sequelize: Sequelize;\n\n  abstract readonly defaultVersion: string;\n  abstract readonly Query: typeof AbstractQuery;\n  abstract readonly TICK_CHAR_LEFT: string;\n  abstract readonly TICK_CHAR_RIGHT: string;\n  abstract readonly queryGenerator: AbstractQueryGenerator;\n  abstract readonly queryInterface: AbstractQueryInterface;\n  abstract readonly connectionManager: AbstractConnectionManager<any>;\n  abstract readonly dataTypesDocumentationUrl: string;\n\n  readonly name: Dialect;\n  readonly DataTypes: Record<string, Class<AbstractDataType<any>>>;\n\n  /** dialect-specific implementation of shared data types */\n  #dataTypeOverrides: Map<string, Class<AbstractDataType<any>>>;\n  /** base implementations of shared data types */\n  #baseDataTypes: Map<string, Class<AbstractDataType<any>>>;\n  #dataTypeParsers = new Map<unknown, TypeParser>();\n\n  get supports(): DialectSupports {\n    const Dialect = this.constructor as typeof AbstractDialect;\n\n    return Dialect.supports;\n  }\n\n  constructor(sequelize: Sequelize, dialectDataTypes: Record<string, Class<AbstractDataType<any>>>, dialectName: Dialect) {\n    this.sequelize = sequelize;\n    this.DataTypes = dialectDataTypes;\n    this.name = dialectName;\n\n    const baseDataTypes = new Map<string, Class<AbstractDataType<any>>>();\n    for (const dataType of Object.values(BaseDataTypes) as Array<Class<AbstractDataType<any>>>) {\n      const dataTypeId: string = (dataType as unknown as typeof AbstractDataType).getDataTypeId();\n\n      // intermediary data type\n      if (!dataTypeId) {\n        continue;\n      }\n\n      if (baseDataTypes.has(dataTypeId)) {\n        throw new Error(`Internal Error: Sequelize declares more than one base implementation for DataType ID ${dataTypeId}.`);\n      }\n\n      baseDataTypes.set(dataTypeId, dataType);\n    }\n\n    const dataTypeOverrides = new Map<string, Class<AbstractDataType<any>>>();\n    for (const dataType of Object.values(this.DataTypes)) {\n      const replacedDataTypeId: string = (dataType as unknown as typeof AbstractDataType).getDataTypeId();\n\n      if (dataTypeOverrides.has(replacedDataTypeId)) {\n        throw new Error(`Dialect ${this.name} declares more than one implementation for DataType ID ${replacedDataTypeId}.`);\n      }\n\n      dataTypeOverrides.set(replacedDataTypeId, dataType);\n    }\n\n    this.#dataTypeOverrides = dataTypeOverrides;\n    this.#baseDataTypes = baseDataTypes;\n  }\n\n  /**\n   * Returns the dialect-specific implementation of a shared data type, or null if no such implementation exists\n   * (in which case you need to use the base implementation).\n   *\n   * @param dataType The shared data type.\n   */\n  getDataTypeForDialect(dataType: Class<AbstractDataType<any>>): Class<AbstractDataType<any>> | null {\n    const typeId = (dataType as unknown as typeof AbstractDataType).getDataTypeId();\n    const baseType = this.#baseDataTypes.get(typeId);\n\n    // this is not one of our types. May be a custom type by a user. We don't replace it.\n    if (baseType != null && baseType !== dataType) {\n      return null;\n    }\n\n    return this.#dataTypeOverrides.get(typeId) ?? null;\n  }\n\n  #printedWarnings = new Set<string>();\n  warnDataTypeIssue(text: string): void {\n    // TODO: log this to sequelize's log option instead (requires a logger with multiple log levels first)\n    if (this.#printedWarnings.has(text)) {\n      return;\n    }\n\n    this.#printedWarnings.add(text);\n    logger.warn(`${text} \\n>> Check: ${this.dataTypesDocumentationUrl}`);\n  }\n\n  abstract createBindCollector(): BindCollector;\n\n  /**\n   * Produces a safe representation of a Buffer for this dialect, that can be inlined in a SQL string.\n   * Used mainly by DataTypes.\n   *\n   * @param buffer The buffer to escape\n   * @returns The string, escaped for SQL.\n   */\n  escapeBuffer(buffer: Buffer): string {\n    const hex = buffer.toString('hex');\n\n    return `X'${hex}'`;\n  }\n\n  /**\n   * Produces a safe representation of a string for this dialect, that can be inlined in a SQL string.\n   * Used mainly by DataTypes.\n   *\n   * @param value The string to escape\n   * @returns The string, escaped for SQL.\n   */\n  escapeString(value: string): string {\n    // http://www.postgresql.org/docs/8.2/static/sql-syntax-lexical.html#SQL-SYNTAX-STRINGS\n    // http://stackoverflow.com/q/603572/130598\n    value = value.replaceAll('\\'', '\\'\\'');\n\n    return `'${value}'`;\n  }\n\n  /**\n   * Whether this dialect can use \\ in strings to escape string delimiters.\n   *\n   * @returns\n   */\n  canBackslashEscape(): boolean {\n    return false;\n  }\n\n  getDefaultPort(): number {\n    // @ts-expect-error -- untyped constructor\n    return this.constructor.getDefaultPort();\n  }\n\n  /**\n   * Used to register a base parser for a Database type.\n   * Parsers are based on the Database Type, not the JS type.\n   * Only one parser can be assigned as the parser for a Database Type.\n   * For this reason, prefer neutral implementations.\n   *\n   * For instance, when implementing \"parse\" for a Date type,\n   * prefer returning a String rather than a Date object.\n   *\n   * The {@link DataTypes.ABSTRACT#parseDatabaseValue} method will then be called on the DataType instance defined by the user,\n   * which can decide on a more specific JS type (e.g. parse the date string & return a Date instance or a Temporal instance).\n   *\n   * You typically do not need to implement this method. This is used to provide default parsers when no DataType\n   * is provided (e.g. raw queries that don't specify a model). Sequelize already provides a default parser for most types.\n   * For a custom Data Type, implementing {@link DataTypes.ABSTRACT#parseDatabaseValue} is typically what you want.\n   *\n   * @param databaseDataTypes Dialect-specific DB data type identifiers that will use this parser.\n   * @param parser The parser function to call when parsing the data type. Parameters are dialect-specific.\n   */\n  registerDataTypeParser(databaseDataTypes: unknown[], parser: TypeParser) {\n    for (const databaseDataType of databaseDataTypes) {\n      if (this.#dataTypeParsers.has(databaseDataType)) {\n        throw new Error(`Sequelize DataType for DB DataType ${databaseDataType} already registered for dialect ${this.name}`);\n      }\n\n      this.#dataTypeParsers.set(databaseDataType, parser);\n    }\n  }\n\n  getParserForDatabaseDataType(databaseDataType: unknown): TypeParser | undefined {\n    return this.#dataTypeParsers.get(databaseDataType);\n  }\n\n  abstract getDefaultSchema(): string;\n\n  static getDefaultPort(): number {\n    throw new Error(`getDefaultPort not implemented in ${this.name}`);\n  }\n}\n\nexport type BindCollector = {\n  /**\n   *\n   *\n   * @param {string} bindParameterName The name of the bind parameter\n   * @returns {string}\n   */\n  collect(bindParameterName: string): string,\n\n  /**\n   * Returns either an array of orders if the bind parameters are mapped to numeric parameters (e.g. '?', $1, @1),\n   * or null if no mapping was necessary because the dialect supports named parameters.\n   */\n  getBindParameterOrder(): string[] | null,\n};\n"],
  "mappings": "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",
  "names": ["merge", "cloneDeep"]
}
