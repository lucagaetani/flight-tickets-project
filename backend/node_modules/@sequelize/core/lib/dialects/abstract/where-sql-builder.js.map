{
  "version": 3,
  "sources": ["../../../src/dialects/abstract/where-sql-builder.ts"],
  "sourcesContent": ["import NodeUtil from 'node:util';\nimport { BaseError } from '../../errors/base-error.js';\nimport { AssociationPath } from '../../expression-builders/association-path.js';\nimport { Attribute } from '../../expression-builders/attribute.js';\nimport { BaseSqlExpression } from '../../expression-builders/base-sql-expression.js';\nimport { Cast } from '../../expression-builders/cast.js';\nimport { Col } from '../../expression-builders/col.js';\nimport { JsonPath } from '../../expression-builders/json-path.js';\nimport { Literal } from '../../expression-builders/literal.js';\nimport { Value } from '../../expression-builders/value.js';\nimport { Where } from '../../expression-builders/where.js';\nimport type { Expression, ModelStatic, WhereOptions } from '../../index.js';\nimport { Op } from '../../operators';\nimport type { ParsedJsonPropertyKey } from '../../utils/attribute-syntax.js';\nimport { parseAttributeSyntax, parseNestedJsonKeySyntax } from '../../utils/attribute-syntax.js';\nimport { isDictionary, isPlainObject, isString } from '../../utils/check.js';\nimport { noOpCol } from '../../utils/deprecations.js';\nimport { EMPTY_ARRAY, EMPTY_OBJECT } from '../../utils/object.js';\nimport type { Nullish } from '../../utils/types.js';\nimport { getComplexKeys, getOperators } from '../../utils/where.js';\nimport { AbstractDataType } from './data-types.js';\nimport * as DataTypes from './data-types.js';\nimport type { NormalizedDataType } from './data-types.js';\nimport type { FormatWhereOptions } from './query-generator-typescript.js';\nimport type { AbstractQueryGenerator } from './query-generator.js';\nimport type { WhereAttributeHashValue } from './where-sql-builder-types.js';\n\nexport class PojoWhere {\n  declare leftOperand: Expression;\n  declare whereValue: WhereAttributeHashValue<any>;\n\n  static create(\n    leftOperand: Expression,\n    whereAttributeHashValue: WhereAttributeHashValue<any>,\n  ): PojoWhere {\n    const pojoWhere = new PojoWhere();\n    pojoWhere.leftOperand = leftOperand;\n    pojoWhere.whereValue = whereAttributeHashValue;\n\n    return pojoWhere;\n  }\n}\n\nclass ObjectPool<T> {\n  #freeItems: T[];\n  #factory: () => T;\n  #lastOccupiedIndex: number;\n  constructor(factory: () => T, initialSize: number) {\n    this.#freeItems = Array.from({ length: initialSize }).map(factory);\n    this.#lastOccupiedIndex = initialSize - 1;\n    this.#factory = factory;\n  }\n\n  getObject(): T {\n    if (this.#lastOccupiedIndex < 0) {\n      return this.#factory();\n    }\n\n    return this.#freeItems[this.#lastOccupiedIndex--];\n  }\n\n  free(val: T): void {\n    if (this.#lastOccupiedIndex >= (this.#freeItems.length - 1)) {\n      this.#freeItems.push(val);\n\n      return;\n    }\n\n    this.#freeItems[++this.#lastOccupiedIndex] = val;\n  }\n}\n\nconst pojoWherePool = new ObjectPool<PojoWhere>(() => new PojoWhere(), 20);\n\nexport class WhereSqlBuilder {\n  #operatorMap: Record<symbol, string> = {\n    [Op.eq]: '=',\n    [Op.ne]: '!=',\n    [Op.gte]: '>=',\n    [Op.gt]: '>',\n    [Op.lte]: '<=',\n    [Op.lt]: '<',\n    [Op.is]: 'IS',\n    [Op.isNot]: 'IS NOT',\n    [Op.in]: 'IN',\n    [Op.notIn]: 'NOT IN',\n    [Op.like]: 'LIKE',\n    [Op.notLike]: 'NOT LIKE',\n    [Op.iLike]: 'ILIKE',\n    [Op.notILike]: 'NOT ILIKE',\n    [Op.regexp]: '~',\n    [Op.notRegexp]: '!~',\n    [Op.iRegexp]: '~*',\n    [Op.notIRegexp]: '!~*',\n    [Op.between]: 'BETWEEN',\n    [Op.notBetween]: 'NOT BETWEEN',\n    [Op.overlap]: '&&',\n    [Op.contains]: '@>',\n    [Op.contained]: '<@',\n    [Op.adjacent]: '-|-',\n    [Op.strictLeft]: '<<',\n    [Op.strictRight]: '>>',\n    [Op.noExtendRight]: '&<',\n    [Op.noExtendLeft]: '&>',\n    [Op.any]: 'ANY',\n    [Op.all]: 'ALL',\n    [Op.match]: '@@',\n    [Op.anyKeyExists]: '?|',\n    [Op.allKeysExist]: '?&',\n  };\n\n  #jsonType: NormalizedDataType | undefined;\n  #arrayOfTextType: NormalizedDataType | undefined;\n\n  constructor(protected readonly queryGenerator: AbstractQueryGenerator) {\n    this.#jsonType = this.dialect.supports.dataTypes.JSON\n      ? new DataTypes.JSON().toDialectDataType(queryGenerator.dialect)\n      : undefined;\n\n    this.#arrayOfTextType = this.dialect.supports.dataTypes.ARRAY\n      ? new DataTypes.ARRAY(new DataTypes.TEXT()).toDialectDataType(queryGenerator.dialect)\n      : undefined;\n  }\n\n  protected get dialect() {\n    return this.queryGenerator.dialect;\n  }\n\n  setOperatorKeyword(op: symbol, keyword: string): void {\n    this.#operatorMap[op] = keyword;\n  }\n\n  /**\n   * Transforms any value accepted by {@link WhereOptions} into a SQL string.\n   *\n   * @param where\n   * @param options\n   */\n  formatWhereOptions(\n    where: WhereOptions,\n    options: FormatWhereOptions = EMPTY_OBJECT,\n  ): string {\n    if (typeof where === 'string') {\n      throw new TypeError('Support for `{ where: \\'raw query\\' }` has been removed. Use `{ where: literal(\\'raw query\\') }` instead');\n    }\n\n    if (where === undefined) {\n      return '';\n    }\n\n    try {\n      return this.#handleRecursiveNotOrAndWithImplicitAndArray(where, (piece: PojoWhere | BaseSqlExpression) => {\n        if (piece instanceof BaseSqlExpression) {\n          return this.queryGenerator.formatSqlExpression(piece, options);\n        }\n\n        return this.formatPojoWhere(piece, options);\n      });\n    } catch (error) {\n      throw new BaseError(`Invalid value received for the \"where\" option. Refer to the sequelize documentation to learn which values the \"where\" option accepts.\\nValue: ${NodeUtil.inspect(where)}`, {\n        cause: error,\n      });\n    }\n  }\n\n  /**\n   * This is the recursive \"and\", \"or\" and \"not\" handler of the first level of {@link WhereOptions} (the level *before* encountering an attribute name).\n   * Unlike handleRecursiveNotOrAndNestedPathRecursive, this method accepts arrays at the top level, which are implicitly converted to \"and\" groups.\n   * and does not handle nested JSON paths.\n   *\n   * @param input\n   * @param handlePart\n   * @param logicalOperator AND / OR\n   */\n  #handleRecursiveNotOrAndWithImplicitAndArray<TAttributes>(\n    input: WhereOptions<TAttributes>,\n    handlePart: (part: BaseSqlExpression | PojoWhere) => string,\n    logicalOperator: typeof Op.and | typeof Op.or = Op.and,\n  ): string {\n    // Arrays in this method are treated as an implicit \"AND\" operator\n    if (Array.isArray(input)) {\n      return joinWithLogicalOperator(\n        input.map(part => {\n          if (part === undefined) {\n            return '';\n          }\n\n          return this.#handleRecursiveNotOrAndWithImplicitAndArray(part, handlePart);\n        }),\n        logicalOperator,\n      );\n    }\n\n    // if the input is not a plan object, then it can't include Operators.\n    if (!isPlainObject(input)) {\n      // @ts-expect-error -- This catches a scenario where the user did not respect the typing\n      if (!(input instanceof BaseSqlExpression)) {\n        throw new TypeError(`Invalid Query: expected a plain object, an array or a sequelize SQL method but got ${NodeUtil.inspect(input)} `);\n      }\n\n      return handlePart(input);\n    }\n\n    const keys = getComplexKeys(input);\n\n    const sqlArray = keys.map(operatorOrAttribute => {\n      if (operatorOrAttribute === Op.not) {\n        const generatedResult = this.#handleRecursiveNotOrAndWithImplicitAndArray(\n          // @ts-expect-error -- This is a recursive type, which TS does not handle well\n          input[Op.not] as WhereOptions<TAttributes>,\n          handlePart,\n        );\n\n        return wrapWithNot(generatedResult);\n      }\n\n      if (operatorOrAttribute === Op.and || operatorOrAttribute === Op.or) {\n        return this.#handleRecursiveNotOrAndWithImplicitAndArray(\n          // @ts-expect-error -- This is a recursive type, which TS does not handle well\n          input[operatorOrAttribute],\n          handlePart,\n          operatorOrAttribute as typeof Op.and | typeof Op.or,\n        );\n      }\n\n      // it *has* to be an attribute now\n      if (typeof operatorOrAttribute === 'symbol') {\n        throw new TypeError(`Invalid Query: ${NodeUtil.inspect(input)} includes the Symbol Operator Op.${operatorOrAttribute.description} but only attributes, Op.and, Op.or, and Op.not are allowed.`);\n      }\n\n      let pojoWhereObject;\n      try {\n        pojoWhereObject = pojoWherePool.getObject();\n\n        pojoWhereObject.leftOperand = parseAttributeSyntax(operatorOrAttribute);\n\n        // @ts-expect-error -- The type of \"operatorOrAttribute\" is too dynamic for TS\n        pojoWhereObject.whereValue = input[operatorOrAttribute];\n\n        return handlePart(pojoWhereObject);\n      } finally {\n        if (pojoWhereObject) {\n          pojoWherePool.free(pojoWhereObject);\n        }\n      }\n    });\n\n    return joinWithLogicalOperator(sqlArray, logicalOperator);\n  }\n\n  /**\n   * This method is responsible for transforming a group \"left operand\" + \"operators, right operands\" (multiple) into a SQL string.\n   *\n   * @param pojoWhere The representation of the group.\n   * @param options Option bag.\n   */\n  formatPojoWhere(\n    pojoWhere: PojoWhere,\n    options: FormatWhereOptions = EMPTY_OBJECT,\n  ): string {\n    // we need to parse the left operand early to determine the data type of the right operand\n    let leftDataType = this.#getOperandType(pojoWhere.leftOperand, options.model);\n    const operandIsJsonColumn = leftDataType == null || leftDataType instanceof DataTypes.JSON;\n\n    return this.#handleRecursiveNotOrAndNestedPathRecursive(\n      pojoWhere.leftOperand,\n      pojoWhere.whereValue,\n      operandIsJsonColumn,\n      (left: Expression, operator: symbol | undefined, right: Expression) => {\n        // \"left\" could have been wrapped in a JSON path. If we still don't know its data type, it's very likely a JSON column\n        // if the user used a JSON path in the where clause.\n        if (leftDataType == null && left instanceof JsonPath) {\n          leftDataType = this.#jsonType;\n        } else if (left !== pojoWhere.leftOperand) { // if \"left\" was wrapped in a JSON path, we need to get its data type again as it might have been cast\n          leftDataType = this.#getOperandType(left, options.model);\n        }\n\n        if (operator === Op.col) {\n          noOpCol();\n\n          right = new Col(right as string);\n          operator = Op.eq;\n        }\n\n        // This happens when the user does something like `where: { id: { [Op.any]: { id: 1 } } }`\n        if (operator === Op.any || operator === Op.all) {\n          right = { [operator]: right };\n          operator = Op.eq;\n        }\n\n        if (operator == null) {\n          if (right === null && leftDataType instanceof DataTypes.JSON) {\n            throw new Error('Because JSON has two possible null values, comparing a JSON/JSONB attribute to NULL requires an explicit comparison operator. Use the `Op.is` operator to compare to SQL NULL, or the `Op.eq` operator to compare to JSON null.');\n          }\n\n          operator = Array.isArray(right) && !(leftDataType instanceof DataTypes.ARRAY) ? Op.in\n            : right === null ? Op.is\n            : Op.eq;\n        }\n\n        // backwards compatibility\n        if (right === null && !(leftDataType instanceof DataTypes.JSON)) {\n          if (operator === Op.eq) {\n            operator = Op.is;\n          }\n\n          if (operator === Op.ne) {\n            operator = Op.isNot;\n          }\n        }\n\n        const rightDataType = this.#getOperandType(right, options.model);\n\n        if (operator in this) {\n          // @ts-expect-error -- TS does not know that this is a method\n          return this[operator](left, leftDataType, operator, right, rightDataType, options);\n        }\n\n        return this.formatBinaryOperation(left, leftDataType, operator, right, rightDataType, options);\n      },\n    );\n  }\n\n  protected [Op.notIn](...args: Parameters<WhereSqlBuilder[typeof Op.in]>): string {\n    return this[Op.in](...args);\n  }\n\n  protected [Op.in](\n    left: Expression,\n    leftDataType: NormalizedDataType | undefined,\n    operator: symbol,\n    right: Expression,\n    rightDataType: NormalizedDataType | undefined,\n    options: FormatWhereOptions,\n  ): string {\n    const rightEscapeOptions = { ...options, type: rightDataType ?? leftDataType };\n    const leftEscapeOptions = { ...options, type: leftDataType ?? rightDataType };\n\n    let rightSql: string;\n    if (right instanceof Literal) {\n      rightSql = this.queryGenerator.escape(right, rightEscapeOptions);\n    } else if (Array.isArray(right)) {\n      if (right.length === 0) {\n        // NOT IN () does not exist in SQL, so we need to return a condition that is:\n        // - always false if the operator is IN\n        // - always true if the operator is NOT IN\n        if (operator === Op.notIn) {\n          return '';\n        }\n\n        rightSql = '(NULL)';\n      } else {\n        rightSql = this.queryGenerator.escapeList(right, rightEscapeOptions);\n      }\n    } else {\n      throw new TypeError('Operators Op.in and Op.notIn must be called with an array of values, or a literal');\n    }\n\n    const leftSql = this.queryGenerator.escape(left, leftEscapeOptions);\n\n    return `${leftSql} ${this.#operatorMap[operator]} ${rightSql}`;\n  }\n\n  protected [Op.isNot](...args: Parameters<WhereSqlBuilder[typeof Op.is]>): string {\n    return this[Op.is](...args);\n  }\n\n  protected [Op.is](\n    left: Expression,\n    leftDataType: NormalizedDataType | undefined,\n    operator: symbol,\n    right: Expression,\n    rightDataType: NormalizedDataType | undefined,\n    options: FormatWhereOptions,\n  ): string {\n    if (right !== null && typeof right !== 'boolean' && !(right instanceof Literal)) {\n      throw new Error('Operators Op.is and Op.isNot can only be used with null, true, false or a literal.');\n    }\n\n    // \"IS\" operator does not accept bind parameters, only literals\n    if (options.bindParam) {\n      options = {\n        ...options,\n        bindParam: undefined,\n      };\n    }\n\n    return this.formatBinaryOperation(\n      left, undefined, operator, right, undefined, options,\n    );\n  }\n\n  protected [Op.notBetween](...args: Parameters<WhereSqlBuilder[typeof Op.between]>): string {\n    return this[Op.between](...args);\n  }\n\n  protected [Op.between](\n    left: Expression,\n    leftDataType: NormalizedDataType | undefined,\n    operator: symbol,\n    right: Expression,\n    rightDataType: NormalizedDataType | undefined,\n    options: FormatWhereOptions,\n  ): string {\n    const rightEscapeOptions = { ...options, type: rightDataType ?? leftDataType };\n    const leftEscapeOptions = { ...options, type: leftDataType ?? rightDataType };\n\n    const leftSql = this.queryGenerator.escape(left, leftEscapeOptions);\n\n    let rightSql: string;\n    if (right instanceof BaseSqlExpression) {\n      rightSql = this.queryGenerator.escape(right, rightEscapeOptions);\n    } else if (Array.isArray(right) && right.length === 2) {\n      rightSql = `${this.queryGenerator.escape(right[0], rightEscapeOptions)} AND ${this.queryGenerator.escape(right[1], rightEscapeOptions)}`;\n    } else {\n      throw new Error('Operators Op.between and Op.notBetween must be used with an array of two values, or a literal.');\n    }\n\n    return `${leftSql} ${this.#operatorMap[operator]} ${rightSql}`;\n  }\n\n  protected [Op.contains](\n    left: Expression,\n    leftDataType: NormalizedDataType | undefined,\n    operator: symbol,\n    right: Expression,\n    rightDataType: NormalizedDataType | undefined,\n    options: FormatWhereOptions,\n  ): string {\n    // In postgres, Op.contains has multiple signatures:\n    // - RANGE<VALUE> Op.contains RANGE<VALUE> (both represented by fixed-size arrays in JS)\n    // - RANGE<VALUE> Op.contains VALUE\n    // - ARRAY<VALUE> Op.contains ARRAY<VALUE>\n    // When the left operand is a range RANGE, we must be able to serialize the right operand as either a RANGE or a VALUE.\n    if (!rightDataType && leftDataType instanceof DataTypes.RANGE && !Array.isArray(right)) {\n      // This serializes the right operand as a VALUE\n      return this.formatBinaryOperation(\n        left,\n        leftDataType,\n        operator,\n        right,\n        leftDataType.options.subtype,\n        options,\n      );\n    }\n\n    // This serializes the right operand as a RANGE (or an array for ARRAY contains ARRAY)\n    return this.formatBinaryOperation(left, leftDataType, operator, right, rightDataType, options);\n  }\n\n  protected [Op.contained](\n    left: Expression,\n    leftDataType: NormalizedDataType | undefined,\n    operator: symbol,\n    right: Expression,\n    rightDataType: NormalizedDataType | undefined,\n    options: FormatWhereOptions,\n  ): string {\n    // This function has the opposite semantics of Op.contains. It has the following signatures:\n    // - RANGE<VALUE> Op.contained RANGE<VALUE> (both represented by fixed-size arrays in JS)\n    // - VALUE Op.contained RANGE<VALUE>\n    // - ARRAY<VALUE> Op.contained ARRAY<VALUE>\n\n    // This serializes VALUE contained RANGE\n    if (\n      leftDataType instanceof AbstractDataType\n      && !(leftDataType instanceof DataTypes.RANGE)\n      && !(leftDataType instanceof DataTypes.ARRAY)\n      && Array.isArray(right)\n    ) {\n      return this.formatBinaryOperation(\n        left,\n        leftDataType,\n        operator,\n        right,\n        new DataTypes.RANGE(leftDataType).toDialectDataType(this.dialect),\n        options,\n      );\n    }\n\n    // This serializes:\n    // RANGE contained RANGE\n    // ARRAY contained ARRAY\n    return this.formatBinaryOperation(left, leftDataType, operator, right, rightDataType, options);\n  }\n\n  protected [Op.startsWith](\n    left: Expression,\n    leftDataType: NormalizedDataType | undefined,\n    operator: symbol,\n    right: Expression,\n    rightDataType: NormalizedDataType | undefined,\n    options: FormatWhereOptions,\n  ): string {\n    return this.formatSubstring(left, leftDataType, Op.like, right, rightDataType, options, false, true);\n  }\n\n  protected [Op.notStartsWith](\n    left: Expression,\n    leftDataType: NormalizedDataType | undefined,\n    operator: symbol,\n    right: Expression,\n    rightDataType: NormalizedDataType | undefined,\n    options: FormatWhereOptions,\n  ): string {\n    return this.formatSubstring(left, leftDataType, Op.notLike, right, rightDataType, options, false, true);\n  }\n\n  protected [Op.endsWith](\n    left: Expression,\n    leftDataType: NormalizedDataType | undefined,\n    operator: symbol,\n    right: Expression,\n    rightDataType: NormalizedDataType | undefined,\n    options: FormatWhereOptions,\n  ): string {\n    return this.formatSubstring(left, leftDataType, Op.like, right, rightDataType, options, true, false);\n  }\n\n  protected [Op.notEndsWith](\n    left: Expression,\n    leftDataType: NormalizedDataType | undefined,\n    operator: symbol,\n    right: Expression,\n    rightDataType: NormalizedDataType | undefined,\n    options: FormatWhereOptions,\n  ): string {\n    return this.formatSubstring(left, leftDataType, Op.notLike, right, rightDataType, options, true, false);\n  }\n\n  protected [Op.substring](\n    left: Expression,\n    leftDataType: NormalizedDataType | undefined,\n    operator: symbol,\n    right: Expression,\n    rightDataType: NormalizedDataType | undefined,\n    options: FormatWhereOptions,\n  ): string {\n    return this.formatSubstring(left, leftDataType, Op.like, right, rightDataType, options, true, true);\n  }\n\n  protected [Op.notSubstring](\n    left: Expression,\n    leftDataType: NormalizedDataType | undefined,\n    operator: symbol,\n    right: Expression,\n    rightDataType: NormalizedDataType | undefined,\n    options: FormatWhereOptions,\n  ): string {\n    return this.formatSubstring(left, leftDataType, Op.notLike, right, rightDataType, options, true, true);\n  }\n\n  protected formatSubstring(\n    left: Expression,\n    leftDataType: NormalizedDataType | undefined,\n    operator: symbol,\n    right: Expression,\n    rightDataType: NormalizedDataType | undefined,\n    options: FormatWhereOptions,\n    start: boolean,\n    end: boolean,\n  ) {\n    if (typeof right === 'string') {\n      const startToken = start ? '%' : '';\n      const endToken = end ? '%' : '';\n\n      return this.formatBinaryOperation(left, leftDataType, operator, startToken + right + endToken, rightDataType, options);\n    }\n\n    const escapedPercent = this.dialect.escapeString('%');\n    const literalBuilder: Array<string | BaseSqlExpression> = [`CONCAT(`];\n    if (start) {\n      literalBuilder.push(escapedPercent, ', ');\n    }\n\n    literalBuilder.push(new Value(right));\n\n    if (end) {\n      literalBuilder.push(', ', escapedPercent);\n    }\n\n    literalBuilder.push(')');\n\n    return this.formatBinaryOperation(left, leftDataType, operator, new Literal(literalBuilder), rightDataType, options);\n  }\n\n  [Op.anyKeyExists](\n    left: Expression,\n    leftDataType: NormalizedDataType | undefined,\n    operator: symbol,\n    right: Expression,\n    rightDataType: NormalizedDataType | undefined,\n    options: FormatWhereOptions,\n  ): string {\n    if (!this.#arrayOfTextType) {\n      throw new Error('This dialect does not support Op.anyKeyExists');\n    }\n\n    return this.formatBinaryOperation(left, leftDataType, operator, right, this.#arrayOfTextType, options);\n  }\n\n  [Op.allKeysExist](\n    left: Expression,\n    leftDataType: NormalizedDataType | undefined,\n    operator: symbol,\n    right: Expression,\n    rightDataType: NormalizedDataType | undefined,\n    options: FormatWhereOptions,\n  ): string {\n    if (!this.#arrayOfTextType) {\n      throw new Error('This dialect does not support Op.allKeysExist');\n    }\n\n    return this.formatBinaryOperation(left, leftDataType, operator, right, this.#arrayOfTextType, options);\n  }\n\n  protected formatBinaryOperation(\n    left: Expression,\n    leftDataType: NormalizedDataType | undefined,\n    operator: symbol,\n    right: Expression,\n    rightDataType: NormalizedDataType | undefined,\n    options: FormatWhereOptions,\n  ) {\n    const operatorSql = this.#operatorMap[operator];\n    if (!operatorSql) {\n      throw new TypeError(`Operator Op.${operator.description} does not exist or is not supported by this dialect.`);\n    }\n\n    const leftSql = this.queryGenerator.escape(left, { ...options, type: leftDataType ?? rightDataType });\n    const rightSql = this.#formatOpAnyAll(right, rightDataType ?? leftDataType)\n      || this.queryGenerator.escape(right, { ...options, type: rightDataType ?? leftDataType });\n\n    return `${wrapAmbiguousWhere(left, leftSql)} ${this.#operatorMap[operator]} ${wrapAmbiguousWhere(right, rightSql)}`;\n  }\n\n  #formatOpAnyAll(value: unknown, type: NormalizedDataType | undefined): string {\n    if (!isDictionary(value)) {\n      return '';\n    }\n\n    if (Op.any in value) {\n      return `ANY (${this.#formatOpValues(value[Op.any], type)})`;\n    }\n\n    if (Op.all in value) {\n      return `ALL (${this.#formatOpValues(value[Op.all], type)})`;\n    }\n\n    return '';\n  }\n\n  #formatOpValues(value: unknown, type: NormalizedDataType | undefined): string {\n    if (isDictionary(value) && Op.values in value) {\n      const options = { type };\n\n      const operand: unknown[] = Array.isArray(value[Op.values])\n        ? value[Op.values] as unknown[]\n        : [value[Op.values]];\n\n      const valueSql = operand.map(v => `(${this.queryGenerator.escape(v, options)})`).join(', ');\n\n      return `VALUES ${valueSql}`;\n    }\n\n    return this.queryGenerator.escape(value, { type: type && new DataTypes.ARRAY(type) });\n  }\n\n  /**\n   * This is the recursive \"and\", \"or\" and \"not\" handler of {@link WhereAttributeHashValue} (the level *after* encountering an attribute name).\n   * Unlike handleRecursiveNotOrAndWithImplicitAndArray, arrays at the top level have an implicit \"IN\" operator, instead of an implicit \"AND\" operator,\n   * and this method handles nested JSON paths.\n   *\n   * @param leftOperand\n   * @param whereValue\n   * @param allowJsonPath\n   * @param handlePart\n   * @param operator\n   * @param parentJsonPath\n   */\n  #handleRecursiveNotOrAndNestedPathRecursive(\n    leftOperand: Expression,\n    whereValue: WhereAttributeHashValue<any>,\n    allowJsonPath: boolean,\n    handlePart: (\n      left: Expression,\n      operator: symbol | undefined,\n      right: Expression,\n    ) => string,\n    operator: typeof Op.and | typeof Op.or = Op.and,\n    parentJsonPath: ReadonlyArray<string | number> = EMPTY_ARRAY,\n  ): string {\n    if (!isPlainObject(whereValue)) {\n      return handlePart(this.#wrapSimpleJsonPath(leftOperand, parentJsonPath), undefined, whereValue);\n    }\n\n    const stringKeys = Object.keys(whereValue);\n    if (!allowJsonPath && stringKeys.length > 0) {\n      return handlePart(this.#wrapSimpleJsonPath(leftOperand, parentJsonPath), undefined, whereValue as Expression);\n    }\n\n    const keys = [...stringKeys, ...getOperators(whereValue)];\n\n    const parts: string[] = keys.map(key => {\n      // @ts-expect-error -- this recursive type is too difficult for TS to handle\n      const value = whereValue[key];\n\n      // nested JSON path\n      if (typeof key === 'string') {\n        // parse path segments & cast syntax\n        const parsedKey = parseNestedJsonKeySyntax(key);\n\n        // optimization for common simple scenario (to skip replacing leftOperand on every iteration)\n        if (parsedKey.castsAndModifiers.length === 0) {\n          return this.#handleRecursiveNotOrAndNestedPathRecursive(\n            leftOperand,\n            value,\n            allowJsonPath,\n            handlePart,\n            operator,\n            [...parentJsonPath, ...parsedKey.pathSegments],\n          );\n        }\n\n        // less optimized scenario: happens when we leave the JSON path (cast to another type or unquote),\n        // we need to replace leftOperand with the casted value or the unquote operation\n        const newOperand = this.#wrapComplexJsonPath(leftOperand, parentJsonPath, parsedKey);\n\n        return this.#handleRecursiveNotOrAndNestedPathRecursive(\n          newOperand,\n          value,\n          // TODO: allow JSON if last cast is JSON?\n          //  needs a mechanism to get JS DataType from SQL DataType first. To get last cast:\n          //  newOperand instanceof Cast && isString(newOperand.type) && newOperand.type.toLowerCase();\n          false,\n          handlePart,\n          operator,\n          // reset json path\n          EMPTY_ARRAY,\n        );\n      }\n\n      if (key === Op.not) {\n        return wrapWithNot(\n          this.#handleRecursiveNotOrAndNestedPathRecursive(\n            leftOperand,\n            value,\n            allowJsonPath,\n            handlePart,\n            Op.and,\n          ),\n        );\n      }\n\n      if (key === Op.and || key === Op.or) {\n        if (Array.isArray(value)) {\n          const sqlParts = value\n            .map(v => this.#handleRecursiveNotOrAndNestedPathRecursive(\n              leftOperand,\n              v,\n              allowJsonPath,\n              handlePart,\n              Op.and,\n            ));\n\n          return joinWithLogicalOperator(sqlParts, key as typeof Op.and | typeof Op.or);\n        }\n\n        return this.#handleRecursiveNotOrAndNestedPathRecursive(\n          leftOperand,\n          value,\n          allowJsonPath,\n          handlePart,\n          key as typeof Op.and | typeof Op.or,\n        );\n      }\n\n      return handlePart(this.#wrapSimpleJsonPath(leftOperand, parentJsonPath), key, value);\n    });\n\n    return joinWithLogicalOperator(parts, operator);\n  }\n\n  #wrapSimpleJsonPath(operand: Expression, pathSegments: ReadonlyArray<string | number>): Expression {\n    if (pathSegments.length === 0) {\n      return operand;\n    }\n\n    // merge JSON paths\n    if (operand instanceof JsonPath) {\n      return new JsonPath(operand.expression, [...operand.path, ...pathSegments]);\n    }\n\n    return new JsonPath(operand, pathSegments);\n  }\n\n  #wrapComplexJsonPath(\n    operand: Expression,\n    parentJsonPath: ReadonlyArray<string | number>,\n    parsedPath: ParsedJsonPropertyKey,\n  ): Expression {\n    const finalPathSegments = parentJsonPath.length > 0\n      ? [...parentJsonPath, ...parsedPath.pathSegments]\n      : parsedPath.pathSegments;\n\n    operand = this.#wrapSimpleJsonPath(operand, finalPathSegments);\n\n    for (const castOrModifier of parsedPath.castsAndModifiers) {\n      if (isString(castOrModifier)) {\n        // casts are always strings\n        operand = new Cast(operand, castOrModifier);\n      } else {\n        // modifiers are always classes\n        operand = new castOrModifier(operand);\n      }\n    }\n\n    return operand;\n  }\n\n  #getOperandType(operand: Expression, model: Nullish<ModelStatic>): NormalizedDataType | undefined {\n    if (operand instanceof Cast) {\n      // TODO: if operand.type is a string (= SQL Type), look up a per-dialect mapping of SQL types to Sequelize types?\n      return this.dialect.sequelize.normalizeDataType(operand.type);\n    }\n\n    if (operand instanceof JsonPath) {\n      // JsonPath can wrap Attributes\n      return this.#jsonType;\n    }\n\n    if (!model) {\n      return undefined;\n    }\n\n    if (operand instanceof AssociationPath) {\n      const association = model.modelDefinition.getAssociation(operand.associationPath);\n\n      if (!association) {\n        return undefined;\n      }\n\n      return this.#getOperandType(operand.attributeName, association.target);\n    }\n\n    if (operand instanceof Attribute) {\n      return model.modelDefinition.attributes.get(operand.attributeName)?.type;\n    }\n\n    return undefined;\n  }\n}\n\nexport function joinWithLogicalOperator(sqlArray: string[], operator: typeof Op.and | typeof Op.or): string {\n  const operatorSql = operator === Op.and ? ' AND ' : ' OR ';\n\n  sqlArray = sqlArray.filter(val => Boolean(val));\n\n  if (sqlArray.length === 0) {\n    return '';\n  }\n\n  if (sqlArray.length === 1) {\n    return sqlArray[0];\n  }\n\n  return sqlArray.map(sql => {\n    if (/ AND | OR /i.test(sql)) {\n      return `(${sql})`;\n    }\n\n    return sql;\n  }).join(operatorSql);\n}\n\nfunction wrapWithNot(sql: string): string {\n  if (!sql) {\n    return '';\n  }\n\n  if (sql.startsWith('(') && sql.endsWith(')')) {\n    return `NOT ${sql}`;\n  }\n\n  return `NOT (${sql})`;\n}\n\nexport function wrapAmbiguousWhere(operand: Expression, sql: string): string {\n  // where() can produce ambiguous SQL when used as an operand:\n  //\n  // { booleanAttr: where(fn('lower', col('name')), Op.is, null) }\n  // produces the ambiguous SQL:\n  //   [booleanAttr] = lower([name]) IS NULL\n  // which is better written as:\n  //   [booleanAttr] = (lower([name]) IS NULL)\n  if (operand instanceof Where && sql.includes(' ')) {\n    return `(${sql})`;\n  }\n\n  return sql;\n}\n"],
  "mappings": "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",
  "names": ["import_where", "NodeUtil"]
}
