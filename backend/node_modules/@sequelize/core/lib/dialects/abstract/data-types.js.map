{
  "version": 3,
  "sources": ["../../../src/dialects/abstract/data-types.ts"],
  "sourcesContent": ["import { Blob } from 'node:buffer';\nimport util from 'node:util';\nimport dayjs from 'dayjs';\nimport identity from 'lodash/identity.js';\nimport isEqual from 'lodash/isEqual';\nimport isObject from 'lodash/isObject';\nimport type { Class } from 'type-fest';\nimport { ValidationErrorItem } from '../../errors';\nimport type { Falsy } from '../../generic/falsy';\nimport type { GeoJson, GeoJsonType } from '../../geo-json.js';\nimport { assertIsGeoJson } from '../../geo-json.js';\nimport type { ModelStatic, Rangable, RangePart } from '../../model.js';\nimport type { Sequelize } from '../../sequelize.js';\nimport { makeBufferFromTypedArray } from '../../utils/buffer.js';\nimport { isPlainObject, isString } from '../../utils/check.js';\nimport { isValidTimeZone } from '../../utils/dayjs.js';\nimport { doNotUseRealDataType } from '../../utils/deprecations.js';\nimport { joinSQLFragments } from '../../utils/join-sql-fragments';\nimport { EMPTY_ARRAY } from '../../utils/object.js';\nimport { parseBigInt, parseNumber } from '../../utils/parse-number.js';\nimport { validator as Validator } from '../../utils/validator-extras';\nimport type { HstoreRecord } from '../postgres/hstore.js';\nimport { buildRangeParser } from '../postgres/range.js';\nimport {\n  attributeTypeToSql,\n  dataTypeClassOrInstanceToInstance,\n  isDataType,\n  isDataTypeClass,\n  throwUnsupportedDataType,\n} from './data-types-utils.js';\nimport type { TableNameWithSchema } from './query-interface.js';\nimport type { AbstractDialect } from './index.js';\n\n// TODO: try merging \"validate\" & \"sanitize\" by making sanitize coerces the type, and if it cannot, throw a ValidationError.\n//       right now, they share a lot of the same logic.\n\n// legacy support\nlet Moment: any;\ntry {\n  Moment = require('moment');\n} catch { /* ignore */ }\n\nfunction isMoment(value: any): boolean {\n  return Moment?.isMoment(value) ?? false;\n}\n\n// If T is a constructor, returns the type of what `new T()` would return,\n// otherwise, returns T\nexport type Constructed<T> = T extends abstract new () => infer Instance\n  ? Instance\n  : T;\n\nexport type AcceptableTypeOf<T extends DataType> =\n  Constructed<T> extends AbstractDataType<infer Acceptable> ? Acceptable : never;\n\nexport type DataTypeInstance = AbstractDataType<any>;\nexport type DataTypeClass = Class<AbstractDataType<any>>;\n\nexport type DataTypeClassOrInstance =\n  | DataTypeInstance\n  | DataTypeClass;\n\nexport type DataType =\n  | string\n  | DataTypeClassOrInstance;\n\nexport type NormalizedDataType = string | DataTypeInstance;\n\nexport interface BindParamOptions {\n  bindParam(value: unknown): string;\n}\n\nexport type DataTypeUseContext =\n  | { model: ModelStatic, attributeName: string, sequelize: Sequelize }\n  | { tableName: TableNameWithSchema, columnName: string, sequelize: Sequelize };\n\n/**\n * A symbol that can be used as the key for a static property on a DataType class to uniquely identify it.\n */\nconst kDataTypeIdentifier = Symbol('sequelize.DataTypeIdentifier');\n\n/**\n * @category DataTypes\n */\nexport abstract class AbstractDataType<\n  /** The type of value we'll accept - ie for a column of this type, we'll accept this value as user input. */\n  AcceptedType,\n> {\n  /**\n   * This property is designed to uniquely identify the DataType.\n   * Do not change this value in implementation-specific dialects, or they will not be mapped to their parent DataType properly!\n   *\n   * @hidden\n   */\n  declare static readonly [kDataTypeIdentifier]: string;\n\n  static getDataTypeId(): string {\n    return this[kDataTypeIdentifier];\n  }\n\n  getDataTypeId(): string {\n    // @ts-expect-error -- untyped constructor\n    return this.constructor.getDataTypeId();\n  }\n\n  /**\n   * Where this DataType is being used.\n   */\n  usageContext: DataTypeUseContext | undefined;\n  #dialect: AbstractDialect | undefined;\n\n  protected _getDialect(): AbstractDialect {\n    if (!this.#dialect) {\n      throw new Error('toDialectDataType has not yet been called on this DataType');\n    }\n\n    return this.#dialect;\n  }\n\n  // TODO: Remove in v8\n  /**\n   * @hidden\n   */\n  static get escape() {\n    throw new Error('The \"escape\" static property has been removed. Each DataType is responsible for escaping its value correctly.');\n  }\n\n  // TODO: Remove in v8\n  /**\n   * @hidden\n   */\n  static get types() {\n    throw new Error('The \"types\" static property has been removed. Use getDataTypeDialectMeta.');\n  }\n\n  // TODO: Remove in v8\n  /**\n   * @hidden\n   */\n  static get key() {\n    throw new Error('The \"key\" static property has been removed.');\n  }\n\n  // TODO: Remove in v8\n  /**\n   * @hidden\n   */\n  get types() {\n    throw new Error('The \"types\" instance property has been removed.');\n  }\n\n  // TODO: Remove in v8\n  /**\n   * @hidden\n   */\n  get key() {\n    throw new Error('The \"key\" instance property has been removed.');\n  }\n\n  // TODO: move to utils?\n  protected _construct<Constructor extends abstract new () => AbstractDataType<any>>(\n    ...args: ConstructorParameters<Constructor>): this {\n    const constructor = this.constructor as new (\n      ..._args: ConstructorParameters<Constructor>\n    ) => this;\n\n    return new constructor(...args);\n  }\n\n  areValuesEqual(\n    value: AcceptedType,\n    originalValue: AcceptedType,\n  ): boolean {\n    return isEqual(value, originalValue);\n  }\n\n  /**\n   * Whether this DataType wishes to handle NULL values itself.\n   * This is almost exclusively used by {@link JSON} and {@link JSONB} which serialize `null` as the JSON string `'null'`.\n   */\n  acceptsNull(): boolean {\n    return false;\n  }\n\n  /**\n   * Called when a value is retrieved from the Database, and its DataType is specified.\n   * Used to normalize values from the database.\n   *\n   * Note: It is also possible to do an initial parsing of a Database value using {@link AbstractDialect#registerDataTypeParser}.\n   * That normalization uses the type ID from the database instead of a Sequelize Data Type to determine which parser to use,\n   * and is called before this method.\n   *\n   * @param value The value to parse.\n   */\n  parseDatabaseValue(value: unknown): unknown {\n    return value as AcceptedType;\n  }\n\n  /**\n   * Used to normalize a value when {@link Model#set} is called.\n   * That is, when a user sets a value on a Model instance.\n   *\n   * @param value\n   */\n  sanitize(value: unknown): unknown {\n    return value;\n  }\n\n  /**\n   * Checks whether the JS value is compatible with (or can be converted to) the SQL data type.\n   * Throws if that is not the case.\n   *\n   * @param value\n   */\n  validate(value: any): asserts value is AcceptedType {}\n\n  /**\n   * Escapes a value for the purposes of inlining it in a SQL query.\n   * The resulting value will be inlined as-is with no further escaping.\n   *\n   * @param value The value to escape.\n   */\n  escape(value: AcceptedType): string {\n    const asBindValue = this.toBindableValue(value);\n\n    if (!isString(asBindValue)) {\n      throw new Error(`${this.constructor.name}#stringify has been overridden to return a non-string value, so ${this.constructor.name}#escape must be implemented to handle that value correctly.`);\n    }\n\n    return this._getDialect().escapeString(asBindValue);\n  }\n\n  /**\n   * This method is called when {@link AbstractQueryGenerator} needs to add a bind parameter to a query it is building.\n   * This method allows for customizing both the SQL to add to the query, and convert the bind parameter value to a DB-compatible value.\n   *\n   * If you only need to prepare the bind param value, implement {@link toBindableValue} instead.\n   *\n   * This method must return the SQL to add to the query. You can obtain a bind parameter ID by calling {@link BindParamOptions#bindParam}\n   * with the value associated to that bind parameter.\n   *\n   * An example of a data type that requires customizing the SQL is the {@link GEOMETRY} data type.\n   *\n   * @param value The value to bind.\n   * @param options Options.\n   */\n  getBindParamSql(value: AcceptedType, options: BindParamOptions): string {\n    // TODO: rename \"options.bindParam\" to \"options.collectBindParam\"\n    return options.bindParam(this.toBindableValue(value));\n  }\n\n  /**\n   * Converts a JS value to a value compatible with the connector library for this Data Type.\n   * Unlike {@link escape}, this value does not need to be escaped. It is passed separately to the database, which\n   * will handle escaping.\n   *\n   * @param value The value to convert.\n   */\n  toBindableValue(value: AcceptedType): unknown {\n    return String(value);\n  }\n\n  toString(): string {\n    try {\n      return this.toSql();\n    } catch {\n      // best effort introspection (dialect may not be available)\n      return this.constructor.toString();\n    }\n  }\n\n  static toString() {\n    return this.name;\n  }\n\n  /**\n   * Returns a SQL declaration of this data type.\n   * e.g. 'VARCHAR(255)', 'TEXT', etc\u2026\n   */\n  abstract toSql(): string;\n\n  /**\n   * Override this method to emit an error or a warning if the Data Type, as it is configured, is not compatible\n   * with the current dialect.\n   *\n   * @param dialect The dialect using this data type.\n   */\n  protected _checkOptionSupport(dialect: AbstractDialect) {\n    // use \"dialect.supports\" to determine base support for this DataType.\n    assertDataTypeSupported(dialect, this);\n  }\n\n  belongsToDialect(dialect: AbstractDialect): boolean {\n    return this.#dialect === dialect;\n  }\n\n  /**\n   * Returns this DataType, using its dialect-specific subclass.\n   *\n   * @param dialect\n   */\n  toDialectDataType(dialect: AbstractDialect): this {\n    // This DataType has already been converted to a dialect-specific DataType.\n    if (this.#dialect === dialect) {\n      return this;\n    }\n\n    const DataTypeClass = this.constructor as Class<AbstractDataType<any>>;\n    // get dialect-specific implementation\n    const subClass = dialect.getDataTypeForDialect(DataTypeClass);\n\n    const replacement: this = (!subClass || subClass === DataTypeClass)\n      // optimisation: re-use instance if it doesn't belong to any dialect yet.\n      ? this.#dialect == null ? this : this.clone()\n      // there is a convention that all DataTypes must accept a single \"options\" parameter as one of their signatures, but it's impossible to enforce in typing\n      // @ts-expect-error -- see ^\n      : new subClass(this.options) as this;\n\n    replacement.#dialect = dialect;\n    replacement._checkOptionSupport(dialect);\n    if (this.usageContext) {\n      replacement.attachUsageContext(this.usageContext);\n    }\n\n    return replacement;\n  }\n\n  /**\n   * Returns a copy of this DataType, without usage context.\n   * Designed to re-use a DataType on another Model.\n   */\n  clone(): this {\n    // there is a convention that all DataTypes must accept a single \"options\" parameter as one of their signatures, but it's impossible to enforce in typing\n    // @ts-expect-error -- see ^\n    return this._construct(this.options);\n  }\n\n  withUsageContext(usageContext: DataTypeUseContext): this {\n    const out = this.clone().attachUsageContext(usageContext);\n\n    if (this.#dialect) {\n      out.#dialect = this.#dialect;\n    }\n\n    return out;\n  }\n\n  /**\n   * @param usageContext\n   * @private\n   */\n  attachUsageContext(usageContext: DataTypeUseContext): this {\n    if (this.usageContext && !isEqual(this.usageContext, usageContext)) {\n      throw new Error(`This DataType is already attached to ${printContext(this.usageContext)}, and therefore cannot be attached to ${printContext(usageContext)}.`);\n    }\n\n    this.usageContext = Object.freeze(usageContext);\n\n    return this;\n  }\n}\n\nfunction printContext(usageContext: DataTypeUseContext): string {\n  if ('model' in usageContext) {\n    return `attribute ${usageContext.model.name}#${usageContext.attributeName}`;\n  }\n\n  return `column \"${usageContext.tableName}\".\"${usageContext.columnName}\"`;\n}\n\nexport interface StringTypeOptions {\n  /**\n   * @default 255\n   */\n  length?: number | undefined;\n\n  /**\n   * @default false\n   */\n  binary?: boolean;\n}\n\n/**\n * Represents a variable length string type.\n *\n * __Fallback policy:__\n * - If the 'length' option is not supported by the dialect, a CHECK constraint will be added to ensure\n * the value remains within the specified length.\n * - If the 'binary' option is not supported by the dialect, a suitable binary type will be used instead.\n *   If none is available, an error will be raised instead.\n *\n * @example\n * ```ts\n * DataTypes.STRING(255)\n * ```\n *\n * @category DataTypes\n */\nexport class STRING extends AbstractDataType<string | Buffer> {\n  /** @hidden */\n  static readonly [kDataTypeIdentifier]: string = 'STRING';\n  readonly options: StringTypeOptions;\n\n  constructor(length: number, binary?: boolean);\n  constructor(options?: StringTypeOptions);\n  // we have to define the constructor overloads using tuples due to a TypeScript limitation\n  //  https://github.com/microsoft/TypeScript/issues/29732, to play nice with classToInvokable.\n  /** @hidden */\n  constructor(...args:\n    | []\n    | [length: number]\n    | [length: number, binary: boolean]\n    | [options: StringTypeOptions]\n  );\n\n  constructor(lengthOrOptions?: number | StringTypeOptions, binary?: boolean) {\n    super();\n\n    if (isObject(lengthOrOptions)) {\n      this.options = {\n        length: lengthOrOptions.length,\n        binary: lengthOrOptions.binary ?? false,\n      };\n    } else {\n      this.options = {\n        length: lengthOrOptions,\n        binary: binary ?? false,\n      };\n    }\n  }\n\n  protected _checkOptionSupport(dialect: AbstractDialect) {\n    if (!dialect.supports.dataTypes.COLLATE_BINARY && this.options.binary) {\n      throwUnsupportedDataType(dialect, 'STRING.BINARY');\n    }\n  }\n\n  toSql(): string {\n    // TODO: STRING should use an unlimited length type by default - https://github.com/sequelize/sequelize/issues/14259\n    return joinSQLFragments([\n      `VARCHAR(${this.options.length ?? 255})`,\n      this.options.binary && 'BINARY',\n    ]);\n  }\n\n  validate(value: any): asserts value is string | Buffer {\n    if (typeof value === 'string') {\n      return;\n    }\n\n    if (!this.options.binary) {\n      ValidationErrorItem.throwDataTypeValidationError(\n        `${util.inspect(value)} is not a valid string. Only the string type is accepted for non-binary strings.`,\n      );\n    }\n\n    rejectBlobs(value);\n\n    if (Buffer.isBuffer(value)) {\n      return;\n    }\n\n    if (value instanceof Uint8Array || value instanceof ArrayBuffer) {\n      return;\n    }\n\n    ValidationErrorItem.throwDataTypeValidationError(\n      `${util.inspect(value)} is not a valid binary value: Only strings, Buffer, Uint8Array and ArrayBuffer are supported.`,\n    );\n  }\n\n  get BINARY() {\n    return this._construct<typeof STRING>({\n      ...this.options,\n      binary: true,\n    });\n  }\n\n  static get BINARY() {\n    return new this({ binary: true });\n  }\n\n  escape(value: string | Buffer): string {\n    if (Buffer.isBuffer(value)) {\n      return this._getDialect().escapeBuffer(value);\n    }\n\n    return this._getDialect().escapeString(value);\n  }\n\n  toBindableValue(value: string | Buffer): unknown {\n    return this.sanitize(value);\n  }\n}\n\n/**\n * Represents a fixed length string type.\n *\n * __Fallback policy:__\n * - If this DataType is not supported, an error will be raised.\n *\n * @example\n * ```ts\n * DataTypes.CHAR(1000)\n * ```\n *\n * @category DataTypes\n */\nexport class CHAR extends STRING {\n  /** @hidden */\n  static readonly [kDataTypeIdentifier]: string = 'CHAR';\n\n  protected _checkOptionSupport(dialect: AbstractDialect) {\n    if (!dialect.supports.dataTypes.CHAR) {\n      throwUnsupportedDataType(dialect, 'CHAR');\n    }\n\n    if (!dialect.supports.dataTypes.COLLATE_BINARY && this.options.binary) {\n      throwUnsupportedDataType(dialect, 'CHAR.BINARY');\n    }\n  }\n\n  toSql() {\n    return joinSQLFragments([\n      `CHAR(${this.options.length ?? 255})`,\n      this.options.binary && 'BINARY',\n    ]);\n  }\n}\n\nconst validTextLengths = ['tiny', 'medium', 'long'];\nexport type TextLength = 'tiny' | 'medium' | 'long';\n\nexport interface TextOptions {\n  length?: TextLength | undefined;\n}\n\n/**\n * Represents an unlimited length string type.\n *\n * @example\n * ```ts\n * DataTypes.TEXT('tiny') // TINYTEXT\n * ```\n *\n * @category DataTypes\n */\nexport class TEXT extends AbstractDataType<string> {\n  /** @hidden */\n  static readonly [kDataTypeIdentifier]: string = 'TEXT';\n  readonly options: TextOptions;\n\n  /**\n   * @param lengthOrOptions could be tiny, medium, long.\n   */\n  constructor(lengthOrOptions?: TextLength | TextOptions) {\n    super();\n\n    const length = (typeof lengthOrOptions === 'object' ? lengthOrOptions.length : lengthOrOptions)?.toLowerCase();\n\n    if (length != null && !validTextLengths.includes(length)) {\n      throw new TypeError(`If specified, the \"length\" option must be one of: ${validTextLengths.join(', ')}`);\n    }\n\n    this.options = {\n      length: length as TextLength,\n    };\n  }\n\n  toSql(): string {\n    switch (this.options.length) {\n      case 'tiny':\n        return 'TINYTEXT';\n      case 'medium':\n        return 'MEDIUMTEXT';\n      case 'long':\n        return 'LONGTEXT';\n      default:\n        return 'TEXT';\n    }\n  }\n\n  validate(value: any): asserts value is string {\n    if (typeof value !== 'string') {\n      ValidationErrorItem.throwDataTypeValidationError(\n        util.format('%s is not a valid string', value),\n      );\n    }\n  }\n}\n\n/**\n * An unlimited length case-insensitive text column.\n * Original case is preserved but acts case-insensitive when comparing values (such as when finding or unique constraints).\n * Only available in Postgres and SQLite.\n *\n * __Fallback policy:__\n * - If this DataType is not supported, and no case-insensitive text alternative exists, an error will be raised.\n *\n * @example\n * ```ts\n * DataTypes.CITEXT\n * ```\n *\n * @category DataTypes\n */\nexport class CITEXT extends AbstractDataType<string> {\n  /** @hidden */\n  static readonly [kDataTypeIdentifier]: string = 'CITEXT';\n\n  toSql(): string {\n    return 'CITEXT';\n  }\n\n  protected _checkOptionSupport(dialect: AbstractDialect) {\n    if (!dialect.supports.dataTypes.CITEXT) {\n      throwUnsupportedDataType(dialect, 'case-insensitive text (CITEXT)');\n    }\n  }\n\n  validate(value: any): asserts value is string {\n    if (typeof value !== 'string') {\n      ValidationErrorItem.throwDataTypeValidationError(\n        util.format('%s is not a valid string', value),\n      );\n    }\n  }\n}\n\nexport interface NumberOptions {\n  /**\n   * Pad the value with zeros to the specified length.\n   *\n   * Currently useless for types that are returned as JS BigInts or JS Numbers.\n   */\n  // TODO: When a number is 0-filled, return it as a string instead of number or bigint\n  zerofill?: boolean | undefined;\n\n  /**\n   * Is unsigned?\n   */\n  unsigned?: boolean | undefined;\n}\n\nexport interface IntegerOptions extends NumberOptions {\n  /**\n   * In MariaDB: When specified, and {@link zerofill} is set, the returned value will be padded with zeros to the specified length.\n   * In MySQL: This option is ignored.\n   * This option is supported in no other dialect.\n   * Currently useless for types that are returned as JS BigInts or JS Numbers.\n   */\n  length?: number;\n}\n\nexport interface DecimalNumberOptions extends NumberOptions {\n  /**\n   * Total number of digits.\n   *\n   * {@link DecimalNumberOptions#scale} must be specified if precision is specified.\n   */\n  precision?: number | undefined;\n\n  /**\n   * Count of decimal digits in the fractional part.\n   *\n   * {@link DecimalNumberOptions#precision} must be specified if scale is specified.\n   */\n  scale?: number | undefined;\n}\n\ntype AcceptedNumber =\n  | number\n  | bigint\n  | boolean\n  | string\n  | null;\n\n/**\n * Base number type which is used to build other types\n */\nexport class BaseNumberDataType<Options extends NumberOptions = NumberOptions> extends AbstractDataType<AcceptedNumber> {\n  readonly options: Options;\n\n  constructor(options?: Options) {\n    super();\n\n    // @ts-expect-error -- \"options\" is always optional, but we can't tell TypeScript that all properties of the object must be optional\n    this.options = { ...options };\n  }\n\n  protected getNumberSqlTypeName(): string {\n    throw new Error(`getNumberSqlTypeName has not been implemented in ${this.constructor.name}`);\n  }\n\n  toSql(): string {\n    let result: string = this.getNumberSqlTypeName();\n\n    if (this.options.unsigned && this._supportsNativeUnsigned(this._getDialect())) {\n      result += ' UNSIGNED';\n    }\n\n    if (this.options.zerofill) {\n      result += ' ZEROFILL';\n    }\n\n    return result;\n  }\n\n  protected _supportsNativeUnsigned(_dialect: AbstractDialect) {\n    return false;\n  }\n\n  validate(value: any): asserts value is number {\n    if (typeof value === 'number' && Number.isInteger(value) && !Number.isSafeInteger(value)) {\n      ValidationErrorItem.throwDataTypeValidationError(\n        util.format(`${this.constructor.name} received an integer % that is not a safely represented using the JavaScript number type. Use a JavaScript bigint or a string instead.`, value),\n      );\n    }\n\n    if (!Validator.isFloat(String(value))) {\n      ValidationErrorItem.throwDataTypeValidationError(\n        `${util.inspect(value)} is not a valid ${this.toString().toLowerCase()}`,\n      );\n    }\n  }\n\n  escape(value: AcceptedNumber): string {\n    return String(this.toBindableValue(value));\n  }\n\n  toBindableValue(num: AcceptedNumber): string | number {\n    // This should be unnecessary but since this directly returns the passed string its worth the added validation.\n    this.validate(num);\n\n    if (Number.isNaN(num)) {\n      return 'NaN';\n    }\n\n    if (num === Number.NEGATIVE_INFINITY || num === Number.POSITIVE_INFINITY) {\n      const sign = num < 0 ? '-' : '';\n\n      return `${sign}Infinity`;\n    }\n\n    return num;\n  }\n\n  getBindParamSql(value: AcceptedNumber, options: BindParamOptions): string {\n    return options.bindParam(value);\n  }\n\n  get UNSIGNED(): this {\n    return this._construct<typeof BaseNumberDataType>({ ...this.options, unsigned: true });\n  }\n\n  get ZEROFILL(): this {\n    return this._construct<typeof BaseNumberDataType>({ ...this.options, zerofill: true });\n  }\n\n  static get UNSIGNED() {\n    return new this({ unsigned: true });\n  }\n\n  static get ZEROFILL() {\n    return new this({ zerofill: true });\n  }\n}\n\nexport class BaseIntegerDataType extends BaseNumberDataType<IntegerOptions> {\n  constructor(optionsOrLength?: number | Readonly<IntegerOptions>) {\n    if (typeof optionsOrLength === 'number') {\n      super({ length: optionsOrLength });\n    } else {\n      super(optionsOrLength ?? {});\n    }\n  }\n\n  validate(value: unknown) {\n    super.validate(value);\n\n    if (typeof value === 'number' && !Number.isInteger(value)) {\n      ValidationErrorItem.throwDataTypeValidationError(`${util.inspect(value)} is not a valid ${this.toString().toLowerCase()}`);\n    }\n\n    if (!Validator.isInt(String(value))) {\n      ValidationErrorItem.throwDataTypeValidationError(`${util.inspect(value)} is not a valid ${this.toString().toLowerCase()}`);\n    }\n  }\n\n  sanitize(value: unknown): unknown {\n    if (typeof value === 'string' || typeof value === 'bigint') {\n      const out = parseNumber(value);\n\n      // let validate sort this validation instead\n      if (Number.isNaN(out)) {\n        return value;\n      }\n\n      return out;\n    }\n\n    return value;\n  }\n\n  parseDatabaseValue(value: unknown): unknown {\n    return this.sanitize(value);\n  }\n\n  protected _checkOptionSupport(dialect: AbstractDialect) {\n    super._checkOptionSupport(dialect);\n\n    if (this.options.zerofill && !dialect.supports.dataTypes.INTS.zerofill) {\n      throwUnsupportedDataType(dialect, `${this.getDataTypeId()}.ZEROFILL`);\n    }\n  }\n\n  protected _supportsNativeUnsigned(_dialect: AbstractDialect): boolean {\n    return _dialect.supports.dataTypes.INTS.unsigned;\n  }\n\n  toSql(): string {\n    let result: string = this.getNumberSqlTypeName();\n    if (this.options.length != null) {\n      result += `(${this.options.length})`;\n    }\n\n    if (this.options.unsigned && this._supportsNativeUnsigned(this._getDialect())) {\n      result += ' UNSIGNED';\n    }\n\n    if (this.options.zerofill) {\n      result += ' ZEROFILL';\n    }\n\n    return result;\n  }\n}\n\n/**\n * An 8-bit integer.\n *\n * __Fallback policy:__\n * - If this type or its unsigned option is unsupported by the dialect, it will be replaced by a SMALLINT or greater,\n *   with a CHECK constraint to ensure the value is withing the bounds of an 8-bit integer.\n * - If the zerofill option is unsupported by the dialect, an error will be raised.\n * - If the length option is unsupported by the dialect, it will be discarded.\n *\n * @example\n * ```ts\n * DataTypes.TINYINT\n * ```\n *\n * @category DataTypes\n */\nexport class TINYINT extends BaseIntegerDataType {\n  /** @hidden */\n  static readonly [kDataTypeIdentifier]: string = 'TINYINT';\n\n  protected getNumberSqlTypeName(): string {\n    return 'TINYINT';\n  }\n}\n\n/**\n * A 16-bit integer.\n *\n * __Fallback policy:__\n * - If this type or its unsigned option is unsupported by the dialect, it will be replaced by a MEDIUMINT or greater,\n *   with a CHECK constraint to ensure the value is withing the bounds of an 16-bit integer.\n * - If the zerofill option is unsupported by the dialect, an error will be raised.\n * - If the length option is unsupported by the dialect, it will be discarded.\n *\n * @example\n * ```ts\n * DataTypes.SMALLINT\n * ```\n *\n * @category DataTypes\n */\nexport class SMALLINT extends BaseIntegerDataType {\n  /** @hidden */\n  static readonly [kDataTypeIdentifier]: string = 'SMALLINT';\n\n  protected getNumberSqlTypeName(): string {\n    return 'SMALLINT';\n  }\n}\n\n/**\n * A 24-bit integer.\n *\n * __Fallback policy:__\n * - If this type or its unsigned option is unsupported by the dialect, it will be replaced by a INTEGER (32 bits) or greater,\n *   with a CHECK constraint to ensure the value is withing the bounds of an 32-bit integer.\n * - If the zerofill option is unsupported by the dialect, an error will be raised.\n * - If the length option is unsupported by the dialect, it will be discarded.\n *\n * @example\n * ```ts\n * DataTypes.MEDIUMINT\n * ```\n *\n * @category DataTypes\n */\nexport class MEDIUMINT extends BaseIntegerDataType {\n  /** @hidden */\n  static readonly [kDataTypeIdentifier]: string = 'MEDIUMINT';\n\n  protected getNumberSqlTypeName(): string {\n    return 'MEDIUMINT';\n  }\n}\n\n/**\n * A 32-bit integer.\n *\n * __Fallback policy:__\n * - When this type or its unsigned option is unsupported by the dialect, it will be replaced by a BIGINT,\n *   with a CHECK constraint to ensure the value is withing the bounds of an 32-bit integer.\n * - If the zerofill option is unsupported by the dialect, an error will be raised.\n * - If the length option is unsupported by the dialect, it will be discarded.\n *\n * @example\n * ```ts\n * DataTypes.INTEGER\n * ```\n *\n * @category DataTypes\n */\nexport class INTEGER extends BaseIntegerDataType {\n  /** @hidden */\n  static readonly [kDataTypeIdentifier]: string = 'INTEGER';\n\n  protected getNumberSqlTypeName(): string {\n    return 'INTEGER';\n  }\n}\n\n/**\n * A 64-bit integer.\n *\n * __Fallback policy:__\n * - If this type or its unsigned option is unsupported by the dialect, an error will be raised.\n * - If the zerofill option is unsupported by the dialect, an error will be raised.\n * - If the length option is unsupported by the dialect, it will be discarded.\n *\n * @example\n * ```ts\n * DataTypes.BIGINT\n * ```\n *\n * @category DataTypes\n */\nexport class BIGINT extends BaseIntegerDataType {\n  /** @hidden */\n  static readonly [kDataTypeIdentifier]: string = 'BIGINT';\n\n  protected getNumberSqlTypeName(): string {\n    return 'BIGINT';\n  }\n\n  protected _checkOptionSupport(dialect: AbstractDialect) {\n    super._checkOptionSupport(dialect);\n\n    if (this.options.unsigned && !this._supportsNativeUnsigned(dialect)) {\n      throwUnsupportedDataType(dialect, `${this.getDataTypeId()}.UNSIGNED`);\n    }\n  }\n\n  sanitize(value: AcceptedNumber): AcceptedNumber {\n    if (typeof value === 'bigint') {\n      return value;\n    }\n\n    if (typeof value !== 'string' && typeof value !== 'number') {\n      // let validate() handle this instead\n      return value;\n    }\n\n    // TODO: Breaking Change: Return a BigInt by default - https://github.com/sequelize/sequelize/issues/14296\n    return String(parseBigInt(value));\n  }\n}\n\nexport class BaseDecimalNumberDataType extends BaseNumberDataType<DecimalNumberOptions> {\n  constructor(options?: DecimalNumberOptions);\n  /**\n   * @param precision defines precision\n   * @param scale defines scale\n   */\n  constructor(precision: number, scale: number);\n\n  // we have to define the constructor overloads using tuples due to a TypeScript limitation\n  //  https://github.com/microsoft/TypeScript/issues/29732, to play nice with classToInvokable.\n  /** @hidden */\n  constructor(...args:\n    | []\n    | [precision: number]\n    | [precision: number, scale: number]\n    | [options: DecimalNumberOptions]\n  );\n\n  constructor(precisionOrOptions?: number | DecimalNumberOptions, scale?: number) {\n    if (isObject(precisionOrOptions)) {\n      super(precisionOrOptions);\n    } else {\n      super({});\n\n      this.options.precision = precisionOrOptions;\n      this.options.scale = scale;\n    }\n\n    if (this.options.scale != null && this.options.precision == null) {\n      throw new Error(`The ${this.getDataTypeId()} DataType requires that the \"precision\" option be specified if the \"scale\" option is specified.`);\n    }\n\n    if (this.options.scale == null && this.options.precision != null) {\n      throw new Error(`The ${this.getDataTypeId()} DataType requires that the \"scale\" option be specified if the \"precision\" option is specified.`);\n    }\n  }\n\n  validate(value: any): asserts value is AcceptedNumber {\n    if (Number.isNaN(value)) {\n      const typeId = this.getDataTypeId();\n      const dialect = this._getDialect();\n\n      // @ts-expect-error -- 'typeId' is string, but only some dataTypes are objects\n      if (dialect.supports.dataTypes[typeId]?.NaN) {\n        return;\n      }\n\n      ValidationErrorItem.throwDataTypeValidationError(`${util.inspect(value)} is not a valid ${this.toString().toLowerCase()}`);\n    }\n\n    if (value === Number.POSITIVE_INFINITY || value === Number.NEGATIVE_INFINITY) {\n      const typeId = this.getDataTypeId();\n      const dialect = this._getDialect();\n\n      // @ts-expect-error -- 'typeId' is string, but only some dataTypes are objects\n      if (dialect.supports.dataTypes[typeId]?.infinity) {\n        return;\n      }\n\n      ValidationErrorItem.throwDataTypeValidationError(`${util.inspect(value)} is not a valid ${this.toString().toLowerCase()}`);\n    }\n\n    super.validate(value);\n  }\n\n  isUnconstrained() {\n    return this.options.scale == null && this.options.precision == null;\n  }\n\n  protected _checkOptionSupport(dialect: AbstractDialect) {\n    super._checkOptionSupport(dialect);\n\n    const typeId = this.getDataTypeId();\n    if (typeId !== 'FLOAT' && typeId !== 'DOUBLE' && typeId !== 'DECIMAL' && typeId !== 'REAL') {\n      return;\n    }\n\n    const supportTable = dialect.supports.dataTypes[typeId];\n    if (!supportTable) {\n      throwUnsupportedDataType(dialect, this.getDataTypeId());\n    }\n\n    if (!supportTable.zerofill && this.options.zerofill) {\n      throwUnsupportedDataType(dialect, `${this.getDataTypeId()}.ZEROFILL`);\n    }\n\n    if (typeId === 'DECIMAL') {\n      return;\n    }\n\n    const supportTable2 = dialect.supports.dataTypes[typeId];\n    if (!supportTable2.scaleAndPrecision && (this.options.scale != null || this.options.precision != null)) {\n      dialect.warnDataTypeIssue(`${dialect.name} does not support ${this.getDataTypeId()} with scale or precision specified. These options are ignored.`);\n\n      delete this.options.scale;\n      delete this.options.precision;\n    }\n  }\n\n  toSql(): string {\n    let sql = this.getNumberSqlTypeName();\n    if (!this.isUnconstrained()) {\n      sql += `(${this.options.precision}, ${this.options.scale})`;\n    }\n\n    if (this.options.unsigned && this._supportsNativeUnsigned(this._getDialect())) {\n      sql += ' UNSIGNED';\n    }\n\n    if (this.options.zerofill) {\n      sql += ' ZEROFILL';\n    }\n\n    return sql;\n  }\n}\n\n/**\n * A single-floating point number with a 4-byte precision.\n * If single-precision floating-point format is not supported, a double-precision floating-point number may be used instead.\n *\n * __Fallback policy:__\n * - If the precision or scale options are unsupported by the dialect, they will be discarded.\n * - If the zerofill option is unsupported by the dialect, an error will be raised.\n * - If the unsigned option is unsupported, it will be replaced by a CHECK > 0 constraint.\n *\n * @example\n * ```ts\n * DataTypes.FLOAT\n * ```\n *\n * @category DataTypes\n */\nexport class FLOAT extends BaseDecimalNumberDataType {\n  /** @hidden */\n  static readonly [kDataTypeIdentifier]: string = 'FLOAT';\n\n  protected getNumberSqlTypeName(): string {\n    throw new Error(`getNumberSqlTypeName is not implemented by default in the FLOAT DataType because 'float' has very different meanings in different dialects.\nIn Sequelize, DataTypes.FLOAT must be a single-precision floating point, and DataTypes.DOUBLE must be a double-precision floating point.\nPlease override this method in your dialect, and provide the best available type for single-precision floating points.\nIf single-precision floating points are not available in your dialect, you may return a double-precision floating point type instead, as long as you print a warning.\nIf neither single precision nor double precision IEEE 754 floating point numbers are available in your dialect, you must throw an error in the _checkOptionSupport method.`);\n  }\n\n  protected _supportsNativeUnsigned(_dialect: AbstractDialect): boolean {\n    return _dialect.supports.dataTypes.FLOAT.unsigned;\n  }\n}\n\n/**\n * @deprecated Use {@link FLOAT} instead.\n */\n// TODO (v8): remove this\nexport class REAL extends BaseDecimalNumberDataType {\n  /** @hidden */\n  static readonly [kDataTypeIdentifier]: string = 'REAL';\n\n  protected _checkOptionSupport(dialect: AbstractDialect) {\n    super._checkOptionSupport(dialect);\n\n    doNotUseRealDataType();\n  }\n\n  protected _supportsNativeUnsigned(_dialect: AbstractDialect): boolean {\n    return _dialect.supports.dataTypes.REAL.unsigned;\n  }\n\n  protected getNumberSqlTypeName(): string {\n    return 'REAL';\n  }\n}\n\n/**\n * Floating point number (8-byte precision).\n * Throws an error when unsupported, instead of silently falling back to a lower precision.\n *\n * __Fallback policy:__\n * - If the precision or scale options are unsupported by the dialect, they will be discarded.\n * - If the zerofill option is unsupported by the dialect, an error will be raised.\n * - If the unsigned option is unsupported, it will be replaced by a CHECK > 0 constraint.\n *\n * @example\n * ```ts\n * DataTypes.DOUBLE\n * ```\n *\n * @category DataTypes\n */\nexport class DOUBLE extends BaseDecimalNumberDataType {\n  /** @hidden */\n  static readonly [kDataTypeIdentifier]: string = 'DOUBLE';\n\n  protected _supportsNativeUnsigned(_dialect: AbstractDialect): boolean {\n    return _dialect.supports.dataTypes.DOUBLE.unsigned;\n  }\n\n  protected getNumberSqlTypeName(): string {\n    return 'DOUBLE PRECISION';\n  }\n}\n\n/**\n * Arbitrary/exact precision decimal number.\n *\n * __Fallback policy:__\n * - If the precision or scale options are unsupported by the dialect, they will be ignored.\n * - If the precision or scale options are not specified, and the dialect does not support unconstrained decimals, an error will be raised.\n * - If the zerofill option is unsupported by the dialect, an error will be raised.\n * - If the unsigned option is unsupported, it will be replaced by a CHECK > 0 constraint.\n *\n * @example\n * ```ts\n * DataTypes.DECIMAL\n * ```\n *\n * @category DataTypes\n */\nexport class DECIMAL extends BaseDecimalNumberDataType {\n  /** @hidden */\n  static readonly [kDataTypeIdentifier]: string = 'DECIMAL';\n\n  protected _checkOptionSupport(dialect: AbstractDialect) {\n    super._checkOptionSupport(dialect);\n\n    const decimalSupport = dialect.supports.dataTypes.DECIMAL;\n\n    if (!decimalSupport) {\n      throwUnsupportedDataType(dialect, 'DECIMAL');\n    }\n\n    if (this.isUnconstrained() && !decimalSupport.unconstrained) {\n      throw new Error(`${dialect.name} does not support unconstrained DECIMAL types. Please specify the \"precision\" and \"scale\" options.`);\n    }\n\n    if (!this.isUnconstrained() && !decimalSupport.constrained) {\n      dialect.warnDataTypeIssue(`${dialect.name} does not support constrained DECIMAL types. The \"precision\" and \"scale\" options will be ignored.`);\n      this.options.scale = undefined;\n      this.options.precision = undefined;\n    }\n  }\n\n  sanitize(value: AcceptedNumber): AcceptedNumber {\n    if (typeof value === 'number') {\n      // Some dialects support NaN\n      if (Number.isNaN(value)) {\n        return value;\n      }\n\n      // catch loss of precision issues\n      if (Number.isInteger(value) && !Number.isSafeInteger(value)) {\n        throw new Error(`${this.getDataTypeId()} received an integer ${util.inspect(value)} that is not a safely represented using the JavaScript number type. Use a JavaScript bigint or a string instead.`);\n      }\n    }\n\n    // Decimal is arbitrary precision, and *must* be represented as strings, as the JS number type does not support arbitrary precision.\n    return String(value);\n  }\n\n  protected _supportsNativeUnsigned(_dialect: AbstractDialect): boolean {\n    const decimalSupport = _dialect.supports.dataTypes.DECIMAL;\n\n    return decimalSupport && decimalSupport.unsigned;\n  }\n\n  protected getNumberSqlTypeName(): string {\n    return 'DECIMAL';\n  }\n}\n\n/**\n * A boolean / tinyint column, depending on dialect\n *\n * __Fallback policy:__\n * - If a native boolean type is not available, a dialect-specific numeric replacement (bit, tinyint) will be used instead.\n *\n * @example\n * ```ts\n * DataTypes.BOOLEAN\n * ```\n *\n * @category DataTypes\n */\nexport class BOOLEAN extends AbstractDataType<boolean> {\n  /** @hidden */\n  static readonly [kDataTypeIdentifier]: string = 'BOOLEAN';\n\n  toSql() {\n    // Note: This may vary depending on the dialect.\n    return 'BOOLEAN';\n  }\n\n  validate(value: any): asserts value is boolean {\n    if (typeof value !== 'boolean') {\n      ValidationErrorItem.throwDataTypeValidationError(\n        util.format('%O is not a valid boolean', value),\n      );\n    }\n  }\n\n  parseDatabaseValue(value: unknown): boolean {\n    if (typeof value === 'boolean') {\n      return value;\n    }\n\n    // Some dialects do not have a dedicated boolean type. We receive integers instead.\n    if (value === 1) {\n      return true;\n    }\n\n    if (value === 0) {\n      return false;\n    }\n\n    // Some dialects also use BIT for booleans, which produces a Buffer.\n    if (Buffer.isBuffer(value) && value.length === 1) {\n      if (value[0] === 1) {\n        return true;\n      }\n\n      if (value[0] === 0) {\n        return false;\n      }\n    }\n\n    throw new Error(`Received invalid boolean value from DB: ${util.inspect(value)}`);\n  }\n\n  escape(value: boolean | Falsy): string {\n    return value ? 'true' : 'false';\n  }\n\n  toBindableValue(value: boolean | Falsy): unknown {\n    return Boolean(value);\n  }\n}\n\nexport interface TimeOptions {\n  /**\n   * The precision of the date.\n   */\n  precision?: number | undefined;\n}\n\n/**\n * A time column.\n *\n * __Fallback policy:__\n * If the dialect does not support this type natively, it will be replaced by a string type,\n * and a CHECK constraint to enforce a valid ISO 8601 time format.\n *\n * @example\n * ```ts\n * DataTypes.TIME(3)\n * ```\n *\n * @category DataTypes\n */\nexport class TIME extends AbstractDataType<string> {\n  /** @hidden */\n  static readonly [kDataTypeIdentifier]: string = 'TIME';\n  readonly options: TimeOptions;\n\n  /**\n   * @param precisionOrOptions precision to allow storing milliseconds\n   */\n  constructor(precisionOrOptions?: number | TimeOptions) {\n    super();\n\n    this.options = {\n      precision: typeof precisionOrOptions === 'object' ? precisionOrOptions.precision : precisionOrOptions,\n    };\n  }\n\n  protected _checkOptionSupport(dialect: AbstractDialect) {\n    super._checkOptionSupport(dialect);\n\n    if (this.options.precision != null && !dialect.supports.dataTypes.TIME.precision) {\n      throwUnsupportedDataType(dialect, 'TIME(precision)');\n    }\n  }\n\n  toSql() {\n    if (this.options.precision != null) {\n      return `TIME(${this.options.precision})`;\n    }\n\n    return 'TIME';\n  }\n}\n\nexport interface DateOptions {\n  /**\n   * The precision of the date.\n   */\n  precision?: number | undefined;\n}\n\ntype RawDate = Date | string | number;\nexport type AcceptedDate = RawDate | dayjs.Dayjs | number;\n\n/**\n * A date and time.\n *\n * __Fallback policy:__\n * If the dialect does not support this type natively, it will be replaced by a string type,\n * and a CHECK constraint to enforce a valid ISO 8601 date-only format.\n *\n * @example\n * ```ts\n * DataTypes.DATE(3)\n * ```\n *\n * @category DataTypes\n */\nexport class DATE extends AbstractDataType<AcceptedDate> {\n  /** @hidden */\n  static readonly [kDataTypeIdentifier]: string = 'DATE';\n  readonly options: DateOptions;\n\n  /**\n   * @param precisionOrOptions precision to allow storing milliseconds\n   */\n  constructor(precisionOrOptions?: number | DateOptions) {\n    super();\n\n    this.options = {\n      precision: typeof precisionOrOptions === 'object' ? precisionOrOptions.precision : precisionOrOptions,\n    };\n\n    if (this.options.precision != null && (this.options.precision < 0 || !Number.isInteger(this.options.precision))) {\n      throw new TypeError('Option \"precision\" must be a positive integer');\n    }\n  }\n\n  toSql() {\n    // TODO [>=8]: Consider making precision default to 3 instead of being dialect-dependent.\n    if (this.options.precision != null) {\n      return `DATETIME(${this.options.precision})`;\n    }\n\n    return 'DATETIME';\n  }\n\n  validate(value: any) {\n    if (!Validator.isDate(String(value))) {\n      ValidationErrorItem.throwDataTypeValidationError(\n        util.format('%O is not a valid date', value),\n      );\n    }\n  }\n\n  sanitize(value: unknown): unknown {\n    if (value instanceof Date || dayjs.isDayjs(value) || isMoment(value)) {\n      return value;\n    }\n\n    if (typeof value === 'string' || typeof value === 'number') {\n      return new Date(value);\n    }\n\n    throw new TypeError(`${util.inspect(value)} cannot be converted to a Date object, and is not a DayJS nor Moment object`);\n  }\n\n  parseDatabaseValue(value: unknown): unknown {\n    return this.sanitize(value);\n  }\n\n  areValuesEqual(\n    value: AcceptedDate,\n    originalValue: AcceptedDate,\n  ): boolean {\n    if (\n      originalValue\n      && Boolean(value)\n      && (value === originalValue\n        || (value instanceof Date\n          && originalValue instanceof Date\n          && value.getTime() === originalValue.getTime()))\n    ) {\n      return true;\n    }\n\n    // not changed when set to same empty value\n    if (!originalValue && !value && originalValue === value) {\n      return true;\n    }\n\n    return false;\n  }\n\n  protected _applyTimezone(date: AcceptedDate) {\n    const timezone = this._getDialect().sequelize.options.timezone;\n\n    if (timezone) {\n      if (isValidTimeZone(timezone)) {\n        return dayjs(date).tz(timezone);\n      }\n\n      return dayjs(date).utcOffset(timezone);\n    }\n\n    return dayjs(date);\n  }\n\n  toBindableValue(date: AcceptedDate) {\n    // Z here means current timezone, _not_ UTC\n    return this._applyTimezone(date).format('YYYY-MM-DD HH:mm:ss.SSS Z');\n  }\n}\n\n/**\n * A date only column (no timestamp)\n *\n * __Fallback policy:__\n * If the dialect does not support this type natively, it will be replaced by a string type,\n * and a CHECK constraint to enforce a valid ISO 8601 datetime format.\n *\n * @example\n * ```ts\n * DataTypes.DATEONLY\n * ```\n *\n * @category DataTypes\n */\nexport class DATEONLY extends AbstractDataType<AcceptedDate> {\n  /** @hidden */\n  static readonly [kDataTypeIdentifier]: string = 'DATEONLY';\n\n  toSql() {\n    return 'DATE';\n  }\n\n  toBindableValue(date: AcceptedDate) {\n    return dayjs.utc(date).format('YYYY-MM-DD');\n  }\n\n  sanitize(value: unknown): unknown {\n    if (typeof value !== 'string' && typeof value !== 'number' && !(value instanceof Date)) {\n      throw new TypeError(`${value} cannot be normalized into a DateOnly string.`);\n    }\n\n    if (value) {\n      return dayjs.utc(value).format('YYYY-MM-DD');\n    }\n\n    return value;\n  }\n\n  areValuesEqual(value: AcceptedDate, originalValue: AcceptedDate): boolean {\n    if (originalValue && Boolean(value) && originalValue === value) {\n      return true;\n    }\n\n    // not changed when set to same empty value\n    if (!originalValue && !value && originalValue === value) {\n      return true;\n    }\n\n    return false;\n  }\n}\n\n/**\n * A key / value store column. Only available in Postgres.\n *\n * __Fallback policy:__\n * If the dialect does not support this type natively, an error will be raised.\n *\n * @example\n * ```ts\n * DataTypes.HSTORE\n * ```\n *\n * @category DataTypes\n */\nexport class HSTORE extends AbstractDataType<HstoreRecord> {\n  /** @hidden */\n  static readonly [kDataTypeIdentifier]: string = 'HSTORE';\n\n  protected _checkOptionSupport(dialect: AbstractDialect) {\n    super._checkOptionSupport(dialect);\n    if (!dialect.supports.dataTypes.HSTORE) {\n      throwUnsupportedDataType(dialect, 'HSTORE');\n    }\n  }\n\n  validate(value: any) {\n    if (!isPlainObject(value)) {\n      ValidationErrorItem.throwDataTypeValidationError(util.format('%O is not a valid hstore, it must be a plain object', value));\n    }\n\n    const hstore = value as Record<PropertyKey, unknown>;\n\n    for (const key of Object.keys(hstore)) {\n      if (!isString(hstore[key])) {\n        ValidationErrorItem.throwDataTypeValidationError(util.format(`%O is not a valid hstore, its values must be strings but ${key} is %O`, hstore, hstore[key]));\n      }\n    }\n  }\n\n  toSql(): string {\n    return 'HSTORE';\n  }\n}\n\n/**\n * A JSON string column.\n *\n * __Fallback policy:__\n * If the dialect does not support this type natively, but supports verifying a string as is valid JSON through CHECK constraints,\n * that will be used instead.\n * If neither are available, an error will be raised.\n *\n * @example\n * ```ts\n * DataTypes.JSON\n * ```\n *\n * @category DataTypes\n */\nexport class JSON extends AbstractDataType<any> {\n  /** @hidden */\n  static readonly [kDataTypeIdentifier]: string = 'JSON';\n\n  protected _checkOptionSupport(dialect: AbstractDialect) {\n    super._checkOptionSupport(dialect);\n    if (!dialect.supports.dataTypes.JSON) {\n      throwUnsupportedDataType(dialect, 'JSON');\n    }\n  }\n\n  /**\n   * We stringify null too.\n   */\n  acceptsNull(): boolean {\n    return true;\n  }\n\n  toBindableValue(value: any): string {\n    return globalThis.JSON.stringify(value);\n  }\n\n  toSql(): string {\n    return 'JSON';\n  }\n}\n\n/**\n * A binary storage JSON column. Only available in Postgres.\n *\n * __Fallback policy:__\n * If the dialect does not support this type natively, an error will be raised.\n *\n * @example\n * ```ts\n * DataTypes.JSONB\n * ```\n *\n * @category DataTypes\n */\nexport class JSONB extends JSON {\n  /** @hidden */\n  static readonly [kDataTypeIdentifier]: string = 'JSONB';\n\n  protected _checkOptionSupport(dialect: AbstractDialect) {\n    super._checkOptionSupport(dialect);\n    if (!dialect.supports.dataTypes.JSONB) {\n      throwUnsupportedDataType(dialect, 'JSONB');\n    }\n  }\n\n  toSql(): string {\n    return 'JSONB';\n  }\n}\n\n/**\n * A default value of the current timestamp. Not a valid type.\n *\n * @example\n * ```ts\n * const User = sequelize.define('User', {\n *   registeredAt: {\n *     type: DataTypes.DATE,\n *     defaultValue: DataTypes.NOW,\n *   },\n * });\n * ```\n *\n * @category DataTypes\n */\n// TODO: this should not be a DataType. Replace with a new version of `fn` that is dialect-aware, so we don't need to hardcode it in toDefaultValue().\nexport class NOW extends AbstractDataType<never> {\n  /** @hidden */\n  static readonly [kDataTypeIdentifier]: string = 'NOW';\n\n  toSql(): string {\n    return 'NOW';\n  }\n}\n\nexport type AcceptedBlob = Buffer | string;\n\nexport type BlobLength = 'tiny' | 'medium' | 'long';\n\nexport interface BlobOptions {\n  // TODO: must also allow BLOB(255), BLOB(16M) in db2/ibmi\n  length?: BlobLength | undefined;\n}\n\n/**\n * Binary storage. BLOB is the \"TEXT\" of binary data: it allows data of arbitrary size.\n *\n * __Fallback policy:__\n * If this type is not supported, an error will be raised.\n *\n * @example\n * ```ts\n * const User = sequelize.define('User', {\n *   profilePicture: {\n *     type: DataTypes.BLOB,\n *   },\n * });\n * ```\n *\n * @category DataTypes\n */\n// TODO: add FIXED_BINARY & VAR_BINARY data types. They are not the same as CHAR BINARY / VARCHAR BINARY.\nexport class BLOB extends AbstractDataType<AcceptedBlob> {\n  /** @hidden */\n  static readonly [kDataTypeIdentifier]: string = 'BLOB';\n  readonly options: BlobOptions;\n\n  /**\n   * @param lengthOrOptions could be tiny, medium, long.\n   */\n  constructor(lengthOrOptions?: BlobLength | BlobOptions) {\n    super();\n\n    // TODO: valide input (tiny, medium, long, number, 16M, 2G, etc)\n\n    this.options = {\n      length: typeof lengthOrOptions === 'object' ? lengthOrOptions.length : lengthOrOptions,\n    };\n  }\n\n  toSql(): string {\n    switch (this.options.length) {\n      case 'tiny':\n        return 'TINYBLOB';\n      case 'medium':\n        return 'MEDIUMBLOB';\n      case 'long':\n        return 'LONGBLOB';\n      default:\n        return 'BLOB';\n    }\n  }\n\n  validate(value: any) {\n    if (Buffer.isBuffer(value) || typeof value === 'string' || value instanceof Uint8Array || value instanceof ArrayBuffer) {\n      return;\n    }\n\n    rejectBlobs(value);\n\n    ValidationErrorItem.throwDataTypeValidationError(\n      `${util.inspect(value)} is not a valid binary value: Only strings, Buffer, Uint8Array and ArrayBuffer are supported.`,\n    );\n  }\n\n  sanitize(value: unknown): unknown {\n    if (value instanceof Uint8Array || value instanceof ArrayBuffer) {\n      return makeBufferFromTypedArray(value);\n    }\n\n    if (typeof value === 'string') {\n      return Buffer.from(value);\n    }\n\n    return value;\n  }\n\n  escape(value: string | Buffer) {\n    const buf = typeof value === 'string' ? Buffer.from(value, 'binary') : value;\n\n    return this._getDialect().escapeBuffer(buf);\n  }\n\n  getBindParamSql(value: AcceptedBlob, options: BindParamOptions) {\n    return options.bindParam(value);\n  }\n}\n\nexport interface RangeOptions {\n  subtype?: DataTypeClassOrInstance;\n}\n\nconst defaultRangeParser = buildRangeParser(identity);\n\n/**\n * Range types are data types representing a range of values of some element type (called the range's subtype).\n * Only available in Postgres. See [the Postgres documentation](http://www.postgresql.org/docs/9.4/static/rangetypes.html) for more details\n *\n * __Fallback policy:__\n * If this type is not supported, an error will be raised.\n *\n * @example\n * ```ts\n * // A range of integers\n * DataTypes.RANGE(DataTypes.INTEGER)\n * // A range of bigints\n * DataTypes.RANGE(DataTypes.BIGINT)\n * // A range of decimals\n * DataTypes.RANGE(DataTypes.DECIMAL)\n * // A range of timestamps\n * DataTypes.RANGE(DataTypes.DATE)\n * // A range of dates\n * DataTypes.RANGE(DataTypes.DATEONLY)\n * ```\n *\n * @category DataTypes\n */\nexport class RANGE<T extends BaseNumberDataType | DATE | DATEONLY = INTEGER> extends AbstractDataType<\n  Rangable<AcceptableTypeOf<T>> | AcceptableTypeOf<T>\n> {\n  /** @hidden */\n  static readonly [kDataTypeIdentifier]: string = 'RANGE';\n  readonly options: {\n    subtype: AbstractDataType<any>,\n  };\n\n  /**\n   * @param subtypeOrOptions A subtype for range, like RANGE(DATE)\n   */\n  constructor(subtypeOrOptions: DataTypeClassOrInstance | RangeOptions) {\n    super();\n\n    const subtypeRaw = (isDataType(subtypeOrOptions) ? subtypeOrOptions : subtypeOrOptions?.subtype)\n      ?? new INTEGER();\n\n    const subtype: DataTypeInstance = isDataTypeClass(subtypeRaw)\n      ? new subtypeRaw()\n      : subtypeRaw;\n\n    this.options = {\n      subtype,\n    };\n  }\n\n  protected _checkOptionSupport(dialect: AbstractDialect) {\n    super._checkOptionSupport(dialect);\n\n    if (!dialect.supports.dataTypes.RANGE) {\n      throwUnsupportedDataType(dialect, 'RANGE');\n    }\n  }\n\n  toDialectDataType(dialect: AbstractDialect): this {\n    let replacement = super.toDialectDataType(dialect);\n\n    if (replacement === this) {\n      replacement = replacement.clone();\n    }\n\n    replacement.options.subtype = replacement.options.subtype.toDialectDataType(dialect);\n\n    return replacement;\n  }\n\n  parseDatabaseValue(value: unknown): unknown {\n    // node-postgres workaround: The SQL Type-based parser is not called by node-postgres for values returned by Model.findOrCreate.\n    if (typeof value === 'string') {\n      value = defaultRangeParser(value);\n    }\n\n    if (!Array.isArray(value)) {\n      throw new Error(`DataTypes.RANGE received a non-range value from the database: ${util.inspect(value)}`);\n    }\n\n    return value.map(part => {\n      return {\n        ...part,\n        value: this.options.subtype.parseDatabaseValue(part.value),\n      };\n    });\n  }\n\n  sanitize(value: unknown): unknown {\n    if (!Array.isArray(value)) {\n      return value;\n    }\n\n    // this is the \"empty\" range, which is not the same value as \"(,)\" (represented by [null, null])\n    if (value.length === 0) {\n      return value;\n    }\n\n    let [low, high] = value;\n    if (!isPlainObject(low)) {\n      low = { value: low ?? null, inclusive: true };\n    }\n\n    if (!isPlainObject(high)) {\n      high = { value: high ?? null, inclusive: false };\n    }\n\n    return [this.#sanitizeSide(low), this.#sanitizeSide(high)];\n  }\n\n  #sanitizeSide(rangePart: RangePart<unknown>) {\n    if (rangePart.value == null) {\n      return rangePart;\n    }\n\n    return { ...rangePart, value: this.options.subtype.sanitize(rangePart.value) };\n  }\n\n  validate(value: any) {\n    if (!Array.isArray(value) || (value.length !== 2 && value.length !== 0)) {\n      ValidationErrorItem.throwDataTypeValidationError(\n        `A range must either be an array with two elements, or an empty array for the empty range. Got ${util.inspect(value)}.`,\n      );\n    }\n  }\n\n  toSql(): string {\n    throw new Error('RANGE has not been implemented in this dialect.');\n  }\n}\n\n/**\n * A column storing a unique universal identifier.\n * Use with `UUIDV1` or `UUIDV4` for default values.\n *\n * __Fallback policy:__\n * If this type is not supported, it will be replaced by a string type with a CHECK constraint to enforce a GUID format.\n *\n * @example\n * ```ts\n * const User = sequelize.define('User', {\n *   id: {\n *     type: DataTypes.UUID,\n *   },\n * });\n * ```\n *\n * @category DataTypes\n */\nexport class UUID extends AbstractDataType<string> {\n  /** @hidden */\n  static readonly [kDataTypeIdentifier]: string = 'UUID';\n\n  validate(value: any) {\n    if (typeof value !== 'string' || !Validator.isUUID(value)) {\n      ValidationErrorItem.throwDataTypeValidationError(\n        util.format('%O is not a valid uuid', value),\n      );\n    }\n  }\n\n  toSql(): string {\n    return 'UUID';\n  }\n}\n\n/**\n * A default unique universal identifier generated following the UUID v1 standard.\n * Cannot be used as a type, must be used as a default value instead.\n *\n * @example\n * ```ts\n * const User = sequelize.define('User', {\n *   id: {\n *     type: DataTypes.UUID,\n *     defaultValue: DataTypes.UUIDV1,\n *   },\n * });\n * ```\n *\n * @category DataTypes\n */\n// TODO: this should not be a DataType. Replace with a new version of `fn` that is dialect-aware, so we don't need to hardcode it in toDefaultValue().\nexport class UUIDV1 extends AbstractDataType<string> {\n  /** @hidden */\n  static readonly [kDataTypeIdentifier]: string = 'UUIDV1';\n\n  validate(value: any) {\n    if (typeof value !== 'string' || !Validator.isUUID(value, 1)) {\n      ValidationErrorItem.throwDataTypeValidationError(\n        util.format('%O is not a valid uuidv1', value),\n      );\n    }\n  }\n\n  toSql(): string {\n    throw new Error('toSQL should not be called on DataTypes.UUIDV1');\n  }\n}\n\n/**\n * A default unique universal identifier generated following the UUID v4 standard.\n * Cannot be used as a type, must be used as a default value instead.\n *\n * @example\n * ```ts\n * const User = sequelize.define('User', {\n *   id: {\n *     type: DataTypes.UUID,\n *     defaultValue: DataTypes.UUIDV4,\n *   },\n * });\n * ```\n *\n * @category DataTypes\n */\n// TODO: this should not be a DataType. Replace with a new version of `fn` that is dialect-aware, so we don't need to hardcode it in toDefaultValue().\nexport class UUIDV4 extends AbstractDataType<string> {\n  /** @hidden */\n  static readonly [kDataTypeIdentifier]: string = 'UUIDV4';\n\n  validate(value: unknown) {\n    if (typeof value !== 'string' || !Validator.isUUID(value, 4)) {\n      ValidationErrorItem.throwDataTypeValidationError(\n        util.format('%O is not a valid uuidv4', value),\n      );\n    }\n  }\n\n  toSql(): string {\n    throw new Error('toSQL should not be called on DataTypes.UUIDV4');\n  }\n}\n\nexport interface VirtualOptions {\n  returnType?: DataTypeClassOrInstance | undefined;\n  attributeDependencies?: string[] | undefined;\n}\n\nexport interface NormalizedVirtualOptions {\n  returnType: DataTypeClassOrInstance | undefined;\n  attributeDependencies: string[];\n}\n\n/**\n * A virtual value that is not stored in the DB. This could for example be useful if you want to provide a default value in your model that is returned to the user but not stored in the DB.\n *\n * You could also use it to validate a value before permuting and storing it. VIRTUAL also takes a return type and dependency fields as arguments\n * If a virtual attribute is present in `attributes` it will automatically pull in the extra fields as well.\n * Return type is mostly useful for setups that rely on types like GraphQL.\n *\n * @example Checking password length before hashing it\n * ```ts\n * sequelize.define('user', {\n *   password_hash: DataTypes.STRING,\n *   password: {\n *     type: DataTypes.VIRTUAL,\n *     set: function (val) {\n *        // Remember to set the data value, otherwise it won't be validated\n *        this.setDataValue('password', val);\n *        this.setDataValue('password_hash', this.salt + val);\n *      },\n *      validate: {\n *         isLongEnough: function (val) {\n *           if (val.length < 7) {\n *             throw new Error(\"Please choose a longer password\")\n *          }\n *       }\n *     }\n *   }\n * })\n * ```\n *\n * In the above code the password is stored plainly in the password field so it can be validated, but is never stored in the DB.\n *\n * @example Virtual with dependency fields\n * ```ts\n * {\n *   active: {\n *     type: new DataTypes.VIRTUAL(DataTypes.BOOLEAN, ['createdAt']),\n *     get: function() {\n *       return this.get('createdAt') > Date.now() - (7 * 24 * 60 * 60 * 1000)\n *     }\n *   }\n * }\n * ```\n *\n * @category DataTypes\n */\nexport class VIRTUAL<T> extends AbstractDataType<T> {\n  /** @hidden */\n  static readonly [kDataTypeIdentifier]: string = 'VIRTUAL';\n\n  options: NormalizedVirtualOptions;\n\n  constructor(returnType?: DataTypeClassOrInstance, attributeDependencies?: string[]);\n  constructor(options?: VirtualOptions);\n\n  // we have to define the constructor overloads using tuples due to a TypeScript limitation\n  //  https://github.com/microsoft/TypeScript/issues/29732, to play nice with classToInvokable.\n  /** @hidden */\n  constructor(...args:\n    | [returnType?: DataTypeClassOrInstance, attributeDependencies?: string[]]\n    | [options?: VirtualOptions]\n  );\n\n  /**\n   * @param [returnTypeOrOptions] return type for virtual type, or an option bag\n   * @param [attributeDependencies] array of attributes this virtual type is dependent on\n   */\n  constructor(returnTypeOrOptions?: DataTypeClassOrInstance | VirtualOptions, attributeDependencies?: string[]) {\n    super();\n\n    const returnType = returnTypeOrOptions == null ? undefined\n      : isDataType(returnTypeOrOptions) ? returnTypeOrOptions\n      : returnTypeOrOptions.returnType;\n\n    this.options = {\n      returnType: returnType ? dataTypeClassOrInstanceToInstance(returnType) : undefined,\n      attributeDependencies: (isDataType(returnTypeOrOptions)\n        ? attributeDependencies\n        : returnTypeOrOptions?.attributeDependencies) ?? [],\n    };\n  }\n\n  toSql(): string {\n    throw new Error('toSQL should not be called on DataTypes.VIRTUAL');\n  }\n\n  get returnType() {\n    return this.options.returnType;\n  }\n\n  get attributeDependencies() {\n    return this.options.attributeDependencies;\n  }\n}\n\n/**\n * If an array, each element in the array is a possible value for the ENUM.\n *\n * If a record (plain object, typescript enum),\n * it will use the keys as the list of possible values for the ENUM, in the order specified by the Object.\n * This is designed to be used with TypeScript enums, but it can be used with plain objects as well.\n * Because we don't handle any mapping between the enum keys and values, we require that they be the same.\n */\ntype EnumValues<Member extends string> = readonly Member[] | Record<Member, Member>;\n\nexport interface EnumOptions<Member extends string> {\n  values: EnumValues<Member>;\n}\n\nexport interface NormalizedEnumOptions<Member extends string> {\n  values: readonly Member[];\n}\n\n/**\n * An enumeration, Postgres Only\n *\n * __Fallback policy:__\n * If this type is not supported, it will be replaced by a string type with a CHECK constraint to enforce a list of values.\n *\n * @example\n * ```ts\n * DataTypes.ENUM('value', 'another value')\n * DataTypes.ENUM(['value', 'another value'])\n * DataTypes.ENUM({\n *   values: ['value', 'another value'],\n * });\n * ```\n *\n * @category DataTypes\n */\nexport class ENUM<Member extends string> extends AbstractDataType<Member> {\n  /** @hidden */\n  static readonly [kDataTypeIdentifier]: string = 'ENUM';\n  readonly options: NormalizedEnumOptions<Member>;\n\n  /**\n   * @param options either array of values or options object with values array. It also supports variadic values.\n   */\n  constructor(options: EnumOptions<Member>);\n  constructor(members: EnumValues<Member>);\n  constructor(...members: Member[]);\n  // we have to define the constructor overloads using tuples due to a TypeScript limitation\n  //  https://github.com/microsoft/TypeScript/issues/29732, to play nice with classToInvokable.\n  /** @hidden */\n  constructor(...args:\n    | [options: EnumOptions<Member>]\n    | [members: EnumValues<Member>]\n    | [...members: Member[]]\n  );\n  constructor(...args: [EnumValues<Member> | Member | EnumOptions<Member>, ...Member[]]) {\n    super();\n\n    const values: readonly Member[] = this.#getEnumValues(args);\n\n    if (values.length === 0) {\n      throw new TypeError(`\nDataTypes.ENUM cannot be used without specifying its possible enum values.\n\nNote that the \"values\" property has been removed from column definitions. The following is no longer supported:\n\nsequelize.define('MyModel', {\n  roles: {\n    type: DataTypes.ENUM,\n    values: ['admin', 'user'],\n  },\n});\n\nInstead, define enum values like this:\n\nsequelize.define('MyModel', {\n  roles: {\n    type: DataTypes.ENUM(['admin', 'user']),\n  },\n});\n`.trim());\n    }\n\n    for (const value of values) {\n      if (typeof value !== 'string') {\n        throw new TypeError(util.format(`One of the possible values passed to DataTypes.ENUM (%O) is not a string. Only strings can be used as enum values.`, value));\n      }\n    }\n\n    this.options = {\n      values,\n    };\n  }\n\n  #getEnumValues(args: [EnumValues<Member> | Member | EnumOptions<Member>, ...Member[]]): readonly Member[] {\n    if (args.length === 0) {\n      return EMPTY_ARRAY;\n    }\n\n    const [first, ...rest] = args;\n\n    if (isString(first)) {\n      return [first, ...rest];\n    }\n\n    if (rest.length > 0) {\n      throw new TypeError('DataTypes.ENUM has been constructed incorrectly: Its first parameter is the option bag or the array of values, but more than one parameter has been provided.');\n    }\n\n    let enumOrArray: EnumValues<Member>;\n    if (!Array.isArray(first) && 'values' in first && typeof first.values !== 'string') {\n      // This is the option bag\n      // @ts-expect-error -- Array.isArray does not narrow correctly when the array is readonly\n      enumOrArray = first.values;\n    } else {\n      // @ts-expect-error -- Array.isArray does not narrow correctly when the array is readonly\n      enumOrArray = first;\n    }\n\n    if (Array.isArray(enumOrArray)) {\n      return [...enumOrArray];\n    }\n\n    // @ts-expect-error -- Array.isArray does not narrow correctly when the array is readonly\n    const theEnum: Record<Member, Member> = enumOrArray;\n    const enumKeys = Object.keys(theEnum) as Member[];\n    for (const enumKey of enumKeys) {\n      if (theEnum[enumKey] !== enumKey) {\n        throw new TypeError(`DataTypes.ENUM has been constructed incorrectly: When specifying values as a TypeScript enum or an object of key-values, the values of the object must be equal to their keys.`);\n      }\n    }\n\n    return enumKeys;\n  }\n\n  validate(value: any): asserts value is Member {\n    if (!this.options.values.includes(value)) {\n      ValidationErrorItem.throwDataTypeValidationError(\n        util.format('%O is not a valid choice for enum %O', value, this.options.values),\n      );\n    }\n  }\n\n  toSql(): string {\n    throw new Error(`ENUM has not been implemented in the ${this._getDialect().name} dialect.`);\n  }\n}\n\nexport interface ArrayOptions {\n  type: DataTypeClassOrInstance;\n}\n\ninterface NormalizedArrayOptions {\n  type: NormalizedDataType;\n}\n\n/**\n * An array of `type`. Only available in Postgres.\n *\n * __Fallback policy:__\n * If this type is not supported, an error will be raised.\n *\n * @example\n * ```ts\n * DataTypes.ARRAY(DataTypes.DECIMAL)\n * ```\n *\n * @category DataTypes\n */\nexport class ARRAY<T extends AbstractDataType<any>> extends AbstractDataType<Array<AcceptableTypeOf<T>>> {\n  /** @hidden */\n  static readonly [kDataTypeIdentifier]: string = 'ARRAY';\n  readonly options: NormalizedArrayOptions;\n\n  /**\n   * @param typeOrOptions type of array values\n   */\n  constructor(typeOrOptions: DataType | ArrayOptions) {\n    super();\n\n    const rawType = isDataType(typeOrOptions) ? typeOrOptions : typeOrOptions?.type;\n\n    if (!rawType) {\n      throw new TypeError('DataTypes.ARRAY is missing type definition for its values.');\n    }\n\n    this.options = {\n      type: isString(rawType) ? rawType : dataTypeClassOrInstanceToInstance(rawType),\n    };\n  }\n\n  toSql(): string {\n    return `${attributeTypeToSql(this.options.type)}[]`;\n  }\n\n  validate(value: any) {\n    if (!Array.isArray(value)) {\n      ValidationErrorItem.throwDataTypeValidationError(\n        util.format('%O is not a valid array', value),\n      );\n    }\n\n    if (isString(this.options.type)) {\n      return;\n    }\n\n    const subType: AbstractDataType<any> = this.options.type;\n\n    for (const item of value) {\n      subType.validate(item);\n    }\n  }\n\n  sanitize(value: unknown): unknown {\n    if (!Array.isArray(value)) {\n      return value;\n    }\n\n    if (isString(this.options.type)) {\n      return;\n    }\n\n    const subType: AbstractDataType<any> = this.options.type;\n\n    return value.map(item => subType.sanitize(item));\n  }\n\n  parseDatabaseValue(value: unknown[]): unknown {\n    if (!Array.isArray(value)) {\n      throw new Error(`DataTypes.ARRAY Received a non-array value from database: ${util.inspect(value)}`);\n    }\n\n    if (isString(this.options.type)) {\n      return value;\n    }\n\n    const subType: AbstractDataType<any> = this.options.type;\n\n    return value.map(item => subType.parseDatabaseValue(item));\n  }\n\n  toBindableValue(value: Array<AcceptableTypeOf<T>>): unknown {\n    if (isString(this.options.type)) {\n      return value;\n    }\n\n    const subType: AbstractDataType<any> = this.options.type;\n\n    return value.map(val => subType.toBindableValue(val));\n  }\n\n  protected _checkOptionSupport(dialect: AbstractDialect) {\n    super._checkOptionSupport(dialect);\n\n    if (!dialect.supports.dataTypes.ARRAY) {\n      throwUnsupportedDataType(dialect, 'ARRAY');\n    }\n  }\n\n  toDialectDataType(dialect: AbstractDialect): this {\n    let replacement = super.toDialectDataType(dialect);\n\n    if (replacement === this) {\n      replacement = replacement.clone();\n    }\n\n    if (!isString(replacement.options.type)) {\n      replacement.options.type = replacement.options.type.toDialectDataType(dialect);\n    }\n\n    return replacement;\n  }\n\n  attachUsageContext(usageContext: DataTypeUseContext): this {\n    if (!isString(this.options.type)) {\n      this.options.type.attachUsageContext(usageContext);\n    }\n\n    return super.attachUsageContext(usageContext);\n  }\n\n  static is<T extends AbstractDataType<any>>(\n    obj: unknown,\n    type: new () => T,\n  ): obj is ARRAY<T> {\n    return obj instanceof ARRAY && (obj).options.type instanceof type;\n  }\n}\n\nexport interface GeometryOptions {\n  type?: GeoJsonType | undefined;\n  srid?: number | undefined;\n}\n\n/**\n * A column storing Geometry information.\n * It is only available in PostgreSQL (with PostGIS), MariaDB or MySQL.\n *\n * GeoJSON is accepted as input and returned as output.\n *\n * In PostGIS, the GeoJSON is parsed using the PostGIS function `STGeomFromGeoJSON`.\n * In MySQL it is parsed using the function `STGeomFromText`.\n *\n * Therefore, one can just follow the [GeoJSON spec](https://tools.ietf.org/html/rfc7946) for handling geometry objects.  See the following examples:\n *\n * __Fallback policy:__\n * If this type is not supported, an error will be raised.\n *\n * @example Defining a Geometry type attribute\n * ```ts\n * DataTypes.GEOMETRY\n * DataTypes.GEOMETRY('POINT')\n * DataTypes.GEOMETRY('POINT', 4326)\n * ```\n *\n * @example Create a new point\n * ```ts\n * const point = { type: 'Point', coordinates: [-76.984722, 39.807222]}; // GeoJson format: [lng, lat]\n *\n * User.create({username: 'username', geometry: point });\n * ```\n *\n * @example Create a new linestring\n * ```ts\n * const line = { type: 'LineString', 'coordinates': [ [100.0, 0.0], [101.0, 1.0] ] };\n *\n * User.create({username: 'username', geometry: line });\n * ```\n *\n * @example Create a new polygon\n * ```ts\n * const polygon = { type: 'Polygon', coordinates: [\n *                 [ [100.0, 0.0], [101.0, 0.0], [101.0, 1.0],\n *                   [100.0, 1.0], [100.0, 0.0] ]\n *                 ]};\n *\n * User.create({username: 'username', geometry: polygon });\n * ```\n *\n * @example Create a new point with a custom SRID\n * ```ts\n * const point = {\n *   type: 'Point',\n *   coordinates: [-76.984722, 39.807222], // GeoJson format: [lng, lat]\n *   crs: { type: 'name', properties: { name: 'EPSG:4326'} }\n * };\n *\n * User.create({username: 'username', geometry: point })\n * ```\n *\n * @category DataTypes\n */\nexport class GEOMETRY extends AbstractDataType<GeoJson> {\n  /** @hidden */\n  static readonly [kDataTypeIdentifier]: string = 'GEOMETRY';\n  readonly options: GeometryOptions;\n\n  /**\n   * @param {string} [type] Type of geometry data\n   * @param {string} [srid] SRID of type\n   */\n  constructor(type: GeoJsonType, srid?: number);\n  constructor(options: GeometryOptions);\n\n  // we have to define the constructor overloads using tuples due to a TypeScript limitation\n  //  https://github.com/microsoft/TypeScript/issues/29732, to play nice with classToInvokable.\n  /** @hidden */\n  constructor(...args:\n    | [type: GeoJsonType, srid?: number]\n    | [options: GeometryOptions]\n  );\n\n  constructor(typeOrOptions: GeoJsonType | GeometryOptions, srid?: number) {\n    super();\n\n    this.options = isObject(typeOrOptions)\n      ? { ...typeOrOptions }\n      : { type: typeOrOptions, srid };\n  }\n\n  protected _checkOptionSupport(dialect: AbstractDialect) {\n    super._checkOptionSupport(dialect);\n\n    if (!dialect.supports.dataTypes.GEOMETRY) {\n      throwUnsupportedDataType(dialect, 'GEOMETRY');\n    }\n  }\n\n  validate(value: unknown): asserts value is GeoJson {\n    try {\n      assertIsGeoJson(value);\n    } catch (error) {\n      if (!(error instanceof Error)) {\n        throw error;\n      }\n\n      // TODO: add 'cause'\n      ValidationErrorItem.throwDataTypeValidationError(error.message);\n    }\n\n    return super.validate(value);\n  }\n\n  toSql(): string {\n    return 'GEOMETRY';\n  }\n}\n\n/**\n * A geography datatype represents two dimensional spacial objects in an elliptic coord system.\n *\n * **The difference from geometry and geography type:**\n *\n * PostGIS 1.5 introduced a new spatial type called geography, which uses geodetic measurement instead of Cartesian measurement.\n * Coordinate points in the geography type are always represented in WGS 84 lon lat degrees (SRID 4326),\n * but measurement functions and relationships STDistance, STDWithin, STLength, and STArea always return answers in meters or assume inputs in meters.\n *\n * **What is best to use? It depends:**\n *\n * When choosing between the geometry and geography type for data storage, you should consider what you\u2019ll be using it for.\n * If all you do are simple measurements and relationship checks on your data, and your data covers a fairly large area, then most likely you\u2019ll be better off storing your data using the new geography type.\n * Although the new geography data type can cover the globe, the geometry type is far from obsolete.\n * The geometry type has a much richer set of functions than geography, relationship checks are generally faster, and it has wider support currently across desktop and web-mapping tools\n *\n * __Fallback policy:__\n * If this type is not supported, an error will be raised.\n *\n * @example Defining a Geography type attribute\n * ```ts\n * DataTypes.GEOGRAPHY\n * DataTypes.GEOGRAPHY('POINT')\n * DataTypes.GEOGRAPHY('POINT', 4326)\n * ```\n *\n * @category DataTypes\n */\nexport class GEOGRAPHY extends GEOMETRY {\n  /** @hidden */\n  static readonly [kDataTypeIdentifier]: string = 'GEOGRAPHY';\n\n  protected _checkOptionSupport(dialect: AbstractDialect) {\n    if (!dialect.supports.dataTypes.GEOGRAPHY) {\n      throwUnsupportedDataType(dialect, 'GEOGRAPHY');\n    }\n  }\n\n  toSql(): string {\n    return 'GEOGRAPHY';\n  }\n}\n\n/**\n * The cidr type holds an IPv4 or IPv6 network specification. Takes 7 or 19 bytes.\n *\n * Only available for Postgres\n *\n * __Fallback policy:__\n * If this type is not supported, an error will be raised.\n *\n * @example\n * ```ts\n * DataTypes.CIDR\n * ```\n *\n * @category DataTypes\n */\nexport class CIDR extends AbstractDataType<string> {\n  /** @hidden */\n  static readonly [kDataTypeIdentifier]: string = 'CIDR';\n\n  protected _checkOptionSupport(dialect: AbstractDialect) {\n    if (!dialect.supports.dataTypes.CIDR) {\n      throwUnsupportedDataType(dialect, 'CIDR');\n    }\n  }\n\n  validate(value: any) {\n    if (typeof value !== 'string' || !Validator.isIPRange(value)) {\n      ValidationErrorItem.throwDataTypeValidationError(\n        util.format('%O is not a valid CIDR', value),\n      );\n    }\n  }\n\n  toSql(): string {\n    return 'CIDR';\n  }\n}\n\n/**\n * The INET type holds an IPv4 or IPv6 host address, and optionally its subnet. Takes 7 or 19 bytes\n *\n * Only available for Postgres\n *\n * __Fallback policy:__\n * If this type is not supported, an error will be raised.\n *\n * @example\n * ```ts\n * DataTypes.INET\n * ```\n *\n * @category DataTypes\n */\nexport class INET extends AbstractDataType<string> {\n  /** @hidden */\n  static readonly [kDataTypeIdentifier]: string = 'INET';\n\n  protected _checkOptionSupport(dialect: AbstractDialect) {\n    if (!dialect.supports.dataTypes.INET) {\n      throwUnsupportedDataType(dialect, 'INET');\n    }\n  }\n\n  validate(value: any) {\n    if (typeof value !== 'string' || !Validator.isIP(value)) {\n      ValidationErrorItem.throwDataTypeValidationError(\n        util.format('%O is not a valid INET', value),\n      );\n    }\n  }\n\n  toSql(): string {\n    return 'INET';\n  }\n}\n\n/**\n * The MACADDR type stores MAC addresses. Takes 6 bytes\n *\n * Only available for Postgres\n *\n * __Fallback policy:__\n * If this type is not supported, an error will be raised.\n *\n * @example\n * ```ts\n * DataTypes.MACADDR\n * ```\n *\n * @category DataTypes\n */\nexport class MACADDR extends AbstractDataType<string> {\n  /** @hidden */\n  static readonly [kDataTypeIdentifier]: string = 'MACADDR';\n\n  protected _checkOptionSupport(dialect: AbstractDialect) {\n    if (!dialect.supports.dataTypes.MACADDR) {\n      throwUnsupportedDataType(dialect, 'MACADDR');\n    }\n  }\n\n  validate(value: any) {\n    if (typeof value !== 'string' || !Validator.isMACAddress(value)) {\n      ValidationErrorItem.throwDataTypeValidationError(\n        util.format('%O is not a valid MACADDR', value),\n      );\n    }\n  }\n\n  toSql(): string {\n    return 'MACADDR';\n  }\n}\n\n/**\n * The TSVECTOR type stores text search vectors.\n *\n * Only available for Postgres\n *\n * __Fallback policy:__\n * If this type is not supported, an error will be raised.\n *\n * @example\n * ```ts\n * DataTypes.TSVECTOR\n * ```\n *\n * @category DataTypes\n */\nexport class TSVECTOR extends AbstractDataType<string> {\n  /** @hidden */\n  static readonly [kDataTypeIdentifier]: string = 'TSVECTOR';\n\n  validate(value: any) {\n    if (typeof value !== 'string') {\n      ValidationErrorItem.throwDataTypeValidationError(\n        util.format('%O is not a valid string', value),\n      );\n    }\n  }\n\n  protected _checkOptionSupport(dialect: AbstractDialect) {\n    if (!dialect.supports.dataTypes.TSVECTOR) {\n      throwUnsupportedDataType(dialect, 'TSVECTOR');\n    }\n  }\n\n  toSql(): string {\n    return 'TSVECTOR';\n  }\n}\n\nfunction rejectBlobs(value: unknown) {\n  // We have a DataType called BLOB. People might try to use the built-in Blob type with it, which they cannot.\n  // To clarify why it doesn't work, we have a dedicated message for it.\n  if (Blob && value instanceof Blob) {\n    ValidationErrorItem.throwDataTypeValidationError('Blob instances are not supported values, because reading their data is an async operation. Call blob.arrayBuffer() to get a buffer, and pass that to Sequelize instead.');\n  }\n}\n\nfunction assertDataTypeSupported(dialect: AbstractDialect, dataType: AbstractDataType<any>) {\n  const typeId = dataType.getDataTypeId();\n\n  if (\n    typeId in dialect.supports.dataTypes\n    // @ts-expect-error -- it's possible that typeId isn't listed in the support table, but that's checked above\n    && !dialect.supports.dataTypes[typeId]\n  ) {\n    throwUnsupportedDataType(dialect, typeId);\n  }\n}\n"],
  "mappings": "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",
  "names": ["import_dayjs", "isEqual", "isObject", "util", "Validator", "dayjs", "identity"]
}
