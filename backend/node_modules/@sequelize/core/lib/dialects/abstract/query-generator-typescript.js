"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var query_generator_typescript_exports = {};
__export(query_generator_typescript_exports, {
  AbstractQueryGeneratorTypeScript: () => AbstractQueryGeneratorTypeScript,
  DROP_TABLE_QUERY_SUPPORTABLE_OPTIONS: () => DROP_TABLE_QUERY_SUPPORTABLE_OPTIONS,
  LIST_TABLES_QUERY_SUPPORTABLE_OPTIONS: () => LIST_TABLES_QUERY_SUPPORTABLE_OPTIONS,
  QUOTE_TABLE_SUPPORTABLE_OPTIONS: () => QUOTE_TABLE_SUPPORTABLE_OPTIONS,
  REMOVE_COLUMN_QUERY_SUPPORTABLE_OPTIONS: () => REMOVE_COLUMN_QUERY_SUPPORTABLE_OPTIONS,
  REMOVE_CONSTRAINT_QUERY_SUPPORTABLE_OPTIONS: () => REMOVE_CONSTRAINT_QUERY_SUPPORTABLE_OPTIONS,
  REMOVE_INDEX_QUERY_SUPPORTABLE_OPTIONS: () => REMOVE_INDEX_QUERY_SUPPORTABLE_OPTIONS,
  SHOW_CONSTRAINTS_QUERY_SUPPORTABLE_OPTIONS: () => SHOW_CONSTRAINTS_QUERY_SUPPORTABLE_OPTIONS
});
module.exports = __toCommonJS(query_generator_typescript_exports);
var import_node_util = __toESM(require("node:util"));
var import_isObject = __toESM(require("lodash/isObject"));
var import_deferrable = require("../../deferrable.js");
var import_association_path = require("../../expression-builders/association-path.js");
var import_attribute = require("../../expression-builders/attribute.js");
var import_base_sql_expression = require("../../expression-builders/base-sql-expression.js");
var import_cast = require("../../expression-builders/cast.js");
var import_col = require("../../expression-builders/col.js");
var import_dialect_aware_fn = require("../../expression-builders/dialect-aware-fn.js");
var import_fn = require("../../expression-builders/fn.js");
var import_identifier = require("../../expression-builders/identifier.js");
var import_json_path = require("../../expression-builders/json-path.js");
var import_list = require("../../expression-builders/list.js");
var import_literal = require("../../expression-builders/literal.js");
var import_value = require("../../expression-builders/value.js");
var import_where = require("../../expression-builders/where.js");
var import_index_hints = require("../../index-hints.js");
var import_operators = require("../../operators.js");
var import_sql_string = require("../../sql-string.js");
var import_table_hints = require("../../table-hints.js");
var import_check = require("../../utils/check.js");
var import_deprecations = require("../../utils/deprecations.js");
var import_dialect = require("../../utils/dialect.js");
var import_join_sql_fragments = require("../../utils/join-sql-fragments.js");
var import_model_utils = require("../../utils/model-utils.js");
var import_object = require("../../utils/object.js");
var import_sql = require("../../utils/sql.js");
var import_data_types_utils = require("./data-types-utils.js");
var import_data_types = require("./data-types.js");
var import_where_sql_builder = require("./where-sql-builder.js");
const DROP_TABLE_QUERY_SUPPORTABLE_OPTIONS = /* @__PURE__ */ new Set(["cascade"]);
const LIST_TABLES_QUERY_SUPPORTABLE_OPTIONS = /* @__PURE__ */ new Set(["schema"]);
const QUOTE_TABLE_SUPPORTABLE_OPTIONS = /* @__PURE__ */ new Set(["indexHints", "tableHints"]);
const REMOVE_COLUMN_QUERY_SUPPORTABLE_OPTIONS = /* @__PURE__ */ new Set(["ifExists", "cascade"]);
const REMOVE_CONSTRAINT_QUERY_SUPPORTABLE_OPTIONS = /* @__PURE__ */ new Set(["ifExists", "cascade"]);
const REMOVE_INDEX_QUERY_SUPPORTABLE_OPTIONS = /* @__PURE__ */ new Set(["concurrently", "ifExists", "cascade"]);
const SHOW_CONSTRAINTS_QUERY_SUPPORTABLE_OPTIONS = /* @__PURE__ */ new Set(["columnName", "constraintName", "constraintType"]);
class AbstractQueryGeneratorTypeScript {
  whereSqlBuilder;
  dialect;
  sequelize;
  constructor(options) {
    if (!options.sequelize) {
      throw new Error("QueryGenerator initialized without options.sequelize");
    }
    if (!options.dialect) {
      throw new Error("QueryGenerator initialized without options.dialect");
    }
    this.sequelize = options.sequelize;
    this.dialect = options.dialect;
    this.whereSqlBuilder = new import_where_sql_builder.WhereSqlBuilder(this);
  }
  get options() {
    return this.sequelize.options;
  }
  _getTechnicalSchemaNames() {
    return [];
  }
  listSchemasQuery(_options) {
    if (this.dialect.supports.schemas) {
      throw new Error(`${this.dialect.name} declares supporting schema but listSchemasQuery is not implemented.`);
    }
    throw new Error(`Schemas are not supported in ${this.dialect.name}.`);
  }
  describeTableQuery(tableName) {
    return `DESCRIBE ${this.quoteTable(tableName)};`;
  }
  dropTableQuery(tableName, options) {
    const DROP_TABLE_QUERY_SUPPORTED_OPTIONS = /* @__PURE__ */ new Set();
    if (this.dialect.supports.dropTable.cascade) {
      DROP_TABLE_QUERY_SUPPORTED_OPTIONS.add("cascade");
    }
    if (options) {
      (0, import_check.rejectInvalidOptions)(
        "dropTableQuery",
        this.dialect.name,
        DROP_TABLE_QUERY_SUPPORTABLE_OPTIONS,
        DROP_TABLE_QUERY_SUPPORTED_OPTIONS,
        options
      );
    }
    return (0, import_join_sql_fragments.joinSQLFragments)([
      "DROP TABLE IF EXISTS",
      this.quoteTable(tableName),
      (options == null ? void 0 : options.cascade) ? "CASCADE" : ""
    ]);
  }
  listTablesQuery(_options) {
    throw new Error(`listTablesQuery has not been implemented in ${this.dialect.name}.`);
  }
  removeColumnQuery(tableName, columnName, options) {
    if (options) {
      const REMOVE_COLUMN_QUERY_SUPPORTED_OPTIONS = /* @__PURE__ */ new Set();
      if (this.dialect.supports.removeColumn.cascade) {
        REMOVE_COLUMN_QUERY_SUPPORTED_OPTIONS.add("cascade");
      }
      if (this.dialect.supports.removeColumn.ifExists) {
        REMOVE_COLUMN_QUERY_SUPPORTED_OPTIONS.add("ifExists");
      }
      (0, import_check.rejectInvalidOptions)(
        "removeColumnQuery",
        this.dialect.name,
        REMOVE_COLUMN_QUERY_SUPPORTABLE_OPTIONS,
        REMOVE_COLUMN_QUERY_SUPPORTED_OPTIONS,
        options
      );
    }
    return (0, import_join_sql_fragments.joinSQLFragments)([
      "ALTER TABLE",
      this.quoteTable(tableName),
      "DROP COLUMN",
      (options == null ? void 0 : options.ifExists) ? "IF EXISTS" : "",
      this.quoteIdentifier(columnName),
      (options == null ? void 0 : options.cascade) ? "CASCADE" : ""
    ]);
  }
  addConstraintQuery(tableName, options) {
    if (!this.dialect.supports.constraints.add) {
      throw new Error(`Add constraint queries are not supported by ${this.dialect.name} dialect`);
    }
    return (0, import_join_sql_fragments.joinSQLFragments)([
      "ALTER TABLE",
      this.quoteTable(tableName),
      "ADD",
      this._getConstraintSnippet(tableName, options)
    ]);
  }
  _getConstraintSnippet(tableName, options) {
    const quotedFields = options.fields.map((field) => {
      if (typeof field === "string") {
        return this.quoteIdentifier(field);
      }
      if (field instanceof import_base_sql_expression.BaseSqlExpression) {
        return this.formatSqlExpression(field);
      }
      if (field.attribute) {
        throw new Error("The field.attribute property has been removed. Use the field.name property instead");
      }
      if (!field.name) {
        throw new Error(`The following index field has no name: ${field}`);
      }
      return this.quoteIdentifier(field.name);
    });
    const constraintNameParts = options.name ? null : options.fields.map((field) => {
      if (typeof field === "string") {
        return field;
      }
      if (field instanceof import_base_sql_expression.BaseSqlExpression) {
        throw new TypeError(`The constraint name must be provided explicitly if one of Sequelize's method (literal(), col(), etc\u2026) is used in the constraint's fields`);
      }
      return field.name;
    });
    let constraintSnippet;
    const table = this.extractTableDetails(tableName);
    const fieldsSqlQuotedString = quotedFields.join(", ");
    const fieldsSqlString = constraintNameParts == null ? void 0 : constraintNameParts.join("_");
    switch (options.type.toUpperCase()) {
      case "CHECK": {
        if (!this.dialect.supports.constraints.check) {
          throw new Error(`Check constraints are not supported by ${this.dialect.name} dialect`);
        }
        const constraintName = this.quoteIdentifier(options.name || `${table.tableName}_${fieldsSqlString}_ck`);
        constraintSnippet = `CONSTRAINT ${constraintName} CHECK (${this.whereItemsQuery(options.where)})`;
        break;
      }
      case "UNIQUE": {
        if (!this.dialect.supports.constraints.unique) {
          throw new Error(`Unique constraints are not supported by ${this.dialect.name} dialect`);
        }
        const constraintName = this.quoteIdentifier(options.name || `${table.tableName}_${fieldsSqlString}_uk`);
        constraintSnippet = `CONSTRAINT ${constraintName} UNIQUE (${fieldsSqlQuotedString})`;
        if (options.deferrable) {
          constraintSnippet += ` ${this._getDeferrableConstraintSnippet(options.deferrable)}`;
        }
        break;
      }
      case "DEFAULT": {
        if (!this.dialect.supports.constraints.default) {
          throw new Error(`Default constraints are not supported by ${this.dialect.name} dialect`);
        }
        if (options.defaultValue === void 0) {
          throw new Error("Default value must be specified for DEFAULT CONSTRAINT");
        }
        const constraintName = this.quoteIdentifier(options.name || `${table.tableName}_${fieldsSqlString}_df`);
        constraintSnippet = `CONSTRAINT ${constraintName} DEFAULT (${this.escape(options.defaultValue, options)}) FOR ${quotedFields[0]}`;
        break;
      }
      case "PRIMARY KEY": {
        if (!this.dialect.supports.constraints.primaryKey) {
          throw new Error(`Primary key constraints are not supported by ${this.dialect.name} dialect`);
        }
        const constraintName = this.quoteIdentifier(options.name || `${table.tableName}_${fieldsSqlString}_pk`);
        constraintSnippet = `CONSTRAINT ${constraintName} PRIMARY KEY (${fieldsSqlQuotedString})`;
        if (options.deferrable) {
          constraintSnippet += ` ${this._getDeferrableConstraintSnippet(options.deferrable)}`;
        }
        break;
      }
      case "FOREIGN KEY": {
        if (!this.dialect.supports.constraints.foreignKey) {
          throw new Error(`Foreign key constraints are not supported by ${this.dialect.name} dialect`);
        }
        const references = options.references;
        if (!references || !references.table || !(references.field || references.fields)) {
          throw new Error("Invalid foreign key constraint options. `references` object with `table` and `field` must be specified");
        }
        const referencedTable = this.extractTableDetails(references.table);
        const constraintName = this.quoteIdentifier(options.name || `${table.tableName}_${fieldsSqlString}_${referencedTable.tableName}_fk`);
        const quotedReferences = references.field !== void 0 ? this.quoteIdentifier(references.field) : references.fields.map((f) => this.quoteIdentifier(f)).join(", ");
        const referencesSnippet = `${this.quoteTable(referencedTable)} (${quotedReferences})`;
        constraintSnippet = `CONSTRAINT ${constraintName} `;
        constraintSnippet += `FOREIGN KEY (${fieldsSqlQuotedString}) REFERENCES ${referencesSnippet}`;
        if (options.onUpdate) {
          if (!this.dialect.supports.constraints.onUpdate) {
            throw new Error(`Foreign key constraint with onUpdate is not supported by ${this.dialect.name} dialect`);
          }
          constraintSnippet += ` ON UPDATE ${options.onUpdate.toUpperCase()}`;
        }
        if (options.onDelete) {
          constraintSnippet += ` ON DELETE ${options.onDelete.toUpperCase()}`;
        }
        if (options.deferrable) {
          constraintSnippet += ` ${this._getDeferrableConstraintSnippet(options.deferrable)}`;
        }
        break;
      }
      default: {
        throw new Error(`Constraint type ${options.type} is not supported by ${this.dialect.name} dialect`);
      }
    }
    return constraintSnippet;
  }
  _getDeferrableConstraintSnippet(deferrable) {
    if (!this.dialect.supports.constraints.deferrable) {
      throw new Error(`Deferrable constraints are not supported by ${this.dialect.name} dialect`);
    }
    switch (deferrable) {
      case import_deferrable.Deferrable.INITIALLY_DEFERRED: {
        return "DEFERRABLE INITIALLY DEFERRED";
      }
      case import_deferrable.Deferrable.INITIALLY_IMMEDIATE: {
        return "DEFERRABLE INITIALLY IMMEDIATE";
      }
      case import_deferrable.Deferrable.NOT: {
        return "NOT DEFERRABLE";
      }
      default: {
        throw new Error(`Unknown constraint checking behavior ${deferrable}`);
      }
    }
  }
  removeConstraintQuery(tableName, constraintName, options) {
    if (!this.dialect.supports.constraints.remove) {
      throw new Error(`Remove constraint queries are not supported by ${this.dialect.name} dialect`);
    }
    if (options) {
      const REMOVE_CONSTRAINT_QUERY_SUPPORTED_OPTIONS = /* @__PURE__ */ new Set();
      const { removeOptions } = this.dialect.supports.constraints;
      if (removeOptions.cascade) {
        REMOVE_CONSTRAINT_QUERY_SUPPORTED_OPTIONS.add("cascade");
      }
      if (removeOptions.ifExists) {
        REMOVE_CONSTRAINT_QUERY_SUPPORTED_OPTIONS.add("ifExists");
      }
      (0, import_check.rejectInvalidOptions)(
        "removeConstraintQuery",
        this.dialect.name,
        REMOVE_CONSTRAINT_QUERY_SUPPORTABLE_OPTIONS,
        REMOVE_CONSTRAINT_QUERY_SUPPORTED_OPTIONS,
        options
      );
    }
    return (0, import_join_sql_fragments.joinSQLFragments)([
      "ALTER TABLE",
      this.quoteTable(tableName),
      "DROP CONSTRAINT",
      (options == null ? void 0 : options.ifExists) ? "IF EXISTS" : "",
      this.quoteIdentifier(constraintName),
      (options == null ? void 0 : options.cascade) ? "CASCADE" : ""
    ]);
  }
  setConstraintCheckingQuery(type, constraints) {
    var _a;
    if (!this.dialect.supports.constraints.deferrable) {
      throw new Error(`Deferrable constraints are not supported by ${this.dialect.name} dialect`);
    }
    let constraintFragment = "ALL";
    if (type instanceof import_deferrable.ConstraintChecking) {
      if ((_a = type.constraints) == null ? void 0 : _a.length) {
        constraintFragment = type.constraints.map((constraint) => this.quoteIdentifier(constraint)).join(", ");
      }
      return `SET CONSTRAINTS ${constraintFragment} ${type.toString()}`;
    }
    if (constraints == null ? void 0 : constraints.length) {
      constraintFragment = constraints.map((constraint) => this.quoteIdentifier(constraint)).join(", ");
    }
    return `SET CONSTRAINTS ${constraintFragment} ${type.toString()}`;
  }
  showConstraintsQuery(_tableName, _options) {
    throw new Error(`showConstraintsQuery has not been implemented in ${this.dialect.name}.`);
  }
  showIndexesQuery(_tableName) {
    throw new Error(`showIndexesQuery has not been implemented in ${this.dialect.name}.`);
  }
  removeIndexQuery(_tableName, _indexNameOrAttributes, _options) {
    throw new Error(`removeIndexQuery has not been implemented in ${this.dialect.name}.`);
  }
  /**
   * Generates an SQL query that returns all foreign keys of a table or the foreign key constraint of a given column.
   *
   * @deprecated Use {@link showConstraintsQuery} instead.
   * @param _tableName The table or associated model.
   * @param _columnName The name of the column. Not supported by SQLite.
   * @returns The generated SQL query.
   */
  getForeignKeyQuery(_tableName, _columnName) {
    throw new Error(`getForeignKeyQuery has been deprecated. Use showConstraintsQuery instead.`);
  }
  /**
   * Generates an SQL query that drops a foreign key constraint.
   *
   * @deprecated Use {@link removeConstraintQuery} instead.
   * @param _tableName The table or associated model.
   * @param _foreignKey The name of the foreign key constraint.
   */
  dropForeignKeyQuery(_tableName, _foreignKey) {
    throw new Error(`dropForeignKeyQuery has been deprecated. Use removeConstraintQuery instead.`);
  }
  // TODO: rename to "normalizeTable" & move to sequelize class
  extractTableDetails(tableNameOrModel, options) {
    const tableNameObject = (0, import_model_utils.isModelStatic)(tableNameOrModel) ? tableNameOrModel.getTableName() : (0, import_check.isString)(tableNameOrModel) ? { tableName: tableNameOrModel } : tableNameOrModel;
    if (!(0, import_check.isPlainObject)(tableNameObject)) {
      throw new Error(`Invalid input received, got ${import_node_util.default.inspect(tableNameOrModel)}, expected a Model Class, a TableNameWithSchema object, or a table name string`);
    }
    delete tableNameObject.toString;
    return {
      ...tableNameObject,
      schema: (options == null ? void 0 : options.schema) || tableNameObject.schema || this.options.schema || this.dialect.getDefaultSchema(),
      delimiter: (options == null ? void 0 : options.delimiter) || tableNameObject.delimiter || "."
    };
  }
  /**
   * Quote table name with optional alias and schema attribution
   *
   * @param param table string or object
   * @param options options
   */
  quoteTable(param, options) {
    const QUOTE_TABLE_SUPPORTED_OPTIONS = /* @__PURE__ */ new Set();
    if (this.dialect.supports.indexHints) {
      QUOTE_TABLE_SUPPORTED_OPTIONS.add("indexHints");
    }
    if (this.dialect.supports.tableHints) {
      QUOTE_TABLE_SUPPORTED_OPTIONS.add("tableHints");
    }
    (0, import_check.rejectInvalidOptions)("quoteTable", this.dialect.name, QUOTE_TABLE_SUPPORTABLE_OPTIONS, QUOTE_TABLE_SUPPORTED_OPTIONS, { ...options });
    if ((0, import_model_utils.isModelStatic)(param)) {
      param = param.getTableName();
    }
    const tableName = this.extractTableDetails(param);
    if ((0, import_isObject.default)(param) && ("as" in param || "name" in param)) {
      throw new Error('parameters "as" and "name" are not allowed in the first parameter of quoteTable, pass them as the second parameter.');
    }
    let sql = "";
    if (this.dialect.supports.schemas) {
      if (tableName.schema && tableName.schema !== this.dialect.getDefaultSchema()) {
        sql += `${this.quoteIdentifier(tableName.schema)}.`;
      }
      sql += this.quoteIdentifier(tableName.tableName);
    } else {
      const fakeSchemaPrefix = tableName.schema && tableName.schema !== this.dialect.getDefaultSchema() ? tableName.schema + (tableName.delimiter || ".") : "";
      sql += this.quoteIdentifier(fakeSchemaPrefix + tableName.tableName);
    }
    if (options == null ? void 0 : options.alias) {
      sql += ` AS ${this.quoteIdentifier(options.alias === true ? tableName.tableName : options.alias)}`;
    }
    if (options == null ? void 0 : options.indexHints) {
      for (const hint of options.indexHints) {
        if (import_index_hints.IndexHints[hint.type]) {
          sql += ` ${import_index_hints.IndexHints[hint.type]} INDEX (${hint.values.map((indexName) => this.quoteIdentifier(indexName)).join(",")})`;
        } else {
          throw new Error(`The index hint type "${hint.type}" is invalid or not supported by dialect "${this.dialect.name}".`);
        }
      }
    }
    if (options == null ? void 0 : options.tableHints) {
      const hints = [];
      for (const hint of options.tableHints) {
        if (import_table_hints.TableHints[hint]) {
          hints.push(import_table_hints.TableHints[hint]);
        } else {
          throw new Error(`The table hint "${hint}" is invalid or not supported by dialect "${this.dialect.name}".`);
        }
      }
      if (hints.length) {
        sql += ` WITH (${hints.join(", ")})`;
      }
    }
    return sql;
  }
  /**
   * Adds quotes to identifier
   *
   * @param identifier
   * @param _force
   */
  // TODO: memoize last result
  quoteIdentifier(identifier, _force) {
    return (0, import_dialect.quoteIdentifier)(identifier, this.dialect.TICK_CHAR_LEFT, this.dialect.TICK_CHAR_RIGHT);
  }
  isSameTable(tableA, tableB) {
    if (tableA === tableB) {
      return true;
    }
    tableA = this.extractTableDetails(tableA);
    tableB = this.extractTableDetails(tableB);
    return tableA.tableName === tableB.tableName && tableA.schema === tableB.schema;
  }
  whereQuery(where, options) {
    const query = this.whereItemsQuery(where, options);
    if (query && query.length > 0) {
      return `WHERE ${query}`;
    }
    return "";
  }
  whereItemsQuery(where, options) {
    return this.whereSqlBuilder.formatWhereOptions(where, options);
  }
  formatSqlExpression(piece, options) {
    if (piece instanceof import_literal.Literal) {
      return this.formatLiteral(piece, options);
    }
    if (piece instanceof import_fn.Fn) {
      return this.formatFn(piece, options);
    }
    if (piece instanceof import_list.List) {
      return this.escapeList(piece.values, options);
    }
    if (piece instanceof import_value.Value) {
      return this.escape(piece.value, options);
    }
    if (piece instanceof import_identifier.Identifier) {
      return this.quoteIdentifier(piece.value);
    }
    if (piece instanceof import_cast.Cast) {
      return this.formatCast(piece, options);
    }
    if (piece instanceof import_col.Col) {
      return this.formatCol(piece, options);
    }
    if (piece instanceof import_attribute.Attribute) {
      return this.formatAttribute(piece, options);
    }
    if (piece instanceof import_where.Where) {
      if (piece.where instanceof import_where_sql_builder.PojoWhere) {
        return this.whereSqlBuilder.formatPojoWhere(piece.where, options);
      }
      return this.whereSqlBuilder.formatWhereOptions(piece.where, options);
    }
    if (piece instanceof import_json_path.JsonPath) {
      return this.formatJsonPath(piece, options);
    }
    if (piece instanceof import_association_path.AssociationPath) {
      return this.formatAssociationPath(piece);
    }
    if (piece instanceof import_dialect_aware_fn.DialectAwareFn) {
      return this.formatDialectAwareFn(piece, options);
    }
    throw new Error(`Unknown sequelize method ${piece.constructor.name}`);
  }
  formatAssociationPath(associationPath) {
    return `${this.quoteIdentifier(associationPath.associationPath.join("->"))}.${this.quoteIdentifier(associationPath.attributeName)}`;
  }
  formatJsonPath(jsonPathVal, options) {
    const value = this.escape(jsonPathVal.expression, options);
    if (jsonPathVal.path.length === 0) {
      return value;
    }
    return this.jsonPathExtractionQuery(value, jsonPathVal.path, false);
  }
  /**
   * The goal of this method is to execute the equivalent of json_unquote for the current dialect.
   *
   * @param _arg
   * @param _options
   */
  formatUnquoteJson(_arg, _options) {
    if (!this.dialect.supports.jsonOperations) {
      throw new Error(`Unquoting JSON is not supported by ${this.dialect.name} dialect.`);
    }
    throw new Error(`formatUnquoteJson has not been implemented in ${this.dialect.name}.`);
  }
  /**
   * @param _sqlExpression ⚠️ This is not an identifier, it's a raw SQL expression. It will be inlined in the query.
   * @param _path The JSON path, where each item is one level of the path
   * @param _unquote Whether the result should be unquoted (depending on dialect: ->> and #>> operators, json_unquote function). Defaults to `false`.
   */
  jsonPathExtractionQuery(_sqlExpression, _path, _unquote) {
    if (!this.dialect.supports.jsonOperations) {
      throw new Error(`JSON Paths are not supported in ${this.dialect.name}.`);
    }
    throw new Error(`jsonPathExtractionQuery has not been implemented in ${this.dialect.name}.`);
  }
  formatLiteral(piece, options) {
    const sql = piece.val.map((part) => {
      if (part instanceof import_base_sql_expression.BaseSqlExpression) {
        return this.formatSqlExpression(part, options);
      }
      return part;
    }).join("");
    if (options == null ? void 0 : options.replacements) {
      return (0, import_sql.injectReplacements)(sql, this.dialect, options.replacements, {
        onPositionalReplacement: () => {
          throw new TypeError(`The following literal includes positional replacements (?).
Only named replacements (:name) are allowed in literal() because we cannot guarantee the order in which they will be evaluated:
\u279C literal(${JSON.stringify(sql)})`);
        }
      });
    }
    return sql;
  }
  formatAttribute(piece, options) {
    const model = options == null ? void 0 : options.model;
    const columnName = (model == null ? void 0 : model.modelDefinition.getColumnNameLoose(piece.attributeName)) ?? piece.attributeName;
    if (options == null ? void 0 : options.mainAlias) {
      return `${this.quoteIdentifier(options.mainAlias)}.${this.quoteIdentifier(columnName)}`;
    }
    return this.quoteIdentifier(columnName);
  }
  formatFn(piece, options) {
    const argEscapeOptions = piece.args.length > 0 && (options == null ? void 0 : options.type) ? { ...options, type: void 0 } : options;
    const args = piece.args.map((arg) => {
      return this.escape(arg, argEscapeOptions);
    }).join(", ");
    return `${piece.fn}(${args})`;
  }
  formatDialectAwareFn(piece, options) {
    const argEscapeOptions = piece.args.length > 0 && (options == null ? void 0 : options.type) ? { ...options, type: void 0 } : options;
    return piece.apply(this.dialect, argEscapeOptions);
  }
  formatCast(cast, options) {
    const type = this.sequelize.normalizeDataType(cast.type);
    const castSql = (0, import_where_sql_builder.wrapAmbiguousWhere)(cast.expression, this.escape(cast.expression, { ...options, type }));
    const targetSql = (0, import_data_types_utils.attributeTypeToSql)(type).toUpperCase();
    return `CAST(${castSql} AS ${targetSql})`;
  }
  formatCol(piece, options) {
    if (piece.identifiers.length === 1 && piece.identifiers[0].startsWith("*")) {
      return "*";
    }
    const identifiers = piece.identifiers.length === 1 ? piece.identifiers[0] : piece.identifiers;
    return this.quote(identifiers, options == null ? void 0 : options.model, void 0, options);
  }
  /**
   * Escapes a value (e.g. a string, number or date) as an SQL value (as opposed to an identifier).
   *
   * @param value The value to escape
   * @param options The options to use when escaping the value
   */
  escape(value, options = import_object.EMPTY_OBJECT) {
    if ((0, import_check.isDictionary)(value) && import_operators.Op.col in value) {
      (0, import_deprecations.noOpCol)();
      value = new import_col.Col(value[import_operators.Op.col]);
    }
    if (value instanceof import_base_sql_expression.BaseSqlExpression) {
      return this.formatSqlExpression(value, options);
    }
    if (value === void 0) {
      throw new TypeError('"undefined" cannot be escaped');
    }
    let { type } = options;
    if (type != null) {
      type = this.sequelize.normalizeDataType(type);
    }
    if (value === null && (!(type instanceof import_data_types.AbstractDataType) || !type.acceptsNull())) {
      if (options.bindParam) {
        return options.bindParam(null);
      }
      return "NULL";
    }
    if (type == null || typeof type === "string") {
      type = (0, import_sql_string.bestGuessDataTypeOfVal)(value, this.dialect);
    } else {
      type = this.sequelize.normalizeDataType(type);
    }
    this.validate(value, type);
    if (options.bindParam) {
      return type.getBindParamSql(value, options);
    }
    return type.escape(value);
  }
  /**
   * Validate a value against a field specification
   *
   * @param value The value to validate
   * @param type The DataType to validate against
   */
  validate(value, type) {
    if (this.sequelize.options.noTypeValidation || (0, import_check.isNullish)(value)) {
      return;
    }
    if ((0, import_check.isString)(type)) {
      return;
    }
    type = this.sequelize.normalizeDataType(type);
    const error = (0, import_data_types_utils.validateDataType)(value, type);
    if (error) {
      throw error;
    }
  }
  /**
   * Escapes an array of values (e.g. strings, numbers or dates) as an SQL List of values.
   *
   * @param values The list of values to escape
   * @param options
   *
   * @example
   * ```ts
   * const values = [1, 2, 3];
   * queryGenerator.escapeList([1, 2, 3]); // '(1, 2, 3)'
   */
  escapeList(values, options) {
    return `(${values.map((value) => this.escape(value, options)).join(", ")})`;
  }
  getToggleForeignKeyChecksQuery(_enable) {
    throw new Error(`${this.dialect.name} does not support toggling foreign key checks`);
  }
  versionQuery() {
    throw new Error(`${this.dialect.name} did not implement versionQuery`);
  }
  tableExistsQuery(tableName) {
    const table = this.extractTableDetails(tableName);
    return `SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE' AND TABLE_NAME = ${this.escape(table.tableName)} AND TABLE_SCHEMA = ${this.escape(table.schema)}`;
  }
}
//# sourceMappingURL=query-generator-typescript.js.map
