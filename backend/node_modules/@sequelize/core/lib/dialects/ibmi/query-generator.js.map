{
  "version": 3,
  "sources": ["../../../src/dialects/ibmi/query-generator.js"],
  "sourcesContent": ["'use strict';\n\nimport { BaseSqlExpression } from '../../expression-builders/base-sql-expression.js';\nimport { conformIndex } from '../../model-internals';\nimport { rejectInvalidOptions } from '../../utils/check';\nimport { nameIndex, removeTrailingSemicolon } from '../../utils/string';\nimport { defaultValueSchemable } from '../../utils/query-builder-utils';\nimport { attributeTypeToSql, normalizeDataType } from '../abstract/data-types-utils';\nimport {\n  ADD_COLUMN_QUERY_SUPPORTABLE_OPTIONS,\n  CREATE_SCHEMA_QUERY_SUPPORTABLE_OPTIONS,\n  CREATE_TABLE_QUERY_SUPPORTABLE_OPTIONS,\n  DROP_TABLE_QUERY_SUPPORTABLE_OPTIONS,\n  REMOVE_COLUMN_QUERY_SUPPORTABLE_OPTIONS,\n} from '../abstract/query-generator';\n\nimport each from 'lodash/each';\nimport isPlainObject from 'lodash/isPlainObject';\n\nconst util = require('node:util');\nconst { IBMiQueryGeneratorTypeScript } = require('./query-generator-typescript');\nconst DataTypes = require('../../data-types');\n\nconst typeWithoutDefault = new Set(['BLOB']);\n\nconst CREATE_SCHEMA_QUERY_SUPPORTED_OPTIONS = new Set();\nconst CREATE_TABLE_QUERY_SUPPORTED_OPTIONS = new Set(['uniqueKeys']);\nconst DROP_TABLE_QUERY_SUPPORTED_OPTIONS = new Set();\nconst ADD_COLUMN_QUERY_SUPPORTED_OPTIONS = new Set();\nconst REMOVE_COLUMN_QUERY_SUPPORTED_OPTIONS = new Set();\n\nexport class IBMiQueryGenerator extends IBMiQueryGeneratorTypeScript {\n  // Schema queries\n  createSchemaQuery(schema, options) {\n    if (options) {\n      rejectInvalidOptions(\n        'createSchemaQuery',\n        this.dialect.name,\n        CREATE_SCHEMA_QUERY_SUPPORTABLE_OPTIONS,\n        CREATE_SCHEMA_QUERY_SUPPORTED_OPTIONS,\n        options,\n      );\n    }\n\n    return `CREATE SCHEMA \"${schema}\"`;\n  }\n\n  dropSchemaQuery(schema) {\n    return `BEGIN IF EXISTS (SELECT * FROM SYSIBM.SQLSCHEMAS WHERE TABLE_SCHEM = ${schema ? `'${schema}'` : 'CURRENT SCHEMA'}) THEN SET TRANSACTION ISOLATION LEVEL NO COMMIT; DROP SCHEMA \"${schema ? `${schema}` : 'CURRENT SCHEMA'}\"; COMMIT; END IF; END`;\n  }\n\n  // Table queries\n  createTableQuery(tableName, attributes, options) {\n    if (options) {\n      rejectInvalidOptions(\n        'createTableQuery',\n        this.dialect.name,\n        CREATE_TABLE_QUERY_SUPPORTABLE_OPTIONS,\n        CREATE_TABLE_QUERY_SUPPORTED_OPTIONS,\n        options,\n      );\n    }\n\n    const primaryKeys = [];\n    const foreignKeys = Object.create(null);\n    const attrStr = [];\n\n    for (const attr in attributes) {\n      if (!Object.hasOwn(attributes, attr)) {\n        continue;\n      }\n\n      const dataType = attributes[attr];\n\n      if (dataType.includes('PRIMARY KEY')) {\n        primaryKeys.push(attr);\n        attrStr.push(`${this.quoteIdentifier(attr)} ${dataType.replace('PRIMARY KEY', '')}`);\n      } else {\n        attrStr.push(`${this.quoteIdentifier(attr)} ${dataType}`);\n      }\n    }\n\n    let attributesClause = attrStr.join(', ');\n    const pkString = primaryKeys.map(pk => this.quoteIdentifier(pk)).join(', ');\n\n    if (options?.uniqueKeys) {\n      // only need to sort primary keys once, don't do it in place\n      const sortedPrimaryKeys = [...primaryKeys];\n      sortedPrimaryKeys.sort();\n\n      each(options.uniqueKeys, (columns, indexName) => {\n        // sort the columns for each unique key, so they can be easily compared\n        // with the sorted primary key fields\n        const sortedColumnFields = [...columns.fields];\n        sortedColumnFields.sort();\n        // if primary keys === unique keys, then skip adding new constraint\n        const uniqueIsPrimary\n          = sortedColumnFields.length === primaryKeys.length\n          && sortedColumnFields.every((value, index) => {\n            return value === sortedPrimaryKeys[index];\n          });\n        if (uniqueIsPrimary) {\n          return true;\n        }\n\n        if (typeof indexName !== 'string') {\n          indexName = `uniq_${tableName}_${columns.fields.join('_')}`;\n        }\n\n        attributesClause += `, CONSTRAINT ${this.quoteIdentifier(indexName)} UNIQUE (${columns.fields.map(field => this.quoteIdentifier(field)).join(', ')})`;\n      });\n    }\n\n    if (pkString.length > 0) {\n      attributesClause += `, PRIMARY KEY (${pkString})`;\n    }\n\n    for (const fkey in foreignKeys) {\n      if (Object.hasOwn(foreignKeys, fkey)) {\n        attributesClause += `, FOREIGN KEY (${this.quoteIdentifier(fkey)}) ${foreignKeys[fkey]}`;\n      }\n    }\n\n    const quotedTable = this.quoteTable(tableName);\n\n    return `BEGIN\n    DECLARE CONTINUE HANDLER FOR SQLSTATE VALUE '42710'\n      BEGIN END;\n      CREATE TABLE ${quotedTable} (${attributesClause});\n      END`;\n  }\n\n  addColumnQuery(table, key, dataType, options) {\n    if (options) {\n      rejectInvalidOptions(\n        'addColumnQuery',\n        this.dialect.name,\n        ADD_COLUMN_QUERY_SUPPORTABLE_OPTIONS,\n        ADD_COLUMN_QUERY_SUPPORTED_OPTIONS,\n        options,\n      );\n    }\n\n    dataType = {\n      ...dataType,\n      // TODO: attributeToSQL SHOULD be using attributes in addColumnQuery\n      //       but instead we need to pass the key along as the field here\n      field: key,\n      type: normalizeDataType(dataType.type, this.dialect),\n    };\n\n    const definition = this.attributeToSQL(dataType, {\n      context: 'addColumn',\n      tableName: table,\n      foreignKey: key,\n    });\n\n    return `ALTER TABLE ${this.quoteTable(table)} ADD ${this.quoteIdentifier(key)} ${definition}`;\n  }\n\n  changeColumnQuery(tableName, attributes) {\n    const attrString = [];\n    const constraintString = [];\n\n    for (const attributeName in attributes) {\n      let definition = attributes[attributeName];\n      if (definition.includes('REFERENCES')) {\n        const attrName = this.quoteIdentifier(attributeName);\n        definition = definition.replace(/.+?(?=REFERENCES)/, '');\n        const foreignKey = this.quoteIdentifier(`${attributeName}`);\n        constraintString.push(`${foreignKey} FOREIGN KEY (${attrName}) ${definition}`);\n      } else {\n        attrString.push(`\"${attributeName}\" SET DATA TYPE ${definition}`);\n      }\n    }\n\n    let finalQuery = '';\n    if (attrString.length) {\n      finalQuery += `ALTER COLUMN ${attrString.join(', ')}`;\n      finalQuery += constraintString.length ? ' ' : '';\n    }\n\n    if (constraintString.length) {\n      finalQuery += `ADD CONSTRAINT ${constraintString.join(', ')}`;\n    }\n\n    return `ALTER TABLE ${this.quoteTable(tableName)} ${finalQuery}`;\n  }\n\n  renameTableQuery(before, after) {\n    return `RENAME TABLE ${this.quoteTable(before)} TO ${this.quoteTable(after)}`;\n  }\n\n  renameColumnQuery(tableName, attrBefore, attributes) {\n    const attrString = [];\n\n    for (const attrName in attributes) {\n      const definition = attributes[attrName];\n      attrString.push(`\\`${attrBefore}\\` \\`${attrName}\\` ${definition}`);\n    }\n\n    return `ALTER TABLE ${this.quoteTable(tableName)} RENAME COLUMN ${attrString.join(', ')};`;\n  }\n\n  /*\n    Returns an add index query.\n    Parameters:\n      - tableName -> Name of an existing table, possibly with schema.\n      - options:\n        - type: UNIQUE|FULLTEXT|SPATIAL\n        - name: The name of the index. Default is <table>_<attr1>_<attr2>\n        - fields: An array of attributes as string or as hash.\n                  If the attribute is a hash, it must have the following content:\n                  - name: The name of the attribute/column\n                  - length: An integer. Optional\n                  - order: 'ASC' or 'DESC'. Optional\n        - parser\n        - using\n        - operator\n        - concurrently: Pass CONCURRENT so other operations run while the index is created\n      - rawTablename, the name of the table, without schema. Used to create the name of the index\n   @private\n  */\n  addIndexQuery(tableName, _attributes, _options, rawTablename) {\n    let options = _options || Object.create(null);\n\n    if (!Array.isArray(_attributes)) {\n      options = _attributes;\n    } else {\n      options.fields = _attributes;\n    }\n\n    options.prefix = options.prefix || rawTablename || tableName;\n    if (options.prefix && typeof options.prefix === 'string') {\n      options.prefix = options.prefix.replaceAll('.', '_');\n    }\n\n    const fieldsSql = options.fields.map(field => {\n      if (typeof field === 'string') {\n        return this.quoteIdentifier(field);\n      }\n\n      if (field instanceof BaseSqlExpression) {\n        return this.formatSqlExpression(field);\n      }\n\n      let result = '';\n\n      if (field.attribute) {\n        field.name = field.attribute;\n      }\n\n      if (!field.name) {\n        throw new Error(`The following index field has no name: ${util.inspect(field)}`);\n      }\n\n      result += this.quoteIdentifier(field.name);\n\n      if (this.dialect.supports.index.length && field.length) {\n        result += `(${field.length})`;\n      }\n\n      if (field.order) {\n        result += ` ${field.order}`;\n      }\n\n      return result;\n    });\n\n    if (options.include) {\n      throw new Error(`The include attribute for indexes is not supported by ${this.dialect.name} dialect`);\n    }\n\n    if (!options.name) {\n      // Mostly for cases where addIndex is called directly by the user without an options object (for example in migrations)\n      // All calls that go through sequelize should already have a name\n      options = nameIndex(options, options.prefix);\n    }\n\n    options = conformIndex(options);\n\n    if (!this.dialect.supports.index.type) {\n      delete options.type;\n    }\n\n    if (options.where) {\n      options.where = this.whereQuery(options.where);\n    }\n\n    tableName = this.quoteTable(tableName);\n\n    let schema;\n    // TODO: drop this option in favor of passing the schema through tableName\n    if (typeof options.schema === 'string') {\n      schema = this.quoteIdentifiers(options.schema);\n    }\n\n    // Although the function is 'addIndex', and the values are passed through\n    // the 'indexes' key of a table, Db2 for i doesn't allow REFERENCES to\n    // work against a UNIQUE INDEX, only a UNIQUE constraint.\n    if (options.unique) {\n      return `BEGIN\n      DECLARE CONTINUE HANDLER FOR SQLSTATE VALUE '42891'\n        BEGIN END;\n        ALTER TABLE ${tableName} ADD CONSTRAINT ${this.quoteIdentifiers(options.name)} UNIQUE (${fieldsSql.join(', ')}${options.operator ? ` ${options.operator}` : ''})${options.where ? ` ${options.where}` : ''};\n      END`;\n    }\n\n    return `CREATE${options.unique ? ' UNIQUE' : ''} INDEX ${schema ? ` ${schema}.` : ''}${this.quoteIdentifiers(options.name)} ON ${tableName} (${fieldsSql.join(', ')}${options.operator ? ` ${options.operator}` : ''})${options.where ? ` ${options.where}` : ''}`;\n  }\n\n  updateQuery(tableName, attrValueHash, where, options, columnDefinitions) {\n    const out = super.updateQuery(tableName, attrValueHash, where, options, columnDefinitions);\n\n    out.query = removeTrailingSemicolon(out.query);\n\n    return out;\n  }\n\n  arithmeticQuery(operator, tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options) {\n    return removeTrailingSemicolon(super.arithmeticQuery(operator, tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options));\n  }\n\n  upsertQuery(tableName, insertValues, updateValues, where, model, options) {\n    const aliasTable = `temp_${this.quoteTable(tableName)}`;\n\n    let query = `MERGE INTO ${this.quoteTable(tableName)} `;\n\n    const usingClause = `USING (\n      SELECT * FROM (${this.quoteTable(tableName)}\n      VALUES(42)\n      ) AS ${aliasTable}(\"id\") ON (${aliasTable}.\"id\" = ${this.quoteTable(tableName)}.\"id\")`;\n\n    query += usingClause;\n    query += ` WHEN MATCHED THEN ${this.updateQuery(tableName, tableName, where, options, updateValues)}\n    WHEN NOT MATCHED THEN ${this.insertQuery(tableName, insertValues, model, options).sql}`;\n\n    return query;\n  }\n\n  insertQuery(table, valueHash, modelAttributes, options) {\n    // remove the final semi-colon\n    const query = super.insertQuery(table, valueHash, modelAttributes, options);\n    if (query.query.at(-1) === ';') {\n      query.query = query.query.slice(0, -1);\n      query.query = `SELECT * FROM FINAL TABLE (${query.query})`;\n    }\n\n    return query;\n  }\n\n  selectQuery(tableName, options, model) {\n    // remove the final semi-colon\n    let query = super.selectQuery(tableName, options, model);\n    if (query.at(-1) === ';') {\n      query = query.slice(0, -1);\n    }\n\n    return query;\n  }\n\n  bulkInsertQuery(tableName, fieldValueHashes, options, fieldMappedAttributes) {\n    // remove the final semi-colon\n    let query = super.bulkInsertQuery(tableName, fieldValueHashes, options, fieldMappedAttributes);\n    if (query.at(-1) === ';') {\n      query = query.slice(0, -1);\n      query = `SELECT * FROM FINAL TABLE (${query})`;\n    }\n\n    return query;\n  }\n\n  truncateTableQuery(tableName) {\n    return `TRUNCATE TABLE ${this.quoteTable(tableName)} IMMEDIATE`;\n  }\n\n  deleteQuery(tableName, where, options = {}, model) {\n    let query = `DELETE FROM ${this.quoteTable(tableName)}`;\n\n    const whereSql = this.whereQuery(where, { ...options, model });\n    if (whereSql) {\n      query += ` ${whereSql}`;\n    }\n\n    if (options.offset || options.limit) {\n      query += this.addLimitAndOffset(options, model);\n    }\n\n    return query;\n  }\n\n  /**\n   * Returns an SQL fragment for adding result constraints.\n   *\n   * @param  {object} options An object with selectQuery options.\n   * @returns {string}         The generated sql query.\n   * @private\n   */\n  addLimitAndOffset(options) {\n    let fragment = '';\n\n    if (options.offset) {\n      fragment += ` OFFSET ${this.escape(options.offset, options)} ROWS`;\n    }\n\n    if (options.limit) {\n      fragment += ` FETCH NEXT ${this.escape(options.limit, options)} ROWS ONLY`;\n    }\n\n    return fragment;\n  }\n\n  // bindParam(bind) {\n  //   return value => {\n  //     bind.push(value);\n\n  //     return '?';\n  //   };\n  // }\n\n  attributeToSQL(attribute, options) {\n    if (!isPlainObject(attribute)) {\n      attribute = {\n        type: attribute,\n      };\n    }\n\n    const attributeString = attribute.type.toString({ escape: this.escape.bind(this), dialect: this.dialect });\n    let template = attributeString;\n\n    if (attribute.type instanceof DataTypes.ENUM) {\n      // enums are a special case\n      template = attribute.type.toSql({ dialect: this.dialect });\n      if (options && options.context) {\n        template += options.context === 'changeColumn' ? ' ADD' : '';\n      }\n\n      template += ` CHECK (${this.quoteIdentifier(attribute.field)} IN(${attribute.type.options.values.map(value => {\n        return this.escape(value);\n      }).join(', ')}))`;\n    } else {\n      template = attributeTypeToSql(attribute.type, { dialect: this.dialect });\n    }\n\n    if (attribute.allowNull === false) {\n      template += ' NOT NULL';\n    } else if (attribute.allowNull === true && (options && options.context === 'changeColumn')) {\n      template += ' DROP NOT NULL';\n    }\n\n    if (attribute.autoIncrement) {\n      template += ' GENERATED BY DEFAULT AS IDENTITY (START WITH 1, INCREMENT BY 1)';\n    }\n\n    // BLOB cannot have a default value\n    if (!typeWithoutDefault.has(attributeString)\n      && attribute.type._binary !== true\n      && defaultValueSchemable(attribute.defaultValue)) {\n      if (attribute.defaultValue === true) {\n        attribute.defaultValue = 1;\n      } else if (attribute.defaultValue === false) {\n        attribute.defaultValue = 0;\n      }\n\n      template += ` DEFAULT ${this.escape(attribute.defaultValue)}`;\n    }\n\n    if (attribute.unique === true && !attribute.primaryKey) {\n      template += ' UNIQUE';\n    }\n\n    if (attribute.primaryKey) {\n      template += ' PRIMARY KEY';\n    }\n\n    // Db2 for i comments are a mess\n    // if (attribute.comment) {\n    //   template += ` ${options.context === 'changeColumn' ? 'ADD ' : ''}COMMENT ${this.escape(attribute.comment)}`;\n    // }\n\n    if (attribute.first) {\n      template += ' FIRST';\n    }\n\n    if (attribute.after) {\n      template += ` AFTER ${this.quoteIdentifier(attribute.after)}`;\n    }\n\n    if (attribute.references) {\n\n      if (options && options.context === 'addColumn' && options.foreignKey) {\n        const attrName = this.quoteIdentifier(options.foreignKey);\n        const fkName = this.quoteIdentifier(`${options.tableName}_${attrName}_foreign_idx`);\n\n        template += ` ADD CONSTRAINT ${fkName} FOREIGN KEY (${attrName})`;\n      }\n\n      template += ` REFERENCES ${this.quoteTable(attribute.references.table)}`;\n\n      if (attribute.references.key) {\n        template += ` (${this.quoteIdentifier(attribute.references.key)})`;\n      } else {\n        template += ` (${this.quoteIdentifier('id')})`;\n      }\n\n      if (attribute.onDelete) {\n        template += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;\n      }\n\n      if (attribute.onUpdate && attribute.onUpdate.toUpperCase() !== 'CASCADE') {\n        template += ` ON UPDATE ${attribute.onUpdate.toUpperCase()}`;\n      }\n    }\n\n    return template;\n  }\n\n  attributesToSQL(attributes, options) {\n    const result = Object.create(null);\n\n    for (const key of Object.keys(attributes)) {\n      const attribute = {\n        ...attributes[key],\n        field: attributes[key].field || key,\n      };\n\n      result[attribute.field || key] = this.attributeToSQL(attribute, options);\n    }\n\n    return result;\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA,iCAAkC;AAClC,6BAA6B;AAC7B,mBAAqC;AACrC,oBAAmD;AACnD,iCAAsC;AACtC,8BAAsD;AACtD,6BAMO;AAEP,kBAAiB;AACjB,2BAA0B;AAE1B,MAAM,OAAO,QAAQ,WAAW;AAChC,MAAM,EAAE,6BAA6B,IAAI,QAAQ,8BAA8B;AAC/E,MAAM,YAAY,QAAQ,kBAAkB;AAE5C,MAAM,qBAAqB,oBAAI,IAAI,CAAC,MAAM,CAAC;AAE3C,MAAM,wCAAwC,oBAAI,IAAI;AACtD,MAAM,uCAAuC,oBAAI,IAAI,CAAC,YAAY,CAAC;AACnE,MAAM,qCAAqC,oBAAI,IAAI;AACnD,MAAM,qCAAqC,oBAAI,IAAI;AACnD,MAAM,wCAAwC,oBAAI,IAAI;AAE/C,MAAM,2BAA2B,6BAA6B;AAAA;AAAA,EAEnE,kBAAkB,QAAQ,SAAS;AACjC,QAAI,SAAS;AACX;AAAA,QACE;AAAA,QACA,KAAK,QAAQ;AAAA,QACb;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAEA,WAAO,kBAAkB;AAAA,EAC3B;AAAA,EAEA,gBAAgB,QAAQ;AACtB,WAAO,wEAAwE,SAAS,IAAI,YAAY,kFAAkF,SAAS,GAAG,WAAW;AAAA,EACnN;AAAA;AAAA,EAGA,iBAAiB,WAAW,YAAY,SAAS;AAC/C,QAAI,SAAS;AACX;AAAA,QACE;AAAA,QACA,KAAK,QAAQ;AAAA,QACb;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAEA,UAAM,cAAc,CAAC;AACrB,UAAM,cAAc,uBAAO,OAAO,IAAI;AACtC,UAAM,UAAU,CAAC;AAEjB,eAAW,QAAQ,YAAY;AAC7B,UAAI,CAAC,OAAO,OAAO,YAAY,IAAI,GAAG;AACpC;AAAA,MACF;AAEA,YAAM,WAAW,WAAW,IAAI;AAEhC,UAAI,SAAS,SAAS,aAAa,GAAG;AACpC,oBAAY,KAAK,IAAI;AACrB,gBAAQ,KAAK,GAAG,KAAK,gBAAgB,IAAI,KAAK,SAAS,QAAQ,eAAe,EAAE,GAAG;AAAA,MACrF,OAAO;AACL,gBAAQ,KAAK,GAAG,KAAK,gBAAgB,IAAI,KAAK,UAAU;AAAA,MAC1D;AAAA,IACF;AAEA,QAAI,mBAAmB,QAAQ,KAAK,IAAI;AACxC,UAAM,WAAW,YAAY,IAAI,QAAM,KAAK,gBAAgB,EAAE,CAAC,EAAE,KAAK,IAAI;AAE1E,QAAI,mCAAS,YAAY;AAEvB,YAAM,oBAAoB,CAAC,GAAG,WAAW;AACzC,wBAAkB,KAAK;AAEvB,sBAAAA,SAAK,QAAQ,YAAY,CAAC,SAAS,cAAc;AAG/C,cAAM,qBAAqB,CAAC,GAAG,QAAQ,MAAM;AAC7C,2BAAmB,KAAK;AAExB,cAAM,kBACF,mBAAmB,WAAW,YAAY,UACzC,mBAAmB,MAAM,CAAC,OAAO,UAAU;AAC5C,iBAAO,UAAU,kBAAkB,KAAK;AAAA,QAC1C,CAAC;AACH,YAAI,iBAAiB;AACnB,iBAAO;AAAA,QACT;AAEA,YAAI,OAAO,cAAc,UAAU;AACjC,sBAAY,QAAQ,aAAa,QAAQ,OAAO,KAAK,GAAG;AAAA,QAC1D;AAEA,4BAAoB,gBAAgB,KAAK,gBAAgB,SAAS,aAAa,QAAQ,OAAO,IAAI,WAAS,KAAK,gBAAgB,KAAK,CAAC,EAAE,KAAK,IAAI;AAAA,MACnJ,CAAC;AAAA,IACH;AAEA,QAAI,SAAS,SAAS,GAAG;AACvB,0BAAoB,kBAAkB;AAAA,IACxC;AAEA,eAAW,QAAQ,aAAa;AAC9B,UAAI,OAAO,OAAO,aAAa,IAAI,GAAG;AACpC,4BAAoB,kBAAkB,KAAK,gBAAgB,IAAI,MAAM,YAAY,IAAI;AAAA,MACvF;AAAA,IACF;AAEA,UAAM,cAAc,KAAK,WAAW,SAAS;AAE7C,WAAO;AAAA;AAAA;AAAA,qBAGU,gBAAgB;AAAA;AAAA,EAEnC;AAAA,EAEA,eAAe,OAAO,KAAK,UAAU,SAAS;AAC5C,QAAI,SAAS;AACX;AAAA,QACE;AAAA,QACA,KAAK,QAAQ;AAAA,QACb;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAEA,eAAW;AAAA,MACT,GAAG;AAAA;AAAA;AAAA,MAGH,OAAO;AAAA,MACP,UAAM,2CAAkB,SAAS,MAAM,KAAK,OAAO;AAAA,IACrD;AAEA,UAAM,aAAa,KAAK,eAAe,UAAU;AAAA,MAC/C,SAAS;AAAA,MACT,WAAW;AAAA,MACX,YAAY;AAAA,IACd,CAAC;AAED,WAAO,eAAe,KAAK,WAAW,KAAK,SAAS,KAAK,gBAAgB,GAAG,KAAK;AAAA,EACnF;AAAA,EAEA,kBAAkB,WAAW,YAAY;AACvC,UAAM,aAAa,CAAC;AACpB,UAAM,mBAAmB,CAAC;AAE1B,eAAW,iBAAiB,YAAY;AACtC,UAAI,aAAa,WAAW,aAAa;AACzC,UAAI,WAAW,SAAS,YAAY,GAAG;AACrC,cAAM,WAAW,KAAK,gBAAgB,aAAa;AACnD,qBAAa,WAAW,QAAQ,qBAAqB,EAAE;AACvD,cAAM,aAAa,KAAK,gBAAgB,GAAG,eAAe;AAC1D,yBAAiB,KAAK,GAAG,2BAA2B,aAAa,YAAY;AAAA,MAC/E,OAAO;AACL,mBAAW,KAAK,IAAI,gCAAgC,YAAY;AAAA,MAClE;AAAA,IACF;AAEA,QAAI,aAAa;AACjB,QAAI,WAAW,QAAQ;AACrB,oBAAc,gBAAgB,WAAW,KAAK,IAAI;AAClD,oBAAc,iBAAiB,SAAS,MAAM;AAAA,IAChD;AAEA,QAAI,iBAAiB,QAAQ;AAC3B,oBAAc,kBAAkB,iBAAiB,KAAK,IAAI;AAAA,IAC5D;AAEA,WAAO,eAAe,KAAK,WAAW,SAAS,KAAK;AAAA,EACtD;AAAA,EAEA,iBAAiB,QAAQ,OAAO;AAC9B,WAAO,gBAAgB,KAAK,WAAW,MAAM,QAAQ,KAAK,WAAW,KAAK;AAAA,EAC5E;AAAA,EAEA,kBAAkB,WAAW,YAAY,YAAY;AACnD,UAAM,aAAa,CAAC;AAEpB,eAAW,YAAY,YAAY;AACjC,YAAM,aAAa,WAAW,QAAQ;AACtC,iBAAW,KAAK,KAAK,kBAAkB,cAAc,YAAY;AAAA,IACnE;AAEA,WAAO,eAAe,KAAK,WAAW,SAAS,mBAAmB,WAAW,KAAK,IAAI;AAAA,EACxF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAqBA,cAAc,WAAW,aAAa,UAAU,cAAc;AAC5D,QAAI,UAAU,YAAY,uBAAO,OAAO,IAAI;AAE5C,QAAI,CAAC,MAAM,QAAQ,WAAW,GAAG;AAC/B,gBAAU;AAAA,IACZ,OAAO;AACL,cAAQ,SAAS;AAAA,IACnB;AAEA,YAAQ,SAAS,QAAQ,UAAU,gBAAgB;AACnD,QAAI,QAAQ,UAAU,OAAO,QAAQ,WAAW,UAAU;AACxD,cAAQ,SAAS,QAAQ,OAAO,WAAW,KAAK,GAAG;AAAA,IACrD;AAEA,UAAM,YAAY,QAAQ,OAAO,IAAI,WAAS;AAC5C,UAAI,OAAO,UAAU,UAAU;AAC7B,eAAO,KAAK,gBAAgB,KAAK;AAAA,MACnC;AAEA,UAAI,iBAAiB,8CAAmB;AACtC,eAAO,KAAK,oBAAoB,KAAK;AAAA,MACvC;AAEA,UAAI,SAAS;AAEb,UAAI,MAAM,WAAW;AACnB,cAAM,OAAO,MAAM;AAAA,MACrB;AAEA,UAAI,CAAC,MAAM,MAAM;AACf,cAAM,IAAI,MAAM,0CAA0C,KAAK,QAAQ,KAAK,GAAG;AAAA,MACjF;AAEA,gBAAU,KAAK,gBAAgB,MAAM,IAAI;AAEzC,UAAI,KAAK,QAAQ,SAAS,MAAM,UAAU,MAAM,QAAQ;AACtD,kBAAU,IAAI,MAAM;AAAA,MACtB;AAEA,UAAI,MAAM,OAAO;AACf,kBAAU,IAAI,MAAM;AAAA,MACtB;AAEA,aAAO;AAAA,IACT,CAAC;AAED,QAAI,QAAQ,SAAS;AACnB,YAAM,IAAI,MAAM,yDAAyD,KAAK,QAAQ,cAAc;AAAA,IACtG;AAEA,QAAI,CAAC,QAAQ,MAAM;AAGjB,oBAAU,yBAAU,SAAS,QAAQ,MAAM;AAAA,IAC7C;AAEA,kBAAU,qCAAa,OAAO;AAE9B,QAAI,CAAC,KAAK,QAAQ,SAAS,MAAM,MAAM;AACrC,aAAO,QAAQ;AAAA,IACjB;AAEA,QAAI,QAAQ,OAAO;AACjB,cAAQ,QAAQ,KAAK,WAAW,QAAQ,KAAK;AAAA,IAC/C;AAEA,gBAAY,KAAK,WAAW,SAAS;AAErC,QAAI;AAEJ,QAAI,OAAO,QAAQ,WAAW,UAAU;AACtC,eAAS,KAAK,iBAAiB,QAAQ,MAAM;AAAA,IAC/C;AAKA,QAAI,QAAQ,QAAQ;AAClB,aAAO;AAAA;AAAA;AAAA,sBAGS,4BAA4B,KAAK,iBAAiB,QAAQ,IAAI,aAAa,UAAU,KAAK,IAAI,IAAI,QAAQ,WAAW,IAAI,QAAQ,aAAa,MAAM,QAAQ,QAAQ,IAAI,QAAQ,UAAU;AAAA;AAAA,IAE5M;AAEA,WAAO,SAAS,QAAQ,SAAS,YAAY,YAAY,SAAS,IAAI,YAAY,KAAK,KAAK,iBAAiB,QAAQ,IAAI,QAAQ,cAAc,UAAU,KAAK,IAAI,IAAI,QAAQ,WAAW,IAAI,QAAQ,aAAa,MAAM,QAAQ,QAAQ,IAAI,QAAQ,UAAU;AAAA,EAChQ;AAAA,EAEA,YAAY,WAAW,eAAe,OAAO,SAAS,mBAAmB;AACvE,UAAM,MAAM,MAAM,YAAY,WAAW,eAAe,OAAO,SAAS,iBAAiB;AAEzF,QAAI,YAAQ,uCAAwB,IAAI,KAAK;AAE7C,WAAO;AAAA,EACT;AAAA,EAEA,gBAAgB,UAAU,WAAW,OAAO,yBAAyB,4BAA4B,SAAS;AACxG,eAAO,uCAAwB,MAAM,gBAAgB,UAAU,WAAW,OAAO,yBAAyB,4BAA4B,OAAO,CAAC;AAAA,EAChJ;AAAA,EAEA,YAAY,WAAW,cAAc,cAAc,OAAO,OAAO,SAAS;AACxE,UAAM,aAAa,QAAQ,KAAK,WAAW,SAAS;AAEpD,QAAI,QAAQ,cAAc,KAAK,WAAW,SAAS;AAEnD,UAAM,cAAc;AAAA,uBACD,KAAK,WAAW,SAAS;AAAA;AAAA,aAEnC,wBAAwB,qBAAqB,KAAK,WAAW,SAAS;AAE/E,aAAS;AACT,aAAS,sBAAsB,KAAK,YAAY,WAAW,WAAW,OAAO,SAAS,YAAY;AAAA,4BAC1E,KAAK,YAAY,WAAW,cAAc,OAAO,OAAO,EAAE;AAElF,WAAO;AAAA,EACT;AAAA,EAEA,YAAY,OAAO,WAAW,iBAAiB,SAAS;AAEtD,UAAM,QAAQ,MAAM,YAAY,OAAO,WAAW,iBAAiB,OAAO;AAC1E,QAAI,MAAM,MAAM,GAAG,EAAE,MAAM,KAAK;AAC9B,YAAM,QAAQ,MAAM,MAAM,MAAM,GAAG,EAAE;AACrC,YAAM,QAAQ,8BAA8B,MAAM;AAAA,IACpD;AAEA,WAAO;AAAA,EACT;AAAA,EAEA,YAAY,WAAW,SAAS,OAAO;AAErC,QAAI,QAAQ,MAAM,YAAY,WAAW,SAAS,KAAK;AACvD,QAAI,MAAM,GAAG,EAAE,MAAM,KAAK;AACxB,cAAQ,MAAM,MAAM,GAAG,EAAE;AAAA,IAC3B;AAEA,WAAO;AAAA,EACT;AAAA,EAEA,gBAAgB,WAAW,kBAAkB,SAAS,uBAAuB;AAE3E,QAAI,QAAQ,MAAM,gBAAgB,WAAW,kBAAkB,SAAS,qBAAqB;AAC7F,QAAI,MAAM,GAAG,EAAE,MAAM,KAAK;AACxB,cAAQ,MAAM,MAAM,GAAG,EAAE;AACzB,cAAQ,8BAA8B;AAAA,IACxC;AAEA,WAAO;AAAA,EACT;AAAA,EAEA,mBAAmB,WAAW;AAC5B,WAAO,kBAAkB,KAAK,WAAW,SAAS;AAAA,EACpD;AAAA,EAEA,YAAY,WAAW,OAAO,UAAU,CAAC,GAAG,OAAO;AACjD,QAAI,QAAQ,eAAe,KAAK,WAAW,SAAS;AAEpD,UAAM,WAAW,KAAK,WAAW,OAAO,EAAE,GAAG,SAAS,MAAM,CAAC;AAC7D,QAAI,UAAU;AACZ,eAAS,IAAI;AAAA,IACf;AAEA,QAAI,QAAQ,UAAU,QAAQ,OAAO;AACnC,eAAS,KAAK,kBAAkB,SAAS,KAAK;AAAA,IAChD;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,kBAAkB,SAAS;AACzB,QAAI,WAAW;AAEf,QAAI,QAAQ,QAAQ;AAClB,kBAAY,WAAW,KAAK,OAAO,QAAQ,QAAQ,OAAO;AAAA,IAC5D;AAEA,QAAI,QAAQ,OAAO;AACjB,kBAAY,eAAe,KAAK,OAAO,QAAQ,OAAO,OAAO;AAAA,IAC/D;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,eAAe,WAAW,SAAS;AACjC,QAAI,KAAC,qBAAAC,SAAc,SAAS,GAAG;AAC7B,kBAAY;AAAA,QACV,MAAM;AAAA,MACR;AAAA,IACF;AAEA,UAAM,kBAAkB,UAAU,KAAK,SAAS,EAAE,QAAQ,KAAK,OAAO,KAAK,IAAI,GAAG,SAAS,KAAK,QAAQ,CAAC;AACzG,QAAI,WAAW;AAEf,QAAI,UAAU,gBAAgB,UAAU,MAAM;AAE5C,iBAAW,UAAU,KAAK,MAAM,EAAE,SAAS,KAAK,QAAQ,CAAC;AACzD,UAAI,WAAW,QAAQ,SAAS;AAC9B,oBAAY,QAAQ,YAAY,iBAAiB,SAAS;AAAA,MAC5D;AAEA,kBAAY,WAAW,KAAK,gBAAgB,UAAU,KAAK,QAAQ,UAAU,KAAK,QAAQ,OAAO,IAAI,WAAS;AAC5G,eAAO,KAAK,OAAO,KAAK;AAAA,MAC1B,CAAC,EAAE,KAAK,IAAI;AAAA,IACd,OAAO;AACL,qBAAW,4CAAmB,UAAU,MAAM,EAAE,SAAS,KAAK,QAAQ,CAAC;AAAA,IACzE;AAEA,QAAI,UAAU,cAAc,OAAO;AACjC,kBAAY;AAAA,IACd,WAAW,UAAU,cAAc,SAAS,WAAW,QAAQ,YAAY,iBAAiB;AAC1F,kBAAY;AAAA,IACd;AAEA,QAAI,UAAU,eAAe;AAC3B,kBAAY;AAAA,IACd;AAGA,QAAI,CAAC,mBAAmB,IAAI,eAAe,KACtC,UAAU,KAAK,YAAY,YAC3B,kDAAsB,UAAU,YAAY,GAAG;AAClD,UAAI,UAAU,iBAAiB,MAAM;AACnC,kBAAU,eAAe;AAAA,MAC3B,WAAW,UAAU,iBAAiB,OAAO;AAC3C,kBAAU,eAAe;AAAA,MAC3B;AAEA,kBAAY,YAAY,KAAK,OAAO,UAAU,YAAY;AAAA,IAC5D;AAEA,QAAI,UAAU,WAAW,QAAQ,CAAC,UAAU,YAAY;AACtD,kBAAY;AAAA,IACd;AAEA,QAAI,UAAU,YAAY;AACxB,kBAAY;AAAA,IACd;AAOA,QAAI,UAAU,OAAO;AACnB,kBAAY;AAAA,IACd;AAEA,QAAI,UAAU,OAAO;AACnB,kBAAY,UAAU,KAAK,gBAAgB,UAAU,KAAK;AAAA,IAC5D;AAEA,QAAI,UAAU,YAAY;AAExB,UAAI,WAAW,QAAQ,YAAY,eAAe,QAAQ,YAAY;AACpE,cAAM,WAAW,KAAK,gBAAgB,QAAQ,UAAU;AACxD,cAAM,SAAS,KAAK,gBAAgB,GAAG,QAAQ,aAAa,sBAAsB;AAElF,oBAAY,mBAAmB,uBAAuB;AAAA,MACxD;AAEA,kBAAY,eAAe,KAAK,WAAW,UAAU,WAAW,KAAK;AAErE,UAAI,UAAU,WAAW,KAAK;AAC5B,oBAAY,KAAK,KAAK,gBAAgB,UAAU,WAAW,GAAG;AAAA,MAChE,OAAO;AACL,oBAAY,KAAK,KAAK,gBAAgB,IAAI;AAAA,MAC5C;AAEA,UAAI,UAAU,UAAU;AACtB,oBAAY,cAAc,UAAU,SAAS,YAAY;AAAA,MAC3D;AAEA,UAAI,UAAU,YAAY,UAAU,SAAS,YAAY,MAAM,WAAW;AACxE,oBAAY,cAAc,UAAU,SAAS,YAAY;AAAA,MAC3D;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA,EAEA,gBAAgB,YAAY,SAAS;AACnC,UAAM,SAAS,uBAAO,OAAO,IAAI;AAEjC,eAAW,OAAO,OAAO,KAAK,UAAU,GAAG;AACzC,YAAM,YAAY;AAAA,QAChB,GAAG,WAAW,GAAG;AAAA,QACjB,OAAO,WAAW,GAAG,EAAE,SAAS;AAAA,MAClC;AAEA,aAAO,UAAU,SAAS,GAAG,IAAI,KAAK,eAAe,WAAW,OAAO;AAAA,IACzE;AAEA,WAAO;AAAA,EACT;AACF;",
  "names": ["each", "isPlainObject"]
}
