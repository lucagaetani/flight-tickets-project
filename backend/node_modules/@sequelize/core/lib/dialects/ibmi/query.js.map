{
  "version": 3,
  "sources": ["../../../src/dialects/ibmi/query.js"],
  "sourcesContent": ["'use strict';\n\nimport { find } from '../../utils/iterators';\n\nconst { AbstractQuery } = require('../abstract/query');\nconst sequelizeErrors = require('../../errors');\nconst { logger } = require('../../utils/logger');\n\nconst debug = logger.debugContext('sql:ibmi');\n\nexport class IBMiQuery extends AbstractQuery {\n  getInsertIdField() {\n    return 'id';\n  }\n\n  async run(sql, parameters) {\n    this.sql = sql.replace(/;$/, '');\n\n    const complete = this._logQuery(sql, debug, parameters);\n\n    let results;\n    try {\n      results = await this.connection.query(this.sql, parameters);\n    } catch (error) {\n      throw this.formatError(error);\n    }\n\n    complete();\n\n    // parse the results to the format sequelize expects\n    for (const result of results) {\n      for (const column of results.columns) {\n        const value = result[column.name];\n        if (value == null) {\n          continue;\n        }\n\n        const parse = this.sequelize.dialect.getParserForDatabaseDataType(column.dataType);\n        if (parse) {\n          result[column.name] = parse(value);\n        }\n      }\n    }\n\n    return this.formatResults(results);\n  }\n\n  /**\n   * High level function that handles the results of a query execution.\n   *\n   *\n   * Example:\n   *  query.formatResults([\n   *    {\n   *      id: 1,              // this is from the main table\n   *      attr2: 'snafu',     // this is from the main table\n   *      Tasks.id: 1,        // this is from the associated table\n   *      Tasks.title: 'task' // this is from the associated table\n   *    }\n   *  ])\n   *\n   * @param {Array} data - The result of the query execution.\n   * @private\n   */\n  formatResults(data) {\n    let result = this.instance;\n\n    if (this.isInsertQuery() || this.isUpdateQuery() || this.isUpsertQuery()) {\n      if (this.instance && this.instance.dataValues) {\n        for (const key in data[0]) {\n          if (Object.hasOwn(data[0], key)) {\n            const record = data[0][key];\n\n            const attributes = this.model.modelDefinition.attributes;\n            const attr = find(attributes.values(), attribute => attribute.attributeName === key || attribute.columnName === key);\n\n            this.instance.dataValues[attr?.attributeName || key] = record;\n          }\n        }\n      }\n\n      if (this.isUpsertQuery()) {\n        return [\n          this.instance,\n          null,\n        ];\n      }\n\n      return [\n        this.instance || data && (this.options.plain && data[0] || data) || undefined,\n        data.count,\n      ];\n    }\n\n    if (this.isSelectQuery()) {\n      return this.handleSelectQuery(data);\n    }\n\n    if (this.isShowIndexesQuery()) {\n      return this.handleShowIndexesQuery(data);\n    }\n\n    if (this.isDescribeQuery()) {\n      result = {};\n\n      for (const _result of data) {\n        const enumRegex = /^enum/i;\n        result[_result.COLUMN_NAME] = {\n          type: enumRegex.test(_result.Type) ? _result.Type.replace(enumRegex, 'ENUM') : _result.DATA_TYPE.toUpperCase(),\n          allowNull: _result.IS_NULLABLE === 'Y',\n          defaultValue: _result.COLUMN_DEFAULT,\n          primaryKey: _result.CONSTRAINT_TYPE === 'PRIMARY KEY',\n          autoIncrement: _result.IS_GENERATED !== 'IDENTITY_GENERATION',\n        };\n      }\n\n      return result;\n    }\n\n    if (this.isCallQuery()) {\n      return data[0];\n    }\n\n    if (this.isBulkUpdateQuery() || this.isBulkDeleteQuery() || this.isUpsertQuery()) {\n      return data.count;\n    }\n\n    if (this.isInsertQuery(data)) {\n      // insert queries can't call count, because they are actually select queries wrapped around insert queries to get the inserted id. Need to count the number of results instead.\n      return [result, data.length];\n    }\n\n    if (this.isUpdateQuery()) {\n      return [result, data.count];\n    }\n\n    if (this.isShowConstraintsQuery()) {\n      return data;\n    }\n\n    if (this.isRawQuery()) {\n      // MySQL returns row data and metadata (affected rows etc) in a single object - let's standarize it, sorta\n      return [data, data];\n    }\n\n    if (this.isShowIndexesQuery()) {\n      return data;\n    }\n\n    return result;\n  }\n\n  handleInsertQuery(results, metaData) {\n    if (this.instance) {\n      // add the inserted row id to the instance\n      const autoIncrementAttribute = this.model.autoIncrementAttribute.field;\n      let id = null;\n\n      id = id || results && results[autoIncrementAttribute];\n      id = id || metaData && metaData[autoIncrementAttribute];\n\n      this.instance[this.model.autoIncrementAttribute] = id;\n    }\n  }\n\n  handleShowIndexesQuery(data) {\n\n    const indexes = Object.create(null);\n\n    data.forEach(item => {\n\n      if (Object.hasOwn(indexes, item.NAME)) {\n        indexes[item.NAME].fields.push({ attribute: item.COLUMN_NAME, length: undefined, order: undefined, collate: undefined });\n      } else {\n        indexes[item.NAME] = {\n          primary: item.CONSTRAINT_TYPE === 'PRIMARY KEY',\n          fields: [{ attribute: item.COLUMN_NAME, length: undefined, order: undefined, collate: undefined }],\n          name: item.NAME,\n          tableName: item.TABLE_NAME,\n          unique: item.CONSTRAINT_TYPE === 'PRIMARY KEY' || item.CONSTRAINT_TYPE === 'UNIQUE',\n          type: item.CONSTRAINT_TYPE,\n        };\n      }\n    });\n\n    return Object.values(indexes);\n  }\n\n  formatError(err) {\n\n    // Db2 for i uses the `odbc` connector. The `odbc` connector returns a list\n    // of odbc errors, each of which has a code and a state. To determine the\n    // type of SequelizeError, check the code and create the associated error.\n    // Error codes can be found at:\n    // https://www.ibm.com/support/knowledgecenter/ssw_ibm_i_72/rzala/rzalaccl.htm\n\n    // some errors occur outside of ODBC (e.g. connection errors)\n    if (err.toString().includes('Error connecting to the database')) {\n      return new sequelizeErrors.ConnectionRefusedError(err);\n    }\n\n    if (Object.hasOwn(err, 'odbcErrors') && err.odbcErrors.length > 0) {\n      const odbcError = err.odbcErrors[0];\n      const foreignKeyConstraintCodes = [\n        -530, // The insert or update value of a foreign key is invalid.\n        -531, // The update or delete of a parent key is prevented by a NO ACTION update or delete rule.\n        -532, // The update or delete of a parent key is prevented by a NO ACTION update or delete rule.\n      ];\n      const uniqueConstraintCodes = [\n        -803, // A violation of the constraint imposed by a unique index or a unique constraint occurred.\n      ];\n\n      if (foreignKeyConstraintCodes.includes(odbcError.code)) {\n        return new sequelizeErrors.ForeignKeyConstraintError({\n          cause: err,\n          sql: {},\n          fields: {},\n        });\n      }\n\n      if (uniqueConstraintCodes.includes(odbcError.code)) {\n        return new sequelizeErrors.UniqueConstraintError({\n          errors: err.odbcErrors,\n          cause: err,\n          sql: {},\n          fields: {},\n        });\n      }\n\n      if (odbcError.code === -204) {\n        let constraintName;\n        let type;\n        const constraintNameRegex = /\"([^)]+?)\" in [^]+? type (\\*\\w+?) not found./;\n        const constraintNameRegexMatches = odbcError.message.match(constraintNameRegex);\n        if (constraintNameRegexMatches && constraintNameRegexMatches.length === 3) {\n          constraintName = constraintNameRegexMatches[1];\n          type = constraintNameRegexMatches[2];\n\n          if (type === '*N') {\n            return new sequelizeErrors.UnknownConstraintError({\n              cause: err,\n              constraint: constraintName,\n            });\n          }\n        }\n      }\n\n      return new sequelizeErrors.DatabaseError(odbcError);\n    }\n\n    return err;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
