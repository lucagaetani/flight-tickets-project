"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var query_generator_exports = {};
__export(query_generator_exports, {
  IBMiQueryGenerator: () => IBMiQueryGenerator
});
module.exports = __toCommonJS(query_generator_exports);
var import_base_sql_expression = require("../../expression-builders/base-sql-expression.js");
var import_model_internals = require("../../model-internals");
var import_check = require("../../utils/check");
var import_string = require("../../utils/string");
var import_query_builder_utils = require("../../utils/query-builder-utils");
var import_data_types_utils = require("../abstract/data-types-utils");
var import_query_generator = require("../abstract/query-generator");
var import_each = __toESM(require("lodash/each"));
var import_isPlainObject = __toESM(require("lodash/isPlainObject"));
const util = require("node:util");
const { IBMiQueryGeneratorTypeScript } = require("./query-generator-typescript");
const DataTypes = require("../../data-types");
const typeWithoutDefault = /* @__PURE__ */ new Set(["BLOB"]);
const CREATE_SCHEMA_QUERY_SUPPORTED_OPTIONS = /* @__PURE__ */ new Set();
const CREATE_TABLE_QUERY_SUPPORTED_OPTIONS = /* @__PURE__ */ new Set(["uniqueKeys"]);
const DROP_TABLE_QUERY_SUPPORTED_OPTIONS = /* @__PURE__ */ new Set();
const ADD_COLUMN_QUERY_SUPPORTED_OPTIONS = /* @__PURE__ */ new Set();
const REMOVE_COLUMN_QUERY_SUPPORTED_OPTIONS = /* @__PURE__ */ new Set();
class IBMiQueryGenerator extends IBMiQueryGeneratorTypeScript {
  // Schema queries
  createSchemaQuery(schema, options) {
    if (options) {
      (0, import_check.rejectInvalidOptions)(
        "createSchemaQuery",
        this.dialect.name,
        import_query_generator.CREATE_SCHEMA_QUERY_SUPPORTABLE_OPTIONS,
        CREATE_SCHEMA_QUERY_SUPPORTED_OPTIONS,
        options
      );
    }
    return `CREATE SCHEMA "${schema}"`;
  }
  dropSchemaQuery(schema) {
    return `BEGIN IF EXISTS (SELECT * FROM SYSIBM.SQLSCHEMAS WHERE TABLE_SCHEM = ${schema ? `'${schema}'` : "CURRENT SCHEMA"}) THEN SET TRANSACTION ISOLATION LEVEL NO COMMIT; DROP SCHEMA "${schema ? `${schema}` : "CURRENT SCHEMA"}"; COMMIT; END IF; END`;
  }
  // Table queries
  createTableQuery(tableName, attributes, options) {
    if (options) {
      (0, import_check.rejectInvalidOptions)(
        "createTableQuery",
        this.dialect.name,
        import_query_generator.CREATE_TABLE_QUERY_SUPPORTABLE_OPTIONS,
        CREATE_TABLE_QUERY_SUPPORTED_OPTIONS,
        options
      );
    }
    const primaryKeys = [];
    const foreignKeys = /* @__PURE__ */ Object.create(null);
    const attrStr = [];
    for (const attr in attributes) {
      if (!Object.hasOwn(attributes, attr)) {
        continue;
      }
      const dataType = attributes[attr];
      if (dataType.includes("PRIMARY KEY")) {
        primaryKeys.push(attr);
        attrStr.push(`${this.quoteIdentifier(attr)} ${dataType.replace("PRIMARY KEY", "")}`);
      } else {
        attrStr.push(`${this.quoteIdentifier(attr)} ${dataType}`);
      }
    }
    let attributesClause = attrStr.join(", ");
    const pkString = primaryKeys.map((pk) => this.quoteIdentifier(pk)).join(", ");
    if (options == null ? void 0 : options.uniqueKeys) {
      const sortedPrimaryKeys = [...primaryKeys];
      sortedPrimaryKeys.sort();
      (0, import_each.default)(options.uniqueKeys, (columns, indexName) => {
        const sortedColumnFields = [...columns.fields];
        sortedColumnFields.sort();
        const uniqueIsPrimary = sortedColumnFields.length === primaryKeys.length && sortedColumnFields.every((value, index) => {
          return value === sortedPrimaryKeys[index];
        });
        if (uniqueIsPrimary) {
          return true;
        }
        if (typeof indexName !== "string") {
          indexName = `uniq_${tableName}_${columns.fields.join("_")}`;
        }
        attributesClause += `, CONSTRAINT ${this.quoteIdentifier(indexName)} UNIQUE (${columns.fields.map((field) => this.quoteIdentifier(field)).join(", ")})`;
      });
    }
    if (pkString.length > 0) {
      attributesClause += `, PRIMARY KEY (${pkString})`;
    }
    for (const fkey in foreignKeys) {
      if (Object.hasOwn(foreignKeys, fkey)) {
        attributesClause += `, FOREIGN KEY (${this.quoteIdentifier(fkey)}) ${foreignKeys[fkey]}`;
      }
    }
    const quotedTable = this.quoteTable(tableName);
    return `BEGIN
    DECLARE CONTINUE HANDLER FOR SQLSTATE VALUE '42710'
      BEGIN END;
      CREATE TABLE ${quotedTable} (${attributesClause});
      END`;
  }
  addColumnQuery(table, key, dataType, options) {
    if (options) {
      (0, import_check.rejectInvalidOptions)(
        "addColumnQuery",
        this.dialect.name,
        import_query_generator.ADD_COLUMN_QUERY_SUPPORTABLE_OPTIONS,
        ADD_COLUMN_QUERY_SUPPORTED_OPTIONS,
        options
      );
    }
    dataType = {
      ...dataType,
      // TODO: attributeToSQL SHOULD be using attributes in addColumnQuery
      //       but instead we need to pass the key along as the field here
      field: key,
      type: (0, import_data_types_utils.normalizeDataType)(dataType.type, this.dialect)
    };
    const definition = this.attributeToSQL(dataType, {
      context: "addColumn",
      tableName: table,
      foreignKey: key
    });
    return `ALTER TABLE ${this.quoteTable(table)} ADD ${this.quoteIdentifier(key)} ${definition}`;
  }
  changeColumnQuery(tableName, attributes) {
    const attrString = [];
    const constraintString = [];
    for (const attributeName in attributes) {
      let definition = attributes[attributeName];
      if (definition.includes("REFERENCES")) {
        const attrName = this.quoteIdentifier(attributeName);
        definition = definition.replace(/.+?(?=REFERENCES)/, "");
        const foreignKey = this.quoteIdentifier(`${attributeName}`);
        constraintString.push(`${foreignKey} FOREIGN KEY (${attrName}) ${definition}`);
      } else {
        attrString.push(`"${attributeName}" SET DATA TYPE ${definition}`);
      }
    }
    let finalQuery = "";
    if (attrString.length) {
      finalQuery += `ALTER COLUMN ${attrString.join(", ")}`;
      finalQuery += constraintString.length ? " " : "";
    }
    if (constraintString.length) {
      finalQuery += `ADD CONSTRAINT ${constraintString.join(", ")}`;
    }
    return `ALTER TABLE ${this.quoteTable(tableName)} ${finalQuery}`;
  }
  renameTableQuery(before, after) {
    return `RENAME TABLE ${this.quoteTable(before)} TO ${this.quoteTable(after)}`;
  }
  renameColumnQuery(tableName, attrBefore, attributes) {
    const attrString = [];
    for (const attrName in attributes) {
      const definition = attributes[attrName];
      attrString.push(`\`${attrBefore}\` \`${attrName}\` ${definition}`);
    }
    return `ALTER TABLE ${this.quoteTable(tableName)} RENAME COLUMN ${attrString.join(", ")};`;
  }
  /*
    Returns an add index query.
    Parameters:
      - tableName -> Name of an existing table, possibly with schema.
      - options:
        - type: UNIQUE|FULLTEXT|SPATIAL
        - name: The name of the index. Default is <table>_<attr1>_<attr2>
        - fields: An array of attributes as string or as hash.
                  If the attribute is a hash, it must have the following content:
                  - name: The name of the attribute/column
                  - length: An integer. Optional
                  - order: 'ASC' or 'DESC'. Optional
        - parser
        - using
        - operator
        - concurrently: Pass CONCURRENT so other operations run while the index is created
      - rawTablename, the name of the table, without schema. Used to create the name of the index
   @private
  */
  addIndexQuery(tableName, _attributes, _options, rawTablename) {
    let options = _options || /* @__PURE__ */ Object.create(null);
    if (!Array.isArray(_attributes)) {
      options = _attributes;
    } else {
      options.fields = _attributes;
    }
    options.prefix = options.prefix || rawTablename || tableName;
    if (options.prefix && typeof options.prefix === "string") {
      options.prefix = options.prefix.replaceAll(".", "_");
    }
    const fieldsSql = options.fields.map((field) => {
      if (typeof field === "string") {
        return this.quoteIdentifier(field);
      }
      if (field instanceof import_base_sql_expression.BaseSqlExpression) {
        return this.formatSqlExpression(field);
      }
      let result = "";
      if (field.attribute) {
        field.name = field.attribute;
      }
      if (!field.name) {
        throw new Error(`The following index field has no name: ${util.inspect(field)}`);
      }
      result += this.quoteIdentifier(field.name);
      if (this.dialect.supports.index.length && field.length) {
        result += `(${field.length})`;
      }
      if (field.order) {
        result += ` ${field.order}`;
      }
      return result;
    });
    if (options.include) {
      throw new Error(`The include attribute for indexes is not supported by ${this.dialect.name} dialect`);
    }
    if (!options.name) {
      options = (0, import_string.nameIndex)(options, options.prefix);
    }
    options = (0, import_model_internals.conformIndex)(options);
    if (!this.dialect.supports.index.type) {
      delete options.type;
    }
    if (options.where) {
      options.where = this.whereQuery(options.where);
    }
    tableName = this.quoteTable(tableName);
    let schema;
    if (typeof options.schema === "string") {
      schema = this.quoteIdentifiers(options.schema);
    }
    if (options.unique) {
      return `BEGIN
      DECLARE CONTINUE HANDLER FOR SQLSTATE VALUE '42891'
        BEGIN END;
        ALTER TABLE ${tableName} ADD CONSTRAINT ${this.quoteIdentifiers(options.name)} UNIQUE (${fieldsSql.join(", ")}${options.operator ? ` ${options.operator}` : ""})${options.where ? ` ${options.where}` : ""};
      END`;
    }
    return `CREATE${options.unique ? " UNIQUE" : ""} INDEX ${schema ? ` ${schema}.` : ""}${this.quoteIdentifiers(options.name)} ON ${tableName} (${fieldsSql.join(", ")}${options.operator ? ` ${options.operator}` : ""})${options.where ? ` ${options.where}` : ""}`;
  }
  updateQuery(tableName, attrValueHash, where, options, columnDefinitions) {
    const out = super.updateQuery(tableName, attrValueHash, where, options, columnDefinitions);
    out.query = (0, import_string.removeTrailingSemicolon)(out.query);
    return out;
  }
  arithmeticQuery(operator, tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options) {
    return (0, import_string.removeTrailingSemicolon)(super.arithmeticQuery(operator, tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options));
  }
  upsertQuery(tableName, insertValues, updateValues, where, model, options) {
    const aliasTable = `temp_${this.quoteTable(tableName)}`;
    let query = `MERGE INTO ${this.quoteTable(tableName)} `;
    const usingClause = `USING (
      SELECT * FROM (${this.quoteTable(tableName)}
      VALUES(42)
      ) AS ${aliasTable}("id") ON (${aliasTable}."id" = ${this.quoteTable(tableName)}."id")`;
    query += usingClause;
    query += ` WHEN MATCHED THEN ${this.updateQuery(tableName, tableName, where, options, updateValues)}
    WHEN NOT MATCHED THEN ${this.insertQuery(tableName, insertValues, model, options).sql}`;
    return query;
  }
  insertQuery(table, valueHash, modelAttributes, options) {
    const query = super.insertQuery(table, valueHash, modelAttributes, options);
    if (query.query.at(-1) === ";") {
      query.query = query.query.slice(0, -1);
      query.query = `SELECT * FROM FINAL TABLE (${query.query})`;
    }
    return query;
  }
  selectQuery(tableName, options, model) {
    let query = super.selectQuery(tableName, options, model);
    if (query.at(-1) === ";") {
      query = query.slice(0, -1);
    }
    return query;
  }
  bulkInsertQuery(tableName, fieldValueHashes, options, fieldMappedAttributes) {
    let query = super.bulkInsertQuery(tableName, fieldValueHashes, options, fieldMappedAttributes);
    if (query.at(-1) === ";") {
      query = query.slice(0, -1);
      query = `SELECT * FROM FINAL TABLE (${query})`;
    }
    return query;
  }
  truncateTableQuery(tableName) {
    return `TRUNCATE TABLE ${this.quoteTable(tableName)} IMMEDIATE`;
  }
  deleteQuery(tableName, where, options = {}, model) {
    let query = `DELETE FROM ${this.quoteTable(tableName)}`;
    const whereSql = this.whereQuery(where, { ...options, model });
    if (whereSql) {
      query += ` ${whereSql}`;
    }
    if (options.offset || options.limit) {
      query += this.addLimitAndOffset(options, model);
    }
    return query;
  }
  /**
   * Returns an SQL fragment for adding result constraints.
   *
   * @param  {object} options An object with selectQuery options.
   * @returns {string}         The generated sql query.
   * @private
   */
  addLimitAndOffset(options) {
    let fragment = "";
    if (options.offset) {
      fragment += ` OFFSET ${this.escape(options.offset, options)} ROWS`;
    }
    if (options.limit) {
      fragment += ` FETCH NEXT ${this.escape(options.limit, options)} ROWS ONLY`;
    }
    return fragment;
  }
  // bindParam(bind) {
  //   return value => {
  //     bind.push(value);
  //     return '?';
  //   };
  // }
  attributeToSQL(attribute, options) {
    if (!(0, import_isPlainObject.default)(attribute)) {
      attribute = {
        type: attribute
      };
    }
    const attributeString = attribute.type.toString({ escape: this.escape.bind(this), dialect: this.dialect });
    let template = attributeString;
    if (attribute.type instanceof DataTypes.ENUM) {
      template = attribute.type.toSql({ dialect: this.dialect });
      if (options && options.context) {
        template += options.context === "changeColumn" ? " ADD" : "";
      }
      template += ` CHECK (${this.quoteIdentifier(attribute.field)} IN(${attribute.type.options.values.map((value) => {
        return this.escape(value);
      }).join(", ")}))`;
    } else {
      template = (0, import_data_types_utils.attributeTypeToSql)(attribute.type, { dialect: this.dialect });
    }
    if (attribute.allowNull === false) {
      template += " NOT NULL";
    } else if (attribute.allowNull === true && (options && options.context === "changeColumn")) {
      template += " DROP NOT NULL";
    }
    if (attribute.autoIncrement) {
      template += " GENERATED BY DEFAULT AS IDENTITY (START WITH 1, INCREMENT BY 1)";
    }
    if (!typeWithoutDefault.has(attributeString) && attribute.type._binary !== true && (0, import_query_builder_utils.defaultValueSchemable)(attribute.defaultValue)) {
      if (attribute.defaultValue === true) {
        attribute.defaultValue = 1;
      } else if (attribute.defaultValue === false) {
        attribute.defaultValue = 0;
      }
      template += ` DEFAULT ${this.escape(attribute.defaultValue)}`;
    }
    if (attribute.unique === true && !attribute.primaryKey) {
      template += " UNIQUE";
    }
    if (attribute.primaryKey) {
      template += " PRIMARY KEY";
    }
    if (attribute.first) {
      template += " FIRST";
    }
    if (attribute.after) {
      template += ` AFTER ${this.quoteIdentifier(attribute.after)}`;
    }
    if (attribute.references) {
      if (options && options.context === "addColumn" && options.foreignKey) {
        const attrName = this.quoteIdentifier(options.foreignKey);
        const fkName = this.quoteIdentifier(`${options.tableName}_${attrName}_foreign_idx`);
        template += ` ADD CONSTRAINT ${fkName} FOREIGN KEY (${attrName})`;
      }
      template += ` REFERENCES ${this.quoteTable(attribute.references.table)}`;
      if (attribute.references.key) {
        template += ` (${this.quoteIdentifier(attribute.references.key)})`;
      } else {
        template += ` (${this.quoteIdentifier("id")})`;
      }
      if (attribute.onDelete) {
        template += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;
      }
      if (attribute.onUpdate && attribute.onUpdate.toUpperCase() !== "CASCADE") {
        template += ` ON UPDATE ${attribute.onUpdate.toUpperCase()}`;
      }
    }
    return template;
  }
  attributesToSQL(attributes, options) {
    const result = /* @__PURE__ */ Object.create(null);
    for (const key of Object.keys(attributes)) {
      const attribute = {
        ...attributes[key],
        field: attributes[key].field || key
      };
      result[attribute.field || key] = this.attributeToSQL(attribute, options);
    }
    return result;
  }
}
//# sourceMappingURL=query-generator.js.map
