{
  "version": 3,
  "sources": ["../../../src/dialects/mysql/data-types.db.ts"],
  "sourcesContent": ["import dayjs from 'dayjs';\nimport wkx from 'wkx';\nimport { isValidTimeZone } from '../../utils/dayjs.js';\nimport type { MySqlTypeCastValue } from './connection-manager.js';\nimport type { MysqlDialect } from './index.js';\n\n/**\n * First pass of DB value parsing: Parses based on the MySQL Type ID.\n * If a Sequelize DataType is specified, the value is then passed to {@link DataTypes.ABSTRACT#parseDatabaseValue}.\n *\n * @param dialect\n */\nexport function registerMySqlDbDataTypeParsers(dialect: MysqlDialect) {\n  /*\n  * @see buffer_type here https://dev.mysql.com/doc/refman/5.7/en/c-api-prepared-statement-type-codes.html\n  * @see hex here https://github.com/sidorares/node-mysql2/blob/master/lib/constants/types.js\n  */\n  dialect.registerDataTypeParser(['DATETIME'], (value: MySqlTypeCastValue) => {\n    const valueStr = value.string();\n    if (valueStr === null) {\n      return null;\n    }\n\n    const timeZone = dialect.sequelize.options.timezone;\n    if (timeZone === '+00:00') { // default value\n      // mysql returns a UTC date string that looks like the following:\n      // 2022-01-01 00:00:00\n      // The above does not specify a time zone offset, so Date.parse will try to parse it as a local time.\n      // Adding +00 fixes this.\n      return `${valueStr}+00`;\n    }\n\n    if (isValidTimeZone(timeZone)) {\n      return dayjs.tz(valueStr, timeZone).toISOString();\n    }\n\n    // offset format, we can just append.\n    // \"2022-09-22 20:03:06\" with timeZone \"-04:00\"\n    // becomes \"2022-09-22 20:03:06-04:00\"\n    return valueStr + timeZone;\n  });\n\n  // dateonly\n  dialect.registerDataTypeParser(['DATE'], (value: MySqlTypeCastValue) => {\n    return value.string();\n  });\n\n  // bigint\n  dialect.registerDataTypeParser(['LONGLONG'], (value: MySqlTypeCastValue) => {\n    return value.string();\n  });\n\n  dialect.registerDataTypeParser(['GEOMETRY'], (value: MySqlTypeCastValue) => {\n    let buffer = value.buffer();\n    // Empty buffer, MySQL doesn't support POINT EMPTY\n    // check, https://dev.mysql.com/worklog/task/?id=2381\n    if (!buffer || buffer.length === 0) {\n      return null;\n    }\n\n    // For some reason, discard the first 4 bytes\n    buffer = buffer.slice(4);\n\n    return wkx.Geometry.parse(buffer).toGeoJSON({ shortCrs: true });\n  });\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAAkB;AAClB,iBAAgB;AAChB,IAAAA,gBAAgC;AAUzB,SAAS,+BAA+B,SAAuB;AAKpE,UAAQ,uBAAuB,CAAC,UAAU,GAAG,CAAC,UAA8B;AAC1E,UAAM,WAAW,MAAM,OAAO;AAC9B,QAAI,aAAa,MAAM;AACrB,aAAO;AAAA,IACT;AAEA,UAAM,WAAW,QAAQ,UAAU,QAAQ;AAC3C,QAAI,aAAa,UAAU;AAKzB,aAAO,GAAG;AAAA,IACZ;AAEA,YAAI,+BAAgB,QAAQ,GAAG;AAC7B,aAAO,aAAAC,QAAM,GAAG,UAAU,QAAQ,EAAE,YAAY;AAAA,IAClD;AAKA,WAAO,WAAW;AAAA,EACpB,CAAC;AAGD,UAAQ,uBAAuB,CAAC,MAAM,GAAG,CAAC,UAA8B;AACtE,WAAO,MAAM,OAAO;AAAA,EACtB,CAAC;AAGD,UAAQ,uBAAuB,CAAC,UAAU,GAAG,CAAC,UAA8B;AAC1E,WAAO,MAAM,OAAO;AAAA,EACtB,CAAC;AAED,UAAQ,uBAAuB,CAAC,UAAU,GAAG,CAAC,UAA8B;AAC1E,QAAI,SAAS,MAAM,OAAO;AAG1B,QAAI,CAAC,UAAU,OAAO,WAAW,GAAG;AAClC,aAAO;AAAA,IACT;AAGA,aAAS,OAAO,MAAM,CAAC;AAEvB,WAAO,WAAAC,QAAI,SAAS,MAAM,MAAM,EAAE,UAAU,EAAE,UAAU,KAAK,CAAC;AAAA,EAChE,CAAC;AACH;",
  "names": ["import_dayjs", "dayjs", "wkx"]
}
