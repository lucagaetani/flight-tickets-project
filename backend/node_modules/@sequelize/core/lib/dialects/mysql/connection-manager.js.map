{
  "version": 3,
  "sources": ["../../../src/dialects/mysql/connection-manager.ts"],
  "sourcesContent": ["import assert from 'node:assert';\nimport { promisify } from 'node:util';\nimport dayjs from 'dayjs';\nimport type {\n  Connection,\n  ConnectionOptions as MySqlConnectionOptions,\n  createConnection as mysqlCreateConnection,\n} from 'mysql2';\nimport {\n  AccessDeniedError,\n  ConnectionError,\n  ConnectionRefusedError,\n  HostNotFoundError,\n  HostNotReachableError,\n  InvalidConnectionError,\n} from '../../errors';\nimport type { ConnectionOptions, Sequelize } from '../../sequelize.js';\nimport { isError, isNodeError } from '../../utils/check.js';\nimport { logger } from '../../utils/logger';\nimport type { Connection as AbstractConnection } from '../abstract/connection-manager';\nimport { AbstractConnectionManager } from '../abstract/connection-manager';\nimport type { AbstractDialect } from '../abstract/index.js';\n\nconst debug = logger.debugContext('connection:mysql');\n\n// TODO: once the code has been split into packages, we won't need to lazy load mysql2 anymore\ntype Lib = {\n  createConnection: typeof mysqlCreateConnection,\n  Connection: Connection,\n};\n\nexport interface MySqlConnection extends Connection, AbstractConnection {}\n\nexport interface MySqlTypeCastValue {\n  type: string;\n  length: number;\n  db: string;\n  table: string;\n  name: string;\n  string(): string;\n  buffer(): Buffer;\n  geometry(): unknown;\n}\n\n/**\n * MySQL Connection Manager\n *\n * Get connections, validate and disconnect them.\n * AbstractConnectionManager pooling use it to handle MySQL specific connections\n * Use https://github.com/sidorares/node-mysql2 to connect with MySQL server\n *\n * @private\n */\nexport class MySqlConnectionManager extends AbstractConnectionManager<MySqlConnection> {\n  private readonly lib: Lib;\n\n  constructor(dialect: AbstractDialect, sequelize: Sequelize) {\n    super(dialect, sequelize);\n    this.lib = this._loadDialectModule('mysql2') as Lib;\n  }\n\n  #typecast(field: MySqlTypeCastValue, next: () => void): unknown {\n    const dataParser = this.dialect.getParserForDatabaseDataType(field.type);\n    if (dataParser) {\n      const value = dataParser(field);\n\n      if (value !== undefined) {\n        return value;\n      }\n    }\n\n    return next();\n  }\n\n  /**\n   * Connect with MySQL database based on config, Handle any errors in connection\n   * Set the pool handlers on connection.error\n   * Also set proper timezone once connection is connected.\n   *\n   * @param config\n   * @returns\n   * @private\n   */\n  async connect(config: ConnectionOptions): Promise<MySqlConnection> {\n    assert(typeof config.port === 'number', 'port has not been normalized');\n\n    const connectionConfig: MySqlConnectionOptions = {\n      bigNumberStrings: false,\n      supportBigNumbers: true,\n      flags: ['-FOUND_ROWS'],\n      ...config.dialectOptions,\n      ...(config.host == null ? null : { host: config.host }),\n      port: config.port,\n      ...(config.username == null ? null : { user: config.username }),\n      ...(config.password == null ? null : { password: config.password }),\n      ...(config.database == null ? null : { database: config.database }),\n      ...(!this.sequelize.options.timezone ? null : { timezone: this.sequelize.options.timezone }),\n      typeCast: (field, next) => this.#typecast(field, next),\n    };\n\n    try {\n      const connection: MySqlConnection = await createConnection(this.lib, connectionConfig);\n\n      debug('connection acquired');\n\n      connection.on('error', (error: unknown) => {\n        if (!isNodeError(error)) {\n          return;\n        }\n\n        switch (error.code) {\n          case 'ESOCKET':\n          case 'ECONNRESET':\n          case 'EPIPE':\n          case 'PROTOCOL_CONNECTION_LOST':\n            void this.pool.destroy(connection);\n            break;\n          default:\n        }\n      });\n\n      if (!this.sequelize.config.keepDefaultTimezone && this.sequelize.options.timezone) {\n        // set timezone for this connection\n        // but named timezone are not directly supported in mysql, so get its offset first\n        let tzOffset = this.sequelize.options.timezone;\n        tzOffset = tzOffset.includes('/') ? dayjs.tz(undefined, tzOffset).format('Z') : tzOffset;\n        await promisify(cb => connection.query(`SET time_zone = '${tzOffset}'`, cb))();\n      }\n\n      return connection;\n    } catch (error) {\n      if (!isError(error)) {\n        throw error;\n      }\n\n      const code = isNodeError(error) ? error.code : null;\n\n      switch (code) {\n        case 'ECONNREFUSED':\n          throw new ConnectionRefusedError(error);\n        case 'ER_ACCESS_DENIED_ERROR':\n          throw new AccessDeniedError(error);\n        case 'ENOTFOUND':\n          throw new HostNotFoundError(error);\n        case 'EHOSTUNREACH':\n          throw new HostNotReachableError(error);\n        case 'EINVAL':\n          throw new InvalidConnectionError(error);\n        default:\n          throw new ConnectionError(error);\n      }\n    }\n  }\n\n  async disconnect(connection: MySqlConnection) {\n    // @ts-expect-error -- undeclared var\n    if (connection._closing) {\n      debug('connection tried to disconnect but was already at CLOSED state');\n\n      return;\n    }\n\n    await promisify(callback => connection.end(callback))();\n  }\n\n  validate(connection: MySqlConnection) {\n    return connection\n      // @ts-expect-error -- undeclared var\n      && !connection._fatalError\n      // @ts-expect-error -- undeclared var\n      && !connection._protocolError\n      // @ts-expect-error -- undeclared var\n      && !connection._closing\n      // @ts-expect-error -- undeclared var\n      && !connection.stream.destroyed;\n  }\n}\n\nasync function createConnection(\n  lib: Lib,\n  config: MySqlConnectionOptions,\n): Promise<MySqlConnection> {\n  return new Promise((resolve, reject) => {\n    const connection: MySqlConnection = lib.createConnection(config) as MySqlConnection;\n\n    const errorHandler = (e: unknown) => {\n      // clean up connect & error event if there is error\n      connection.removeListener('connect', connectHandler);\n      connection.removeListener('error', connectHandler);\n      reject(e);\n    };\n\n    const connectHandler = () => {\n      // clean up error event if connected\n      connection.removeListener('error', errorHandler);\n      resolve(connection);\n    };\n\n    // don't use connection.once for error event handling here\n    // mysql2 emit error two times in case handshake was failed\n    // first error is protocol_lost and second is timeout\n    // if we will use `once.error` node process will crash on 2nd error emit\n    connection.on('error', errorHandler);\n    connection.once('connect', connectHandler);\n  });\n}\n"],
  "mappings": "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",
  "names": ["assert", "dayjs"]
}
