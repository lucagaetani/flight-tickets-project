{
  "version": 3,
  "sources": ["../../../src/dialects/postgres/query-generator.js"],
  "sourcesContent": ["'use strict';\n\nimport { EMPTY_OBJECT } from '../../utils/object.js';\nimport { defaultValueSchemable } from '../../utils/query-builder-utils';\nimport { generateIndexName } from '../../utils/string';\nimport { ENUM } from './data-types';\nimport { quoteIdentifier } from '../../utils/dialect';\nimport { rejectInvalidOptions } from '../../utils/check';\nimport {\n  CREATE_DATABASE_QUERY_SUPPORTABLE_OPTIONS,\n  CREATE_SCHEMA_QUERY_SUPPORTABLE_OPTIONS,\n  CREATE_TABLE_QUERY_SUPPORTABLE_OPTIONS,\n  DROP_TABLE_QUERY_SUPPORTABLE_OPTIONS,\n} from '../abstract/query-generator';\n\nimport each from 'lodash/each';\nimport isEmpty from 'lodash/isEmpty';\nimport isPlainObject from 'lodash/isPlainObject';\nimport map from 'lodash/map';\nimport reduce from 'lodash/reduce';\n\nconst DataTypes = require('../../data-types');\nconst { PostgresQueryGeneratorTypeScript } = require('./query-generator-typescript');\n\n/**\n * list of reserved words in PostgreSQL 10\n * source: https://www.postgresql.org/docs/10/static/sql-keywords-appendix.html\n *\n * @private\n */\nconst POSTGRES_RESERVED_WORDS = 'all,analyse,analyze,and,any,array,as,asc,asymmetric,authorization,binary,both,case,cast,check,collate,collation,column,concurrently,constraint,create,cross,current_catalog,current_date,current_role,current_schema,current_time,current_timestamp,current_user,default,deferrable,desc,distinct,do,else,end,except,false,fetch,for,foreign,freeze,from,full,grant,group,having,ilike,in,initially,inner,intersect,into,is,isnull,join,lateral,leading,left,like,limit,localtime,localtimestamp,natural,not,notnull,null,offset,on,only,or,order,outer,overlaps,placing,primary,references,returning,right,select,session_user,similar,some,symmetric,table,tablesample,then,to,trailing,true,union,unique,user,using,variadic,verbose,when,where,window,with'.split(',');\n\nconst CREATE_DATABASE_QUERY_SUPPORTED_OPTIONS = new Set(['encoding', 'collate', 'ctype', 'template']);\nconst CREATE_SCHEMA_QUERY_SUPPORTED_OPTIONS = new Set();\nconst CREATE_TABLE_QUERY_SUPPORTED_OPTIONS = new Set(['comment', 'uniqueKeys']);\nconst DROP_TABLE_QUERY_SUPPORTED_OPTIONS = new Set(['cascade']);\n\nexport class PostgresQueryGenerator extends PostgresQueryGeneratorTypeScript {\n  setSearchPath(searchPath) {\n    return `SET search_path to ${searchPath};`;\n  }\n\n  createDatabaseQuery(databaseName, options) {\n    if (options) {\n      rejectInvalidOptions(\n        'createDatabaseQuery',\n        this.dialect.name,\n        CREATE_DATABASE_QUERY_SUPPORTABLE_OPTIONS,\n        CREATE_DATABASE_QUERY_SUPPORTED_OPTIONS,\n        options,\n      );\n    }\n\n    const quotedDatabaseName = this.quoteIdentifier(databaseName);\n    const encoding = options?.encoding ? ` ENCODING = ${this.escape(options.encoding)}` : '';\n    const collation = options?.collate ? ` LC_COLLATE = ${this.escape(options.collate)}` : '';\n    const ctype = options?.ctype ? ` LC_CTYPE = ${this.escape(options.ctype)}` : '';\n    const template = options?.template ? ` TEMPLATE = ${this.escape(options.template)}` : '';\n\n    return `CREATE DATABASE ${quotedDatabaseName}${encoding}${collation}${ctype}${template};`;\n  }\n\n  dropDatabaseQuery(databaseName) {\n    return `DROP DATABASE IF EXISTS ${this.quoteIdentifier(databaseName)};`;\n  }\n\n  listDatabasesQuery() {\n    return `SELECT datname AS name FROM pg_database;`;\n  }\n\n  createSchemaQuery(schema, options) {\n    if (options) {\n      rejectInvalidOptions(\n        'createSchemaQuery',\n        this.dialect.name,\n        CREATE_SCHEMA_QUERY_SUPPORTABLE_OPTIONS,\n        CREATE_SCHEMA_QUERY_SUPPORTED_OPTIONS,\n        options,\n      );\n    }\n\n    return `CREATE SCHEMA IF NOT EXISTS ${this.quoteIdentifier(schema)};`;\n  }\n\n  dropSchemaQuery(schema) {\n    return `DROP SCHEMA IF EXISTS ${this.quoteIdentifier(schema)} CASCADE;`;\n  }\n\n  createTableQuery(tableName, attributes, options) {\n    if (options) {\n      rejectInvalidOptions(\n        'createTableQuery',\n        this.dialect.name,\n        CREATE_TABLE_QUERY_SUPPORTABLE_OPTIONS,\n        CREATE_TABLE_QUERY_SUPPORTED_OPTIONS,\n        options,\n      );\n    }\n\n    options = { ...options };\n\n    const attrStr = [];\n    let comments = '';\n    let columnComments = '';\n\n    const quotedTable = this.quoteTable(tableName);\n\n    if (options.comment && typeof options.comment === 'string') {\n      comments += `; COMMENT ON TABLE ${quotedTable} IS ${this.escape(options.comment)}`;\n    }\n\n    for (const attr in attributes) {\n      const quotedAttr = this.quoteIdentifier(attr);\n      const i = attributes[attr].indexOf('COMMENT ');\n      if (i !== -1) {\n        // Move comment to a separate query\n        const escapedCommentText = this.escape(attributes[attr].slice(Math.max(0, i + 8)));\n        columnComments += `; COMMENT ON COLUMN ${quotedTable}.${quotedAttr} IS ${escapedCommentText}`;\n        attributes[attr] = attributes[attr].slice(0, Math.max(0, i));\n      }\n\n      const dataType = this.dataTypeMapping(tableName, attr, attributes[attr]);\n      attrStr.push(`${quotedAttr} ${dataType}`);\n    }\n\n    let attributesClause = attrStr.join(', ');\n\n    if (options.uniqueKeys) {\n      each(options.uniqueKeys, (index, indexName) => {\n        if (typeof indexName !== 'string') {\n          indexName = generateIndexName(tableName, index);\n        }\n\n        attributesClause += `, CONSTRAINT ${\n          this.quoteIdentifier(indexName)\n        } UNIQUE (${\n          index.fields.map(field => this.quoteIdentifier(field))\n            .join(', ')\n        })`;\n      });\n    }\n\n    const pks = reduce(attributes, (acc, attribute, key) => {\n      if (attribute.includes('PRIMARY KEY')) {\n        acc.push(this.quoteIdentifier(key));\n      }\n\n      return acc;\n    }, []).join(', ');\n\n    if (pks.length > 0) {\n      attributesClause += `, PRIMARY KEY (${pks})`;\n    }\n\n    return `CREATE TABLE IF NOT EXISTS ${quotedTable} (${attributesClause})${comments}${columnComments};`;\n  }\n\n  addColumnQuery(table, key, attribute, options) {\n    options = options || {};\n\n    const dbDataType = this.attributeToSQL(attribute, { context: 'addColumn', table, key });\n    const dataType = attribute.type || attribute;\n    const definition = this.dataTypeMapping(table, key, dbDataType);\n    const quotedKey = this.quoteIdentifier(key);\n    const quotedTable = this.quoteTable(table);\n    const ifNotExists = options.ifNotExists ? ' IF NOT EXISTS' : '';\n\n    let query = `ALTER TABLE ${quotedTable} ADD COLUMN ${ifNotExists} ${quotedKey} ${definition};`;\n\n    if (dataType instanceof DataTypes.ENUM) {\n      query = this.pgEnum(table, key, dataType) + query;\n    } else if (dataType instanceof DataTypes.ARRAY && dataType.options.type instanceof DataTypes.ENUM) {\n      query = this.pgEnum(table, key, dataType.options.type) + query;\n    }\n\n    return query;\n  }\n\n  changeColumnQuery(tableName, attributes) {\n    const query = subQuery => `ALTER TABLE ${this.quoteTable(tableName)} ALTER COLUMN ${subQuery};`;\n    const sql = [];\n    for (const attributeName in attributes) {\n      let definition = this.dataTypeMapping(tableName, attributeName, attributes[attributeName]);\n      let attrSql = '';\n\n      if (definition.includes('NOT NULL')) {\n        attrSql += query(`${this.quoteIdentifier(attributeName)} SET NOT NULL`);\n\n        definition = definition.replace('NOT NULL', '').trim();\n      } else if (!definition.includes('REFERENCES')) {\n        attrSql += query(`${this.quoteIdentifier(attributeName)} DROP NOT NULL`);\n      }\n\n      if (definition.includes('DEFAULT')) {\n        attrSql += query(`${this.quoteIdentifier(attributeName)} SET DEFAULT ${definition.match(/DEFAULT ([^;]+)/)[1]}`);\n\n        definition = definition.replace(/(DEFAULT[^;]+)/, '').trim();\n      } else if (!definition.includes('REFERENCES')) {\n        attrSql += query(`${this.quoteIdentifier(attributeName)} DROP DEFAULT`);\n      }\n\n      if (attributes[attributeName].startsWith('ENUM(')) {\n        attrSql += this.pgEnum(tableName, attributeName, attributes[attributeName]);\n        definition = definition.replace(/^ENUM\\(.+\\)/, this.pgEnumName(tableName, attributeName, { schema: false }));\n        definition += ` USING (${this.quoteIdentifier(attributeName)}::${this.pgEnumName(tableName, attributeName)})`;\n      }\n\n      if (/UNIQUE;*$/.test(definition)) {\n        definition = definition.replace(/UNIQUE;*$/, '');\n        attrSql += query(`ADD UNIQUE (${this.quoteIdentifier(attributeName)})`).replace('ALTER COLUMN', '');\n      }\n\n      if (definition.includes('REFERENCES')) {\n        definition = definition.replace(/.+?(?=REFERENCES)/, '');\n        attrSql += query(`ADD FOREIGN KEY (${this.quoteIdentifier(attributeName)}) ${definition}`).replace('ALTER COLUMN', '');\n      } else {\n        attrSql += query(`${this.quoteIdentifier(attributeName)} TYPE ${definition}`);\n      }\n\n      sql.push(attrSql);\n    }\n\n    return sql.join('');\n  }\n\n  renameColumnQuery(tableName, attrBefore, attributes) {\n\n    const attrString = [];\n\n    for (const attributeName in attributes) {\n      attrString.push(`${this.quoteIdentifier(attrBefore)} TO ${this.quoteIdentifier(attributeName)}`);\n    }\n\n    return `ALTER TABLE ${this.quoteTable(tableName)} RENAME COLUMN ${attrString.join(', ')};`;\n  }\n\n  fn(fnName, tableName, parameters, body, returns, language) {\n    fnName = fnName || 'testfunc';\n    language = language || 'plpgsql';\n    returns = returns ? `RETURNS ${returns}` : '';\n    parameters = parameters || '';\n\n    return `CREATE OR REPLACE FUNCTION pg_temp.${fnName}(${parameters}) ${returns} AS $func$ BEGIN ${body} END; $func$ LANGUAGE ${language}; SELECT * FROM pg_temp.${fnName}();`;\n  }\n\n  truncateTableQuery(tableName, options = {}) {\n    return [\n      `TRUNCATE ${this.quoteTable(tableName)}`,\n      options.restartIdentity ? ' RESTART IDENTITY' : '',\n      options.cascade ? ' CASCADE' : '',\n    ].join('');\n  }\n\n  deleteQuery(tableName, where, options = EMPTY_OBJECT, model) {\n    const table = this.quoteTable(tableName);\n\n    const escapeOptions = {\n      replacements: options.replacements,\n      model,\n    };\n\n    const limit = options.limit ? ` LIMIT ${this.escape(options.limit, escapeOptions)}` : '';\n    let primaryKeys = '';\n    let primaryKeysSelection = '';\n\n    let whereClause = this.whereQuery(where, { ...options, model });\n    if (whereClause) {\n      whereClause = ` ${whereClause}`;\n    }\n\n    if (options.limit) {\n      if (!model) {\n        throw new Error('Cannot LIMIT delete without a model.');\n      }\n\n      const pks = Object.values(model.primaryKeys).map(pk => this.quoteIdentifier(pk.field)).join(',');\n\n      primaryKeys = model.primaryKeyAttributes.length > 1 ? `(${pks})` : pks;\n      primaryKeysSelection = pks;\n\n      return `DELETE FROM ${table} WHERE ${primaryKeys} IN (SELECT ${primaryKeysSelection} FROM ${table}${whereClause}${limit})`;\n    }\n\n    return `DELETE FROM ${table}${whereClause}`;\n  }\n\n  addLimitAndOffset(options) {\n    let fragment = '';\n    if (options.limit != null) {\n      fragment += ` LIMIT ${this.escape(options.limit, options)}`;\n    }\n\n    if (options.offset) {\n      fragment += ` OFFSET ${this.escape(options.offset, options)}`;\n    }\n\n    return fragment;\n  }\n\n  attributeToSQL(attribute, options) {\n    if (!isPlainObject(attribute)) {\n      attribute = {\n        type: attribute,\n      };\n    }\n\n    let type;\n    if (\n      attribute.type instanceof DataTypes.ENUM\n      || attribute.type instanceof DataTypes.ARRAY && attribute.type.type instanceof DataTypes.ENUM\n    ) {\n      const enumType = attribute.type.type || attribute.type;\n      const values = enumType.options.values;\n\n      if (Array.isArray(values) && values.length > 0) {\n        type = `ENUM(${values.map(value => this.escape(value)).join(', ')})`;\n\n        if (attribute.type instanceof DataTypes.ARRAY) {\n          type += '[]';\n        }\n\n      } else {\n        throw new Error('Values for ENUM haven\\'t been defined.');\n      }\n    }\n\n    if (!type) {\n      type = attribute.type;\n    }\n\n    let sql = type.toString();\n\n    if (attribute.allowNull === false) {\n      sql += ' NOT NULL';\n    }\n\n    if (attribute.autoIncrement) {\n      if (attribute.autoIncrementIdentity) {\n        sql += ' GENERATED BY DEFAULT AS IDENTITY';\n      } else {\n        sql += ' SERIAL';\n      }\n    }\n\n    if (defaultValueSchemable(attribute.defaultValue)) {\n      sql += ` DEFAULT ${this.escape(attribute.defaultValue, { type: attribute.type })}`;\n    }\n\n    if (attribute.unique === true) {\n      sql += ' UNIQUE';\n    }\n\n    if (attribute.primaryKey) {\n      sql += ' PRIMARY KEY';\n    }\n\n    if (attribute.references) {\n      let schema;\n\n      if (options.schema) {\n        schema = options.schema;\n      } else if (\n        (!attribute.references.table || typeof attribute.references.table === 'string')\n        && options.table\n        && options.table.schema\n      ) {\n        schema = options.table.schema;\n      }\n\n      const referencesTable = this.extractTableDetails(attribute.references.table, { schema });\n\n      let referencesKey;\n\n      if (!options.withoutForeignKeyConstraints) {\n        if (attribute.references.key) {\n          referencesKey = this.quoteIdentifiers(attribute.references.key);\n        } else {\n          referencesKey = this.quoteIdentifier('id');\n        }\n\n        sql += ` REFERENCES ${this.quoteTable(referencesTable)} (${referencesKey})`;\n\n        if (attribute.onDelete) {\n          sql += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;\n        }\n\n        if (attribute.onUpdate) {\n          sql += ` ON UPDATE ${attribute.onUpdate.toUpperCase()}`;\n        }\n\n        if (attribute.references.deferrable) {\n          sql += ` ${this._getDeferrableConstraintSnippet(attribute.references.deferrable)}`;\n        }\n      }\n    }\n\n    if (attribute.comment && typeof attribute.comment === 'string') {\n      if (options && ['addColumn', 'changeColumn'].includes(options.context)) {\n        const quotedAttr = this.quoteIdentifier(options.key);\n        const escapedCommentText = this.escape(attribute.comment);\n        sql += `; COMMENT ON COLUMN ${this.quoteTable(options.table)}.${quotedAttr} IS ${escapedCommentText}`;\n      } else {\n        // for createTable event which does it's own parsing\n        // TODO: centralize creation of comment statements here\n        sql += ` COMMENT ${attribute.comment}`;\n      }\n    }\n\n    return sql;\n  }\n\n  attributesToSQL(attributes, options) {\n    const result = {};\n\n    for (const key in attributes) {\n      const attribute = attributes[key];\n      result[attribute.field || key] = this.attributeToSQL(attribute, { key, ...options });\n    }\n\n    return result;\n  }\n\n  createTrigger(tableName, triggerName, eventType, fireOnSpec, functionName, functionParams, optionsArray) {\n    const decodedEventType = this.decodeTriggerEventType(eventType);\n    const eventSpec = this.expandTriggerEventSpec(fireOnSpec);\n    const expandedOptions = this.expandOptions(optionsArray);\n    const paramList = this._expandFunctionParamList(functionParams);\n\n    return `CREATE ${this.triggerEventTypeIsConstraint(eventType)}TRIGGER ${this.quoteIdentifier(triggerName)} ${decodedEventType} ${\n      eventSpec} ON ${this.quoteTable(tableName)}${expandedOptions ? ` ${expandedOptions}` : ''} EXECUTE PROCEDURE ${functionName}(${paramList});`;\n  }\n\n  dropTrigger(tableName, triggerName) {\n    return `DROP TRIGGER ${this.quoteIdentifier(triggerName)} ON ${this.quoteTable(tableName)} RESTRICT;`;\n  }\n\n  renameTrigger(tableName, oldTriggerName, newTriggerName) {\n    return `ALTER TRIGGER ${this.quoteIdentifier(oldTriggerName)} ON ${this.quoteTable(tableName)} RENAME TO ${this.quoteIdentifier(newTriggerName)};`;\n  }\n\n  createFunction(functionName, params, returnType, language, body, optionsArray, options) {\n    if (!functionName || !returnType || !language || !body) {\n      throw new Error('createFunction missing some parameters. Did you pass functionName, returnType, language and body?');\n    }\n\n    const paramList = this._expandFunctionParamList(params);\n    const variableList = options && options.variables ? this._expandFunctionVariableList(options.variables) : '';\n    const expandedOptionsArray = this.expandOptions(optionsArray);\n\n    const statement = options && options.force ? 'CREATE OR REPLACE FUNCTION' : 'CREATE FUNCTION';\n\n    return `${statement} ${functionName}(${paramList}) RETURNS ${returnType} AS $func$ ${variableList} BEGIN ${body} END; $func$ language '${language}'${expandedOptionsArray};`;\n  }\n\n  dropFunction(functionName, params) {\n    if (!functionName) {\n      throw new Error('requires functionName');\n    }\n\n    // RESTRICT is (currently, as of 9.2) default but we'll be explicit\n    const paramList = this._expandFunctionParamList(params);\n\n    return `DROP FUNCTION ${functionName}(${paramList}) RESTRICT;`;\n  }\n\n  renameFunction(oldFunctionName, params, newFunctionName) {\n    const paramList = this._expandFunctionParamList(params);\n\n    return `ALTER FUNCTION ${oldFunctionName}(${paramList}) RENAME TO ${newFunctionName};`;\n  }\n\n  _expandFunctionParamList(params) {\n    if (params === undefined || !Array.isArray(params)) {\n      throw new Error('_expandFunctionParamList: function parameters array required, including an empty one for no arguments');\n    }\n\n    const paramList = [];\n    for (const curParam of params) {\n      const paramDef = [];\n      if (curParam.type) {\n        if (curParam.direction) {\n          paramDef.push(curParam.direction);\n        }\n\n        if (curParam.name) {\n          paramDef.push(curParam.name);\n        }\n\n        paramDef.push(curParam.type);\n      } else {\n        throw new Error('function or trigger used with a parameter without any type');\n      }\n\n      const joined = paramDef.join(' ');\n      if (joined) {\n        paramList.push(joined);\n      }\n\n    }\n\n    return paramList.join(', ');\n  }\n\n  _expandFunctionVariableList(variables) {\n    if (!Array.isArray(variables)) {\n      throw new TypeError('_expandFunctionVariableList: function variables must be an array');\n    }\n\n    const variableDefinitions = [];\n    for (const variable of variables) {\n      if (!variable.name || !variable.type) {\n        throw new Error('function variable must have a name and type');\n      }\n\n      let variableDefinition = `DECLARE ${variable.name} ${variable.type}`;\n      if (variable.default) {\n        variableDefinition += ` := ${variable.default}`;\n      }\n\n      variableDefinition += ';';\n      variableDefinitions.push(variableDefinition);\n    }\n\n    return variableDefinitions.join(' ');\n  }\n\n  expandOptions(options) {\n    return options === undefined || isEmpty(options)\n      ? '' : options.join(' ');\n  }\n\n  decodeTriggerEventType(eventSpecifier) {\n    const EVENT_DECODER = {\n      after: 'AFTER',\n      before: 'BEFORE',\n      instead_of: 'INSTEAD OF',\n      after_constraint: 'AFTER',\n    };\n\n    if (!EVENT_DECODER[eventSpecifier]) {\n      throw new Error(`Invalid trigger event specified: ${eventSpecifier}`);\n    }\n\n    return EVENT_DECODER[eventSpecifier];\n  }\n\n  triggerEventTypeIsConstraint(eventSpecifier) {\n    return eventSpecifier === 'after_constraint' ? 'CONSTRAINT ' : '';\n  }\n\n  expandTriggerEventSpec(fireOnSpec) {\n    if (isEmpty(fireOnSpec)) {\n      throw new Error('no table change events specified to trigger on');\n    }\n\n    return map(fireOnSpec, (fireValue, fireKey) => {\n      const EVENT_MAP = {\n        insert: 'INSERT',\n        update: 'UPDATE',\n        delete: 'DELETE',\n        truncate: 'TRUNCATE',\n      };\n\n      if (!EVENT_MAP[fireValue]) {\n        throw new Error(`parseTriggerEventSpec: undefined trigger event ${fireKey}`);\n      }\n\n      let eventSpec = EVENT_MAP[fireValue];\n      if (eventSpec === 'UPDATE' && Array.isArray(fireValue) && fireValue.length > 0) {\n        eventSpec += ` OF ${fireValue.join(', ')}`;\n      }\n\n      return eventSpec;\n    }).join(' OR ');\n  }\n\n  pgEnumName(tableName, columnName, options = {}) {\n    const tableDetails = this.extractTableDetails(tableName, options);\n\n    const enumName = `enum_${tableDetails.tableName}_${columnName}`;\n    if (options.noEscape) {\n      return enumName;\n    }\n\n    const escapedEnumName = this.quoteIdentifier(enumName);\n\n    if (options.schema !== false && tableDetails.schema) {\n      return this.quoteIdentifier(tableDetails.schema) + tableDetails.delimiter + escapedEnumName;\n    }\n\n    return escapedEnumName;\n  }\n\n  pgListEnums(tableName, attrName, options) {\n    let enumName = '';\n    const tableDetails = tableName != null\n      ? this.extractTableDetails(tableName, options)\n      : { schema: this.options.schema || this.dialect.getDefaultSchema() };\n\n    if (tableDetails.tableName && attrName) {\n      // pgEnumName escapes as an identifier, we want to escape it as a string\n      enumName = ` AND t.typname=${this.escape(this.pgEnumName(tableDetails.tableName, attrName, { noEscape: true }))}`;\n    }\n\n    return 'SELECT t.typname enum_name, array_agg(e.enumlabel ORDER BY enumsortorder) enum_value FROM pg_type t '\n      + 'JOIN pg_enum e ON t.oid = e.enumtypid '\n      + 'JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace '\n      + `WHERE n.nspname = ${this.escape(tableDetails.schema)}${enumName} GROUP BY 1`;\n  }\n\n  pgEnum(tableName, attr, dataType, options) {\n    const enumName = this.pgEnumName(tableName, attr, options);\n    let values;\n\n    if (dataType instanceof ENUM && dataType.options.values) {\n      values = `ENUM(${dataType.options.values.map(value => this.escape(value)).join(', ')})`;\n    } else {\n      values = dataType.toString().match(/^ENUM\\(.+\\)/)[0];\n    }\n\n    let sql = `DO ${this.escape(`BEGIN CREATE TYPE ${enumName} AS ${values}; EXCEPTION WHEN duplicate_object THEN null; END`)};`;\n    if (Boolean(options) && options.force === true) {\n      sql = this.pgEnumDrop(tableName, attr) + sql;\n    }\n\n    return sql;\n  }\n\n  pgEnumAdd(tableName, attr, value, options) {\n    const enumName = this.pgEnumName(tableName, attr);\n    let sql = `ALTER TYPE ${enumName} ADD VALUE IF NOT EXISTS `;\n\n    sql += this.escape(value);\n\n    if (options.before) {\n      sql += ` BEFORE ${this.escape(options.before)}`;\n    } else if (options.after) {\n      sql += ` AFTER ${this.escape(options.after)}`;\n    }\n\n    return sql;\n  }\n\n  pgEnumDrop(tableName, attr, enumName) {\n    enumName = enumName || this.pgEnumName(tableName, attr);\n\n    return `DROP TYPE IF EXISTS ${enumName}; `;\n  }\n\n  fromArray(text) {\n    if (Array.isArray(text)) {\n      return text;\n    }\n\n    text = text.replace(/^{/, '').replace(/}$/, '');\n    let matches = text.match(/(\"(?:\\\\.|[^\"\\\\])*\"|[^,]*)(?:\\s*,\\s*|\\s*$)/gi);\n\n    if (matches.length === 0) {\n      return [];\n    }\n\n    matches = matches.map(m => m.replace(/\",$/, '').replace(/,$/, '').replaceAll(/(^\"|\"$)/g, ''));\n\n    return matches.slice(0, -1);\n  }\n\n  dataTypeMapping(tableName, attr, dataType) {\n    if (dataType.includes('PRIMARY KEY')) {\n      dataType = dataType.replace('PRIMARY KEY', '');\n    }\n\n    if (dataType.includes('SERIAL')) {\n      if (dataType.includes('BIGINT')) {\n        dataType = dataType.replace('SERIAL', 'BIGSERIAL');\n        dataType = dataType.replace('BIGINT', '');\n      } else if (dataType.includes('SMALLINT')) {\n        dataType = dataType.replace('SERIAL', 'SMALLSERIAL');\n        dataType = dataType.replace('SMALLINT', '');\n      } else {\n        dataType = dataType.replace('INTEGER', '');\n      }\n\n      dataType = dataType.replace('NOT NULL', '');\n    }\n\n    if (dataType.startsWith('ENUM(')) {\n      dataType = dataType.replace(/^ENUM\\(.+\\)/, this.pgEnumName(tableName, attr));\n    }\n\n    return dataType;\n  }\n\n  /**\n   * Quote identifier in sql clause\n   *\n   * @param {string} identifier\n   * @param {boolean} force\n   *\n   * @returns {string}\n   */\n  quoteIdentifier(identifier, force) {\n    const optForceQuote = force || false;\n    // TODO [>7]: remove \"quoteIdentifiers: false\" option\n    const optQuoteIdentifiers = this.options.quoteIdentifiers !== false;\n\n    if (\n      optForceQuote === true\n      // TODO [>7]: drop this.options.quoteIdentifiers. Always quote identifiers based on these rules\n      || optQuoteIdentifiers !== false\n      || identifier.includes('.')\n      || identifier.includes('->')\n      || POSTGRES_RESERVED_WORDS.includes(identifier.toLowerCase())\n    ) {\n      // In Postgres if tables or attributes are created double-quoted,\n      // they are also case sensitive. If they contain any uppercase\n      // characters, they must always be double-quoted. This makes it\n      // impossible to write queries in portable SQL if tables are created in\n      // this way. Hence, we strip quotes if we don't want case sensitivity.\n      return quoteIdentifier(identifier, this.dialect.TICK_CHAR_LEFT, this.dialect.TICK_CHAR_RIGHT);\n    }\n\n    return identifier;\n  }\n}\n"],
  "mappings": "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",
  "names": ["each", "reduce", "isPlainObject", "isEmpty", "map"]
}
