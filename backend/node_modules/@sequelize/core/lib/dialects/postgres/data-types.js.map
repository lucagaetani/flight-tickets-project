{
  "version": 3,
  "sources": ["../../../src/dialects/postgres/data-types.ts"],
  "sourcesContent": ["import assert from 'node:assert';\nimport wkx from 'wkx';\nimport type { Rangable } from '../../model.js';\nimport { isBigInt, isNumber, isString } from '../../utils/check.js';\nimport * as BaseTypes from '../abstract/data-types';\nimport type { AbstractDataType, AcceptableTypeOf, AcceptedDate, BindParamOptions } from '../abstract/data-types';\nimport { attributeTypeToSql } from '../abstract/data-types-utils.js';\nimport type { AbstractDialect } from '../abstract/index.js';\nimport * as Hstore from './hstore';\nimport { PostgresQueryGenerator } from './query-generator';\nimport * as RangeParser from './range';\n\nfunction removeUnsupportedIntegerOptions(dataType: BaseTypes.BaseIntegerDataType, dialect: AbstractDialect) {\n  if (dataType.options.length != null) {\n    // this option only makes sense for zerofill\n    dialect.warnDataTypeIssue(`${dialect.name} does not support ${dataType.getDataTypeId()} with length specified. This options is ignored.`);\n\n    delete dataType.options.length;\n  }\n}\n\nexport class DATEONLY extends BaseTypes.DATEONLY {\n  toBindableValue(value: AcceptableTypeOf<BaseTypes.DATEONLY>) {\n    if (value === Number.POSITIVE_INFINITY) {\n      return 'infinity';\n    }\n\n    if (value === Number.NEGATIVE_INFINITY) {\n      return '-infinity';\n    }\n\n    return super.toBindableValue(value);\n  }\n\n  sanitize(value: unknown): unknown {\n    if (value === Number.POSITIVE_INFINITY\n      || value === Number.NEGATIVE_INFINITY) {\n      return value;\n    }\n\n    if (typeof value === 'string') {\n      const lower = value.toLowerCase();\n      if (lower === 'infinity') {\n        return Number.POSITIVE_INFINITY;\n      }\n\n      if (lower === '-infinity') {\n        return Number.NEGATIVE_INFINITY;\n      }\n    }\n\n    return super.sanitize(value);\n  }\n\n}\n\nexport class DECIMAL extends BaseTypes.DECIMAL {\n  // TODO: add check constraint >= 0 if unsigned is true\n}\n\nexport class TEXT extends BaseTypes.TEXT {\n  protected _checkOptionSupport(dialect: AbstractDialect) {\n    super._checkOptionSupport(dialect);\n\n    if (this.options.length) {\n      dialect.warnDataTypeIssue(\n        `${dialect.name} does not support TEXT with options. Plain TEXT will be used instead.`,\n      );\n\n      this.options.length = undefined;\n    }\n  }\n}\n\nexport class DATE extends BaseTypes.DATE {\n  toSql() {\n    if (this.options.precision != null) {\n      return `TIMESTAMP(${this.options.precision}) WITH TIME ZONE`;\n    }\n\n    return 'TIMESTAMP WITH TIME ZONE';\n  }\n\n  validate(value: any) {\n    if (value === Number.POSITIVE_INFINITY\n      || value === Number.NEGATIVE_INFINITY) {\n      // valid\n      return;\n    }\n\n    super.validate(value);\n  }\n\n  toBindableValue(value: AcceptedDate): string {\n    if (value === Number.POSITIVE_INFINITY) {\n      return 'infinity';\n    }\n\n    if (value === Number.NEGATIVE_INFINITY) {\n      return '-infinity';\n    }\n\n    return super.toBindableValue(value);\n  }\n\n  sanitize(value: unknown) {\n    if (value == null) {\n      return value;\n    }\n\n    if (value === Number.POSITIVE_INFINITY || value === Number.NEGATIVE_INFINITY) {\n      return value;\n    }\n\n    if (value instanceof Date) {\n      return value;\n    }\n\n    if (typeof value === 'string') {\n      const lower = value.toLowerCase();\n      if (lower === 'infinity') {\n        return Number.POSITIVE_INFINITY;\n      }\n\n      if (lower === '-infinity') {\n        return Number.NEGATIVE_INFINITY;\n      }\n    }\n\n    return super.sanitize(value);\n  }\n}\n\nexport class TINYINT extends BaseTypes.TINYINT {\n  protected _checkOptionSupport(dialect: AbstractDialect) {\n    super._checkOptionSupport(dialect);\n    removeUnsupportedIntegerOptions(this, dialect);\n  }\n\n  // TODO: add >= 0 =< 2^8-1 check when the unsigned option is true\n  // TODO: add >= -2^7 =< 2^7-1 check when the unsigned option is false\n\n  toSql(): string {\n    return 'SMALLINT';\n  }\n}\n\nexport class SMALLINT extends BaseTypes.SMALLINT {\n  protected _checkOptionSupport(dialect: AbstractDialect) {\n    super._checkOptionSupport(dialect);\n    removeUnsupportedIntegerOptions(this, dialect);\n  }\n\n  // TODO: add >= 0 =< 2^16-1 check when the unsigned option is true\n\n  toSql(): string {\n    if (this.options.unsigned) {\n      return 'INTEGER';\n    }\n\n    return 'SMALLINT';\n  }\n}\n\nexport class MEDIUMINT extends BaseTypes.MEDIUMINT {\n  protected _checkOptionSupport(dialect: AbstractDialect) {\n    super._checkOptionSupport(dialect);\n    removeUnsupportedIntegerOptions(this, dialect);\n  }\n\n  // TODO: add >= 0 =< 2^24-1 check when the unsigned option is true\n  // TODO: add >= -2^23 =< 2^23-1 check when the unsigned option is false\n\n  toSql(): string {\n    return 'INTEGER';\n  }\n}\n\nexport class INTEGER extends BaseTypes.INTEGER {\n  protected _checkOptionSupport(dialect: AbstractDialect) {\n    super._checkOptionSupport(dialect);\n    removeUnsupportedIntegerOptions(this, dialect);\n  }\n\n  // TODO: add >= 0 =< 2^32-1 check when the unsigned option is true\n\n  toSql(): string {\n    if (this.options.unsigned) {\n      return 'BIGINT';\n    }\n\n    return 'INTEGER';\n  }\n}\n\nexport class BIGINT extends BaseTypes.BIGINT {\n  protected _checkOptionSupport(dialect: AbstractDialect) {\n    super._checkOptionSupport(dialect);\n    removeUnsupportedIntegerOptions(this, dialect);\n  }\n}\n\nexport class DOUBLE extends BaseTypes.DOUBLE {\n  // TODO: add check constraint >= 0 if unsigned is true\n}\n\nexport class FLOAT extends BaseTypes.FLOAT {\n  // TODO: add check constraint >= 0 if unsigned is true\n\n  protected getNumberSqlTypeName(): string {\n    // REAL is postgres' single precision float. FLOAT(p) is an alias for either REAL of DOUBLE PRECISION based on (p).\n    return 'REAL';\n  }\n}\n\nexport class BLOB extends BaseTypes.BLOB {\n  protected _checkOptionSupport(dialect: AbstractDialect) {\n    super._checkOptionSupport(dialect);\n\n    if (this.options.length) {\n      dialect.warnDataTypeIssue(\n        `${dialect.name} does not support BLOB (BYTEA) with options. Plain BYTEA will be used instead.`,\n      );\n      this.options.length = undefined;\n    }\n  }\n\n  toSql() {\n    return 'BYTEA';\n  }\n}\n\nexport class GEOMETRY extends BaseTypes.GEOMETRY {\n  toSql() {\n    let result = 'GEOMETRY';\n    if (this.options.type) {\n      result += `(${this.options.type.toUpperCase()}`;\n      if (this.options.srid) {\n        result += `,${this.options.srid}`;\n      }\n\n      result += ')';\n    }\n\n    return result;\n  }\n\n  parse(value: string) {\n    const b = Buffer.from(value, 'hex');\n\n    return wkx.Geometry.parse(b).toGeoJSON({ shortCrs: true });\n  }\n\n  toBindableValue(value: AcceptableTypeOf<BaseTypes.GEOMETRY>): string {\n    return `ST_GeomFromGeoJSON(${this._getDialect().escapeString(JSON.stringify(value))})`;\n  }\n\n  getBindParamSql(value: AcceptableTypeOf<BaseTypes.GEOMETRY>, options: BindParamOptions) {\n    return `ST_GeomFromGeoJSON(${options.bindParam(value)})`;\n  }\n}\n\nexport class GEOGRAPHY extends BaseTypes.GEOGRAPHY {\n  toSql() {\n    let result = 'GEOGRAPHY';\n    if (this.options.type) {\n      result += `(${this.options.type}`;\n      if (this.options.srid) {\n        result += `,${this.options.srid}`;\n      }\n\n      result += ')';\n    }\n\n    return result;\n  }\n\n  toBindableValue(value: AcceptableTypeOf<BaseTypes.GEOGRAPHY>) {\n    return `ST_GeomFromGeoJSON(${this._getDialect().escapeString(JSON.stringify(value))})`;\n  }\n\n  getBindParamSql(value: AcceptableTypeOf<BaseTypes.GEOGRAPHY>, options: BindParamOptions) {\n    return `ST_GeomFromGeoJSON(${options.bindParam(value)})`;\n  }\n}\n\nexport class HSTORE extends BaseTypes.HSTORE {\n  toBindableValue(value: AcceptableTypeOf<BaseTypes.HSTORE>): string {\n    if (value == null) {\n      return value;\n    }\n\n    return Hstore.stringify(value);\n  }\n}\n\nexport class RANGE<T extends BaseTypes.BaseNumberDataType | DATE | DATEONLY = INTEGER> extends BaseTypes.RANGE<T> {\n  toBindableValue(values: Rangable<AcceptableTypeOf<T>>): string {\n    if (!Array.isArray(values)) {\n      throw new TypeError('Range values must be an array');\n    }\n\n    return RangeParser.stringify(values, rangePart => {\n      let out = this.options.subtype.toBindableValue(rangePart);\n\n      if (isNumber(out) || isBigInt(out)) {\n        out = String(out);\n      }\n\n      if (!isString(out)) {\n        throw new Error('DataTypes.RANGE only accepts types that are represented by either strings, numbers or bigints.');\n      }\n\n      return out;\n    });\n  }\n\n  escape(values: Rangable<AcceptableTypeOf<T>>): string {\n    const value = this.toBindableValue(values);\n    const dialect = this._getDialect();\n\n    return `${dialect.escapeString(value)}::${this.toSql()}`;\n  }\n\n  getBindParamSql(\n    values: Rangable<AcceptableTypeOf<T>>,\n    options: BindParamOptions,\n  ): string {\n    const value = this.toBindableValue(values);\n\n    return `${options.bindParam(value)}::${this.toSql()}`;\n  }\n\n  toSql() {\n    const subTypeClass = this.options.subtype.constructor as typeof BaseTypes.AbstractDataType;\n\n    return RANGE.typeMap[subTypeClass.getDataTypeId().toLowerCase()];\n  }\n\n  static typeMap: Record<string, string> = {\n    integer: 'int4range',\n    decimal: 'numrange',\n    date: 'tstzrange',\n    dateonly: 'daterange',\n    bigint: 'int8range',\n  };\n}\n\nexport class ARRAY<T extends BaseTypes.AbstractDataType<any>> extends BaseTypes.ARRAY<T> {\n  escape(values: Array<AcceptableTypeOf<T>>) {\n    const type = this.options.type;\n\n    const mappedValues = isString(type) ? values : values.map(value => type.escape(value));\n\n    // Types that don't need to specify their cast\n    const unambiguousType = type instanceof BaseTypes.TEXT\n      || type instanceof BaseTypes.INTEGER;\n\n    const cast = mappedValues.length === 0 || !unambiguousType ? `::${attributeTypeToSql(type)}[]` : '';\n\n    return `ARRAY[${mappedValues.join(',')}]${cast}`;\n  }\n\n  getBindParamSql(\n    values: Array<AcceptableTypeOf<T>>,\n    options: BindParamOptions,\n  ) {\n    if (isString(this.options.type)) {\n      return options.bindParam(values);\n    }\n\n    const subType: AbstractDataType<any> = this.options.type;\n\n    return options.bindParam(values.map((value: any) => {\n      return subType.toBindableValue(value);\n    }));\n  }\n}\n\nexport class ENUM<Members extends string> extends BaseTypes.ENUM<Members> {\n  override toSql(): string {\n    const context = this.usageContext;\n    if (context == null) {\n      throw new Error('Could not determine the name of this enum because it is not attached to an attribute or a column.');\n    }\n\n    let tableName;\n    let columnName;\n    if ('model' in context) {\n      tableName = context.model.getTableName();\n\n      const attribute = context.model.getAttributes()[context.attributeName];\n      columnName = attribute.field ?? context.attributeName;\n    } else {\n      tableName = context.tableName;\n      columnName = context.columnName;\n    }\n\n    const queryGenerator = context.sequelize.dialect.queryGenerator;\n\n    assert(queryGenerator instanceof PostgresQueryGenerator, 'expected queryGenerator to be PostgresQueryGenerator');\n\n    return queryGenerator.pgEnumName(tableName, columnName);\n  }\n}\n"],
  "mappings": "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",
  "names": ["wkx", "assert"]
}
