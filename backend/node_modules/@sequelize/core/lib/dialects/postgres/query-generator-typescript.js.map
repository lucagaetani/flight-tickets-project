{
  "version": 3,
  "sources": ["../../../src/dialects/postgres/query-generator-typescript.ts"],
  "sourcesContent": ["import type { Expression } from '../../sequelize.js';\nimport { joinSQLFragments } from '../../utils/join-sql-fragments';\nimport { generateIndexName } from '../../utils/string';\nimport { AbstractQueryGenerator } from '../abstract/query-generator';\nimport type { EscapeOptions, RemoveIndexQueryOptions, TableNameOrModel } from '../abstract/query-generator-typescript';\nimport type {\n  ListSchemasQueryOptions,\n  ListTablesQueryOptions,\n  ShowConstraintsQueryOptions,\n} from '../abstract/query-generator.types';\n\n/**\n * Temporary class to ease the TypeScript migration\n */\nexport class PostgresQueryGeneratorTypeScript extends AbstractQueryGenerator {\n  protected _getTechnicalSchemaNames() {\n    return ['information_schema', 'tiger', 'tiger_data', 'topology'];\n  }\n\n  listSchemasQuery(options?: ListSchemasQueryOptions) {\n    const schemasToSkip = ['public', ...this._getTechnicalSchemaNames()];\n\n    if (options && Array.isArray(options?.skip)) {\n      schemasToSkip.push(...options.skip);\n    }\n\n    return joinSQLFragments([\n      `SELECT schema_name AS \"schema\" FROM information_schema.schemata`,\n      `WHERE schema_name !~ E'^pg_' AND schema_name NOT IN (${schemasToSkip.map(schema => this.escape(schema)).join(', ')})`]);\n  }\n\n  describeTableQuery(tableName: TableNameOrModel) {\n    const table = this.extractTableDetails(tableName);\n\n    return joinSQLFragments([\n      'SELECT',\n      'pk.constraint_type as \"Constraint\",',\n      'c.column_name as \"Field\",',\n      'c.column_default as \"Default\",',\n      'c.is_nullable as \"Null\",',\n      `(CASE WHEN c.udt_name = 'hstore' THEN c.udt_name ELSE c.data_type END) || (CASE WHEN c.character_maximum_length IS NOT NULL THEN '(' || c.character_maximum_length || ')' ELSE '' END) as \"Type\",`,\n      '(SELECT array_agg(e.enumlabel) FROM pg_catalog.pg_type t JOIN pg_catalog.pg_enum e ON t.oid=e.enumtypid WHERE t.typname=c.udt_name) AS \"special\",',\n      '(SELECT pgd.description FROM pg_catalog.pg_statio_all_tables AS st INNER JOIN pg_catalog.pg_description pgd on (pgd.objoid=st.relid) WHERE c.ordinal_position=pgd.objsubid AND c.table_name=st.relname) AS \"Comment\"',\n      'FROM information_schema.columns c',\n      'LEFT JOIN (SELECT tc.table_schema, tc.table_name,',\n      'cu.column_name, tc.constraint_type',\n      'FROM information_schema.TABLE_CONSTRAINTS tc',\n      'JOIN information_schema.KEY_COLUMN_USAGE  cu',\n      'ON tc.table_schema=cu.table_schema and tc.table_name=cu.table_name',\n      'and tc.constraint_name=cu.constraint_name',\n      `and tc.constraint_type='PRIMARY KEY') pk`,\n      'ON pk.table_schema=c.table_schema',\n      'AND pk.table_name=c.table_name',\n      'AND pk.column_name=c.column_name',\n      `WHERE c.table_name = ${this.escape(table.tableName)}`,\n      `AND c.table_schema = ${this.escape(table.schema!)}`,\n    ]);\n  }\n\n  listTablesQuery(options?: ListTablesQueryOptions) {\n    return joinSQLFragments([\n      'SELECT table_name AS \"tableName\", table_schema AS \"schema\"',\n      `FROM information_schema.tables WHERE table_type = 'BASE TABLE' AND table_name != 'spatial_ref_sys'`,\n      options?.schema\n        ? `AND table_schema = ${this.escape(options.schema)}`\n        : `AND table_schema !~ E'^pg_' AND table_schema NOT IN (${this._getTechnicalSchemaNames().map(schema => this.escape(schema)).join(', ')})`,\n      'ORDER BY table_schema, table_name',\n    ]);\n  }\n\n  showConstraintsQuery(tableName: TableNameOrModel, options?: ShowConstraintsQueryOptions) {\n    const table = this.extractTableDetails(tableName);\n\n    // Postgres converts camelCased alias to lowercase unless quoted\n    return joinSQLFragments([\n      'SELECT c.constraint_catalog AS \"constraintCatalog\",',\n      'c.constraint_schema AS \"constraintSchema\",',\n      'c.constraint_name AS \"constraintName\",',\n      'c.constraint_type AS \"constraintType\",',\n      'c.table_catalog AS \"tableCatalog\",',\n      'c.table_schema AS \"tableSchema\",',\n      'c.table_name AS \"tableName\",',\n      'kcu.column_name AS \"columnNames\",',\n      'ccu.table_schema AS \"referencedTableSchema\",',\n      'ccu.table_name AS \"referencedTableName\",',\n      'ccu.column_name AS \"referencedColumnNames\",',\n      'r.delete_rule AS \"deleteAction\",',\n      'r.update_rule AS \"updateAction\",',\n      'ch.check_clause AS \"definition\",',\n      'c.is_deferrable AS \"isDeferrable\",',\n      'c.initially_deferred AS \"initiallyDeferred\"',\n      'FROM INFORMATION_SCHEMA.table_constraints c',\n      'LEFT JOIN INFORMATION_SCHEMA.referential_constraints r ON c.constraint_catalog = r.constraint_catalog AND c.constraint_schema = r.constraint_schema AND c.constraint_name = r.constraint_name',\n      'LEFT JOIN INFORMATION_SCHEMA.key_column_usage kcu ON c.constraint_catalog = kcu.constraint_catalog AND c.constraint_schema = kcu.constraint_schema AND c.constraint_name = kcu.constraint_name',\n      'LEFT JOIN information_schema.constraint_column_usage AS ccu ON r.constraint_catalog = ccu.constraint_catalog AND r.constraint_schema = ccu.constraint_schema AND r.constraint_name = ccu.constraint_name',\n      'LEFT JOIN INFORMATION_SCHEMA.check_constraints ch ON c.constraint_catalog = ch.constraint_catalog AND c.constraint_schema = ch.constraint_schema AND c.constraint_name = ch.constraint_name',\n      `WHERE c.table_name = ${this.escape(table.tableName)}`,\n      `AND c.table_schema = ${this.escape(table.schema)}`,\n      options?.columnName ? `AND kcu.column_name = ${this.escape(options.columnName)}` : '',\n      options?.constraintName ? `AND c.constraint_name = ${this.escape(options.constraintName)}` : '',\n      options?.constraintType ? `AND c.constraint_type = ${this.escape(options.constraintType)}` : '',\n      'ORDER BY c.constraint_name, kcu.ordinal_position',\n    ]);\n  }\n\n  showIndexesQuery(tableName: TableNameOrModel) {\n    const table = this.extractTableDetails(tableName);\n\n    // TODO [>=6]: refactor the query to use pg_indexes\n    return joinSQLFragments([\n      'SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey[:ix.indnkeyatts-1] AS index_fields,',\n      'ix.indkey[ix.indnkeyatts:] AS include_fields, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names,',\n      'pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a , pg_namespace s',\n      'WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND',\n      `t.relkind = 'r' and t.relname = ${this.escape(table.tableName)}`,\n      `AND s.oid = t.relnamespace AND s.nspname = ${this.escape(table.schema)}`,\n      'GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey, ix.indnkeyatts ORDER BY i.relname;',\n    ]);\n  }\n\n  removeIndexQuery(\n    tableName: TableNameOrModel,\n    indexNameOrAttributes: string | string[],\n    options?: RemoveIndexQueryOptions,\n  ) {\n    if (options?.cascade && options?.concurrently) {\n      throw new Error(`Cannot specify both concurrently and cascade options in removeIndexQuery for ${this.dialect.name} dialect`);\n    }\n\n    let indexName;\n    const table = this.extractTableDetails(tableName);\n    if (Array.isArray(indexNameOrAttributes)) {\n      indexName = generateIndexName(table, { fields: indexNameOrAttributes });\n    } else {\n      indexName = indexNameOrAttributes;\n    }\n\n    return joinSQLFragments([\n      'DROP INDEX',\n      options?.concurrently ? 'CONCURRENTLY' : '',\n      options?.ifExists ? 'IF EXISTS' : '',\n      `${this.quoteIdentifier(table.schema!)}.${this.quoteIdentifier(indexName)}`,\n      options?.cascade ? 'CASCADE' : '',\n    ]);\n  }\n\n  jsonPathExtractionQuery(sqlExpression: string, path: ReadonlyArray<number | string>, unquote: boolean): string {\n    const operator = path.length === 1\n      ? (unquote ? '->>' : '->')\n      : (unquote ? '#>>' : '#>');\n\n    const pathSql = path.length === 1\n      // when accessing an array index with ->, the index must be a number\n      // when accessing an object key with ->, the key must be a string\n      ? this.escape(path[0])\n      // when accessing with #>, the path is always an array of strings\n      : this.escape(path.map(value => String(value)));\n\n    return sqlExpression + operator + pathSql;\n  }\n\n  formatUnquoteJson(arg: Expression, options?: EscapeOptions) {\n    return `${this.escape(arg, options)}#>>ARRAY[]::TEXT[]`;\n  }\n\n  versionQuery() {\n    return 'SHOW SERVER_VERSION';\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
