"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var query_interface_typescript_exports = {};
__export(query_interface_typescript_exports, {
  SqliteQueryInterfaceTypeScript: () => SqliteQueryInterfaceTypeScript
});
module.exports = __toCommonJS(query_interface_typescript_exports);
var import_errors = require("../../errors");
var import_query_types = require("../../query-types");
var import_query_interface = require("../abstract/query-interface");
var import_sqlite_utils = require("./sqlite-utils");
class SqliteQueryInterfaceTypeScript extends import_query_interface.AbstractQueryInterface {
  sequelize;
  queryGenerator;
  constructor(sequelize, queryGenerator) {
    super(sequelize, queryGenerator);
    this.sequelize = sequelize;
    this.queryGenerator = queryGenerator;
  }
  /**
   * Drop all tables
   *
   * @param options
   */
  async dropAllTables(options) {
    const skip = (options == null ? void 0 : options.skip) || [];
    const allTables = await this.showAllTables(options);
    const tableNames = allTables.filter((tableName) => !skip.includes(tableName.tableName));
    await (0, import_sqlite_utils.withSqliteForeignKeysOff)(this.sequelize, options, async () => {
      await Promise.all(tableNames.map(async (tableName) => this.dropTable(tableName, options)));
    });
  }
  async addConstraint(tableName, options) {
    if (!options.fields) {
      throw new Error("Fields must be specified through options.fields");
    }
    if (!options.type) {
      throw new Error("Constraint type must be specified through options.type");
    }
    const constraintOptions = { ...options };
    const constraintSnippet = this.queryGenerator._getConstraintSnippet(tableName, constraintOptions);
    const describeCreateTableSql = this.queryGenerator.describeCreateTableQuery(tableName);
    const describeCreateTable = await this.sequelize.queryRaw(describeCreateTableSql, {
      ...options,
      raw: true,
      type: import_query_types.QueryTypes.SELECT
    });
    if (!describeCreateTable.length || !("sql" in describeCreateTable[0])) {
      throw new Error("Unable to find constraints for table. Perhaps the table does not exist?");
    }
    let { sql: createTableSql } = describeCreateTable[0];
    createTableSql = createTableSql.replaceAll('"', "`").replace(/\);?$/, `, ${constraintSnippet})`);
    const fields = await this.describeTable(tableName, options);
    const sql = this.queryGenerator._replaceTableQuery(tableName, fields, createTableSql);
    const subQueries = sql.split(";").filter((q) => q !== "");
    for (const subQuery of subQueries) {
      await this.sequelize.queryRaw(`${subQuery};`, { ...options, raw: true });
    }
  }
  async removeConstraint(tableName, constraintName, options) {
    const describeCreateTableSql = this.queryGenerator.describeCreateTableQuery(tableName);
    const describeCreateTable = await this.sequelize.queryRaw(describeCreateTableSql, {
      ...options,
      raw: true,
      type: import_query_types.QueryTypes.SELECT
    });
    if (!describeCreateTable.length || !("sql" in describeCreateTable[0])) {
      throw new Error("Unable to find constraints for table. Perhaps the table does not exist?");
    }
    const { sql: createTableSql } = describeCreateTable[0];
    const constraints = await this.showConstraints(tableName, options);
    const constraint = constraints.find((c) => c.constraintName === constraintName);
    if (!constraint) {
      const table = this.queryGenerator.extractTableDetails(tableName);
      throw new import_errors.UnknownConstraintError({
        message: `Constraint ${constraintName} on table ${table.tableName} does not exist`,
        constraint: constraintName,
        table: table.tableName
      });
    }
    constraint.constraintName = this.queryGenerator.quoteIdentifier(constraint.constraintName);
    let constraintSnippet = `, CONSTRAINT ${constraint.constraintName} ${constraint.constraintType} ${constraint.definition}`;
    if (constraint.constraintType === "FOREIGN KEY") {
      constraintSnippet = `, CONSTRAINT ${constraint.constraintName} FOREIGN KEY`;
      const columns = constraint.columnNames.map((columnName) => this.queryGenerator.quoteIdentifier(columnName)).join(", ");
      const referenceTableName = this.queryGenerator.quoteTable(constraint.referencedTableName);
      const referenceTableColumns = constraint.referencedColumnNames.map((columnName) => this.queryGenerator.quoteIdentifier(columnName)).join(", ");
      constraintSnippet += ` (${columns})`;
      constraintSnippet += ` REFERENCES ${referenceTableName} (${referenceTableColumns})`;
      constraintSnippet += constraint.updateAction ? ` ON UPDATE ${constraint.updateAction}` : "";
      constraintSnippet += constraint.deleteAction ? ` ON DELETE ${constraint.deleteAction}` : "";
    } else if (["PRIMARY KEY", "UNIQUE"].includes(constraint.constraintType)) {
      constraintSnippet = `, CONSTRAINT ${constraint.constraintName} ${constraint.constraintType}`;
      const columns = constraint.columnNames.map((columnName) => this.queryGenerator.quoteIdentifier(columnName)).join(", ");
      constraintSnippet += ` (${columns})`;
    }
    const fields = await this.describeTable(tableName, options);
    const sql = this.queryGenerator._replaceTableQuery(tableName, fields, createTableSql.replaceAll('"', "`").replace(constraintSnippet, ""));
    const subQueries = sql.split(";").filter((q) => q !== "");
    for (const subQuery of subQueries) {
      await this.sequelize.queryRaw(`${subQuery};`, { ...options, raw: true });
    }
  }
  async showConstraints(tableName, options) {
    const describeCreateTableSql = this.queryGenerator.describeCreateTableQuery(tableName);
    const describeCreateTable = await this.sequelize.queryRaw(describeCreateTableSql, {
      ...options,
      raw: true,
      type: import_query_types.QueryTypes.SELECT
    });
    if (!describeCreateTable.length || !("sql" in describeCreateTable[0])) {
      throw new Error("Unable to find constraints for table. Perhaps the table does not exist?");
    }
    const { sql: createTableSql } = describeCreateTable[0];
    const match = /CREATE TABLE (?:`|'|")(\S+)(?:`|'|") \((.+)\)/.exec(createTableSql);
    const data = [];
    if (match) {
      const [, constraintTableName, attributeSQL] = match;
      const keys = [];
      const attributes = [];
      const constraints = [];
      const sqlAttributes = attributeSQL.split(/,(?![^(]*\))/).map((attr) => attr.trim());
      for (const attribute of sqlAttributes) {
        if (attribute.startsWith("CONSTRAINT")) {
          constraints.push(attribute);
        } else if (attribute.startsWith("PRIMARY KEY") || attribute.startsWith("FOREIGN KEY")) {
          keys.push(attribute);
        } else {
          attributes.push(attribute);
        }
      }
      for (const attribute of attributes) {
        const [, column, type] = attribute.match(/`(\S+)` (.+)/) || [];
        if (/\bPRIMARY KEY\b/.test(type)) {
          data.push({
            constraintSchema: "",
            constraintName: "PRIMARY",
            constraintType: "PRIMARY KEY",
            tableSchema: "",
            tableName: constraintTableName,
            columnNames: [column]
          });
        } else if (/\bREFERENCES\b/.test(type)) {
          const deleteAction = type.match(/ON DELETE (\w+(?: (?!ON UPDATE)\w+)?)/);
          const updateAction = type.match(/ON UPDATE (\w+(?: (?!ON DELETE)\w+)?)/);
          const [, referencedTableName, referencedColumnNames] = type.match(/REFERENCES `(\S+)` \(`(\S+)`\)/) || [];
          data.push({
            constraintSchema: "",
            constraintName: "FOREIGN",
            constraintType: "FOREIGN KEY",
            tableSchema: "",
            tableName: constraintTableName,
            columnNames: [column],
            referencedTableSchema: "",
            referencedTableName: referencedTableName ?? "",
            referencedColumnNames: [referencedColumnNames],
            deleteAction: (deleteAction == null ? void 0 : deleteAction.at(1)) ?? "",
            updateAction: (updateAction == null ? void 0 : updateAction.at(1)) ?? ""
          });
        } else if (/\bUNIQUE\b/.test(type)) {
          data.push({
            constraintSchema: "",
            constraintName: "UNIQUE",
            constraintType: "UNIQUE",
            tableSchema: "",
            tableName: constraintTableName,
            columnNames: [column]
          });
        } else if (/\bCHECK\b/.test(type)) {
          const definition = type.match(/CHECK (.+)/);
          data.push({
            constraintSchema: "",
            constraintName: "CHECK",
            constraintType: "CHECK",
            tableSchema: "",
            tableName: constraintTableName,
            columnNames: [column],
            definition: definition ? definition[1] ?? "" : ""
          });
        }
      }
      for (const constraint of constraints) {
        const [, constraintName, constraintType, definition] = constraint.match(/CONSTRAINT (?:`|'|")(\S+)(?:`|'|") (\w+(?: \w+)?) (.+)/) || [];
        if (/\bPRIMARY KEY\b/.test(constraint)) {
          const columnsMatch = [...definition.matchAll(/`(\S+)`/g)];
          data.push({
            constraintSchema: "",
            constraintName,
            constraintType: "PRIMARY KEY",
            tableSchema: "",
            tableName: constraintTableName,
            columnNames: columnsMatch.map((col) => col[1])
          });
        } else if (/\bREFERENCES\b/.test(constraint)) {
          const deleteAction = definition.match(/ON DELETE (\w+(?: (?!ON UPDATE)\w+)?)/);
          const updateAction = definition.match(/ON UPDATE (\w+(?: (?!ON DELETE)\w+)?)/);
          const [, rawColumnNames, referencedTableName, rawReferencedColumnNames] = definition.match(/\(([^\s,]+(?:,\s?[^\s,]+)*)\) REFERENCES `(\S+)` \(([^\s,]+(?:,\s?[^\s,]+)*)\)/) || [];
          const columnsMatch = [...rawColumnNames.matchAll(/`(\S+)`/g)];
          const referencedColumnNames = [...rawReferencedColumnNames.matchAll(/`(\S+)`/g)];
          data.push({
            constraintSchema: "",
            constraintName,
            constraintType: "FOREIGN KEY",
            tableSchema: "",
            tableName: constraintTableName,
            columnNames: columnsMatch.map((col) => col[1]),
            referencedTableSchema: "",
            referencedTableName: referencedTableName ?? "",
            referencedColumnNames: referencedColumnNames.map((col) => col[1]),
            deleteAction: (deleteAction == null ? void 0 : deleteAction.at(1)) ?? "",
            updateAction: (updateAction == null ? void 0 : updateAction.at(1)) ?? ""
          });
        } else if (["CHECK", "DEFAULT", "UNIQUE"].includes(constraintType)) {
          const columnsMatch = [...definition.matchAll(/`(\S+)`/g)];
          data.push({
            constraintSchema: "",
            constraintName,
            constraintType,
            tableSchema: "",
            tableName: constraintTableName,
            ...constraintType !== "CHECK" && { columnNames: columnsMatch.map((col) => col[1]) },
            ...constraintType !== "UNIQUE" && { definition }
          });
        }
      }
      for (const key of keys) {
        const [, constraintType, rawColumnNames] = key.match(/(\w+(?: \w+)?)\s?\(([^\s,]+(?:,\s?[^\s,]+)*)\)/) || [];
        const columnsMatch = [...rawColumnNames.matchAll(/`(\S+)`/g)];
        const columnNames = columnsMatch.map((col) => col[1]);
        if (constraintType === "PRIMARY KEY") {
          data.push({
            constraintSchema: "",
            constraintName: "PRIMARY",
            constraintType,
            tableSchema: "",
            tableName: constraintTableName,
            columnNames
          });
        } else if (constraintType === "FOREIGN KEY") {
          const deleteAction = key.match(/ON DELETE (\w+(?: (?!ON UPDATE)\w+)?)/);
          const updateAction = key.match(/ON UPDATE (\w+(?: (?!ON DELETE)\w+)?)/);
          const [, referencedTableName, rawReferencedColumnNames] = key.match(/REFERENCES `(\S+)` \(([^\s,]+(?:,\s?[^\s,]+)*)\)/) || [];
          const referencedColumnNames = [...rawReferencedColumnNames.matchAll(/`(\S+)`/g)];
          data.push({
            constraintSchema: "",
            constraintName: "FOREIGN",
            constraintType,
            tableSchema: "",
            tableName: constraintTableName,
            columnNames,
            referencedTableSchema: "",
            referencedTableName,
            referencedColumnNames: referencedColumnNames.map((col) => col[1]),
            deleteAction: (deleteAction == null ? void 0 : deleteAction.at(1)) ?? "",
            updateAction: (updateAction == null ? void 0 : updateAction.at(1)) ?? ""
          });
        }
      }
    } else {
      throw new Error(`Could not parse constraints from SQL: ${createTableSql}`);
    }
    let constraintData = data;
    if (options == null ? void 0 : options.columnName) {
      constraintData = constraintData.filter((constraint) => {
        var _a;
        return (_a = constraint.columnNames) == null ? void 0 : _a.includes(options.columnName);
      });
      constraintData = constraintData.map((constraint) => {
        if (constraint.columnNames) {
          constraint.columnNames = constraint.columnNames.filter((column) => column === options.columnName);
        }
        return constraint;
      });
    }
    if (options == null ? void 0 : options.constraintName) {
      constraintData = constraintData.filter((constraint) => constraint.constraintName === options.constraintName);
    }
    if (options == null ? void 0 : options.constraintType) {
      constraintData = constraintData.filter((constraint) => constraint.constraintType === options.constraintType);
    }
    return constraintData;
  }
}
//# sourceMappingURL=query-interface-typescript.js.map
