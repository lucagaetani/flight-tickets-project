"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var query_exports = {};
__export(query_exports, {
  SqliteQuery: () => SqliteQuery
});
module.exports = __toCommonJS(query_exports);
var import_isEqual = __toESM(require("lodash/isEqual"));
var import_isPlainObject = __toESM(require("lodash/isPlainObject"));
var import_merge = __toESM(require("lodash/merge"));
const { AbstractQuery } = require("../abstract/query");
const { QueryTypes } = require("../../query-types");
const sequelizeErrors = require("../../errors");
const { logger } = require("../../utils/logger");
const debug = logger.debugContext("sql:sqlite");
function stringifyIfBigint(value) {
  if (typeof value === "bigint") {
    return value.toString();
  }
  return value;
}
class SqliteQuery extends AbstractQuery {
  getInsertIdField() {
    return "lastID";
  }
  _collectModels(include, prefix) {
    const ret = {};
    if (include) {
      for (const _include of include) {
        let key;
        if (!prefix) {
          key = _include.as;
        } else {
          key = `${prefix}.${_include.as}`;
        }
        ret[key] = _include.model;
        if (_include.include) {
          (0, import_merge.default)(ret, this._collectModels(_include.include, key));
        }
      }
    }
    return ret;
  }
  _handleQueryResponse(metaData, results) {
    var _a;
    let result = this.instance;
    if (this.isInsertQuery(results, metaData) || this.isUpsertQuery()) {
      this.handleInsertQuery(results, metaData);
      if (!this.instance) {
        const modelDefinition = (_a = this.model) == null ? void 0 : _a.modelDefinition;
        if (metaData.constructor.name === "Statement" && (modelDefinition == null ? void 0 : modelDefinition.autoIncrementAttributeName) && (modelDefinition == null ? void 0 : modelDefinition.autoIncrementAttributeName) === this.model.primaryKeyAttribute) {
          const startId = metaData[this.getInsertIdField()] - metaData.changes + 1;
          result = [];
          for (let i = startId; i < startId + metaData.changes; i++) {
            result.push({ [modelDefinition.getColumnName(this.model.primaryKeyAttribute)]: i });
          }
        } else {
          result = metaData[this.getInsertIdField()];
        }
      }
    }
    if (this.isShowConstraintsQuery()) {
      return result;
    }
    if (this.isSelectQuery()) {
      return this.handleSelectQuery(results);
    }
    if (this.isShowOrDescribeQuery()) {
      return results;
    }
    if (this.sql.includes("PRAGMA INDEX_LIST")) {
      return this.handleShowIndexesQuery(results);
    }
    if (this.sql.includes("PRAGMA INDEX_INFO")) {
      return results;
    }
    if (this.sql.includes("PRAGMA TABLE_INFO")) {
      result = {};
      let defaultValue;
      for (const _result of results) {
        if (_result.dflt_value === null) {
          defaultValue = void 0;
        } else if (_result.dflt_value === "NULL") {
          defaultValue = null;
        } else {
          defaultValue = _result.dflt_value;
        }
        result[_result.name] = {
          type: _result.type,
          allowNull: _result.notnull === 0,
          defaultValue,
          primaryKey: _result.pk !== 0
        };
        if (result[_result.name].type === "TINYINT(1)") {
          result[_result.name].defaultValue = { 0: false, 1: true }[result[_result.name].defaultValue];
        }
        if (typeof result[_result.name].defaultValue === "string") {
          result[_result.name].defaultValue = result[_result.name].defaultValue.replaceAll("'", "");
        }
      }
      return result;
    }
    if ([QueryTypes.BULKUPDATE, QueryTypes.BULKDELETE].includes(this.options.type)) {
      return metaData.changes;
    }
    if (this.options.type === QueryTypes.RAW) {
      return [results, metaData];
    }
    if (this.isUpsertQuery()) {
      return [result, null];
    }
    if (this.isUpdateQuery() || this.isInsertQuery()) {
      return [result, metaData.changes];
    }
    return result;
  }
  async run(sql, parameters) {
    const conn = this.connection;
    this.sql = sql;
    const method = this.getDatabaseMethod();
    const complete = this._logQuery(sql, debug, parameters);
    const columnTypes = {};
    const executeSql = async () => {
      if (sql.startsWith("-- ")) {
        return;
      }
      const query = this;
      if (!parameters) {
        parameters = [];
      }
      if ((0, import_isPlainObject.default)(parameters)) {
        const newParameters = /* @__PURE__ */ Object.create(null);
        for (const key of Object.keys(parameters)) {
          newParameters[`$${key}`] = stringifyIfBigint(parameters[key]);
        }
        parameters = newParameters;
      } else {
        parameters = parameters.map(stringifyIfBigint);
      }
      let response;
      try {
        if (method === "run") {
          response = await this.#runSeries(conn, sql, parameters);
        } else {
          response = await this.#allSeries(conn, sql, parameters);
        }
      } catch (error) {
        error.sql = this.sql;
        throw this.formatError(error);
      }
      complete();
      return query._handleQueryResponse(response.statement, response.results);
    };
    if (method === "all") {
      let tableNames = [];
      if (this.options && this.options.tableNames) {
        tableNames = this.options.tableNames;
      } else if (/from `(.*?)`/i.test(this.sql)) {
        tableNames.push(/from `(.*?)`/i.exec(this.sql)[1]);
      }
      tableNames = tableNames.filter((tableName) => !(tableName in columnTypes) && tableName !== "sqlite_master");
      if (tableNames.length === 0) {
        return executeSql();
      }
      await Promise.all(tableNames.map(async (tableName) => {
        tableName = tableName.replaceAll("`", "");
        columnTypes[tableName] = {};
        const { results } = await this.#allSeries(conn, `PRAGMA table_info(\`${tableName}\`)`);
        for (const result of results) {
          columnTypes[tableName][result.name] = result.type;
        }
      }));
    }
    return executeSql();
  }
  #allSeries(connection, query, parameters) {
    return new Promise((resolve, reject) => {
      connection.serialize(() => {
        connection.all(query, parameters, function(err, results) {
          if (err) {
            reject(err);
            return;
          }
          resolve({ statement: this, results });
        });
      });
    });
  }
  #runSeries(connection, query, parameters) {
    return new Promise((resolve, reject) => {
      connection.serialize(() => {
        connection.run(query, parameters, function(err, results) {
          if (err) {
            reject(err);
            return;
          }
          resolve({ statement: this, results });
        });
      });
    });
  }
  formatError(err) {
    switch (err.code) {
      case "SQLITE_CONSTRAINT_UNIQUE":
      case "SQLITE_CONSTRAINT_PRIMARYKEY":
      case "SQLITE_CONSTRAINT_TRIGGER":
      case "SQLITE_CONSTRAINT_FOREIGNKEY":
      case "SQLITE_CONSTRAINT": {
        if (err.message.includes("FOREIGN KEY constraint failed")) {
          return new sequelizeErrors.ForeignKeyConstraintError({
            cause: err
          });
        }
        let fields = [];
        let match = err.message.match(/columns (.*?) are/);
        if (match !== null && match.length >= 2) {
          fields = match[1].split(", ");
        } else {
          match = err.message.match(/UNIQUE constraint failed: (.*)/);
          if (match !== null && match.length >= 2) {
            fields = match[1].split(", ").map((columnWithTable) => columnWithTable.split(".")[1]);
          }
        }
        const errors = [];
        let message = "Validation error";
        for (const field of fields) {
          errors.push(new sequelizeErrors.ValidationErrorItem(
            this.getUniqueConstraintErrorMessage(field),
            "unique violation",
            // sequelizeErrors.ValidationErrorItem.Origins.DB,
            field,
            this.instance && this.instance[field],
            this.instance,
            "not_unique"
          ));
        }
        if (this.model) {
          for (const index of this.model.getIndexes()) {
            if (index.unique && (0, import_isEqual.default)(index.fields, fields) && index.msg) {
              message = index.msg;
              break;
            }
          }
        }
        return new sequelizeErrors.UniqueConstraintError({ message, errors, cause: err, fields });
      }
      case "SQLITE_BUSY":
        return new sequelizeErrors.TimeoutError(err);
      default:
        return new sequelizeErrors.DatabaseError(err);
    }
  }
  async handleShowIndexesQuery(data) {
    return Promise.all(data.reverse().map(async (item) => {
      item.fields = [];
      item.primary = false;
      item.unique = Boolean(item.unique);
      item.constraintName = item.name;
      const columns = await this.run(`PRAGMA INDEX_INFO(\`${item.name}\`)`);
      for (const column of columns) {
        item.fields[column.seqno] = {
          attribute: column.name,
          length: void 0,
          order: void 0
        };
      }
      return item;
    }));
  }
  getDatabaseMethod() {
    if (this.isInsertQuery() || this.isUpdateQuery() || this.isUpsertQuery() || this.isBulkUpdateQuery() || this.sql.toLowerCase().includes("CREATE TEMPORARY TABLE".toLowerCase()) || this.options.type === QueryTypes.BULKDELETE) {
      return "run";
    }
    return "all";
  }
}
//# sourceMappingURL=query.js.map
