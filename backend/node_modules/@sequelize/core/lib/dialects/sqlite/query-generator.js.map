{
  "version": 3,
  "sources": ["../../../src/dialects/sqlite/query-generator.js"],
  "sourcesContent": ["'use strict';\n\nimport { removeNullishValuesFromHash } from '../../utils/format';\nimport { EMPTY_OBJECT } from '../../utils/object.js';\nimport { defaultValueSchemable } from '../../utils/query-builder-utils';\nimport { rejectInvalidOptions } from '../../utils/check';\nimport { ADD_COLUMN_QUERY_SUPPORTABLE_OPTIONS, CREATE_TABLE_QUERY_SUPPORTABLE_OPTIONS } from '../abstract/query-generator';\n\nimport defaults from 'lodash/defaults';\nimport each from 'lodash/each';\nimport isObject from 'lodash/isObject';\n\nconst { Transaction } = require('../../transaction');\nconst { SqliteQueryGeneratorTypeScript } = require('./query-generator-typescript');\n\nconst ADD_COLUMN_QUERY_SUPPORTED_OPTIONS = new Set();\n// TODO: add support for 'uniqueKeys' by improving the createTableQuery implementation so it also generates a CREATE UNIQUE INDEX query\nconst CREATE_TABLE_QUERY_SUPPORTED_OPTIONS = new Set();\n\nexport class SqliteQueryGenerator extends SqliteQueryGeneratorTypeScript {\n  createTableQuery(tableName, attributes, options) {\n    if (options) {\n      rejectInvalidOptions(\n        'createTableQuery',\n        this.dialect.name,\n        CREATE_TABLE_QUERY_SUPPORTABLE_OPTIONS,\n        CREATE_TABLE_QUERY_SUPPORTED_OPTIONS,\n        options,\n      );\n    }\n\n    options = options || {};\n\n    const primaryKeys = [];\n    const needsMultiplePrimaryKeys = Object.values(attributes).filter(definition => definition.includes('PRIMARY KEY')).length > 1;\n    const attrArray = [];\n\n    for (const attr in attributes) {\n      if (Object.hasOwn(attributes, attr)) {\n        const dataType = attributes[attr];\n        const containsAutoIncrement = dataType.includes('AUTOINCREMENT');\n\n        let dataTypeString = dataType;\n        if (dataType.includes('PRIMARY KEY')) {\n          if (dataType.includes('INT')) {\n            // Only INTEGER is allowed for primary key, see https://github.com/sequelize/sequelize/issues/969 (no lenght, unsigned etc)\n            dataTypeString = containsAutoIncrement ? 'INTEGER PRIMARY KEY AUTOINCREMENT' : 'INTEGER PRIMARY KEY';\n\n            if (dataType.includes(' REFERENCES')) {\n              dataTypeString += dataType.slice(dataType.indexOf(' REFERENCES'));\n            }\n          }\n\n          if (needsMultiplePrimaryKeys) {\n            primaryKeys.push(attr);\n            if (dataType.includes('NOT NULL')) {\n              dataTypeString = dataType.replace(' PRIMARY KEY', '');\n            } else {\n              dataTypeString = dataType.replace('PRIMARY KEY', 'NOT NULL');\n            }\n          }\n        }\n\n        attrArray.push(`${this.quoteIdentifier(attr)} ${dataTypeString}`);\n      }\n    }\n\n    const table = this.quoteTable(tableName);\n    let attrStr = attrArray.join(', ');\n    const pkString = primaryKeys.map(pk => this.quoteIdentifier(pk)).join(', ');\n\n    // sqlite has a bug where using CONSTRAINT constraint_name UNIQUE during CREATE TABLE\n    //  does not respect the provided constraint name\n    //  and uses sqlite_autoindex_ as the name of the constraint instead.\n    //  CREATE UNIQUE INDEX does not have this issue, so we're using that instead\n    //\n    // if (options.uniqueKeys) {\n    //   each(options.uniqueKeys, (columns, indexName) => {\n    //     if (columns.customIndex) {\n    //       if (typeof indexName !== 'string') {\n    //         indexName = generateIndexName(tableName, columns);\n    //       }\n    //\n    //       attrStr += `, CONSTRAINT ${\n    //         this.quoteIdentifier(indexName)\n    //       } UNIQUE (${\n    //         columns.fields.map(field => this.quoteIdentifier(field)).join(', ')\n    //       })`;\n    //     }\n    //   });\n    // }\n\n    if (pkString.length > 0) {\n      attrStr += `, PRIMARY KEY (${pkString})`;\n    }\n\n    const sql = `CREATE TABLE IF NOT EXISTS ${table} (${attrStr});`;\n\n    return this.replaceBooleanDefaults(sql);\n  }\n\n  addLimitAndOffset(options, model) {\n    let fragment = '';\n    if (options.limit != null) {\n      fragment += ` LIMIT ${this.escape(options.limit, options)}`;\n    } else if (options.offset) {\n      // limit must be specified if offset is specified.\n      fragment += ` LIMIT -1`;\n    }\n\n    if (options.offset) {\n      fragment += ` OFFSET ${this.escape(options.offset, options)}`;\n    }\n\n    return fragment;\n  }\n\n  addColumnQuery(table, key, dataType, options) {\n    if (options) {\n      rejectInvalidOptions(\n        'addColumnQuery',\n        this.dialect.name,\n        ADD_COLUMN_QUERY_SUPPORTABLE_OPTIONS,\n        ADD_COLUMN_QUERY_SUPPORTED_OPTIONS,\n        options,\n      );\n    }\n\n    const attributes = {};\n    attributes[key] = dataType;\n    const fields = this.attributesToSQL(attributes, { context: 'addColumn' });\n    const attribute = `${this.quoteIdentifier(key)} ${fields[key]}`;\n\n    const sql = `ALTER TABLE ${this.quoteTable(table)} ADD ${attribute};`;\n\n    return this.replaceBooleanDefaults(sql);\n  }\n\n  updateQuery(tableName, attrValueHash, where, options, attributes) {\n    options = options || {};\n    defaults(options, this.options);\n\n    attrValueHash = removeNullishValuesFromHash(attrValueHash, options.omitNull, options);\n\n    const modelAttributeMap = Object.create(null);\n    const values = [];\n    const bind = Object.create(null);\n    const bindParam = options.bindParam === undefined ? this.bindParam(bind) : options.bindParam;\n\n    if (attributes) {\n      each(attributes, (attribute, key) => {\n        modelAttributeMap[key] = attribute;\n        if (attribute.field) {\n          modelAttributeMap[attribute.field] = attribute;\n        }\n      });\n    }\n\n    for (const key in attrValueHash) {\n      const value = attrValueHash[key] ?? null;\n\n      const escapedValue = this.escape(value, {\n        replacements: options.replacements,\n        bindParam,\n        type: modelAttributeMap[key]?.type,\n        // TODO: model,\n      });\n\n      values.push(`${this.quoteIdentifier(key)}=${escapedValue}`);\n    }\n\n    let query;\n    const whereOptions = { ...options, bindParam };\n\n    if (options.limit) {\n      query = `UPDATE ${this.quoteTable(tableName)} SET ${values.join(',')} WHERE rowid IN (SELECT rowid FROM ${this.quoteTable(tableName)} ${this.whereQuery(where, whereOptions)} LIMIT ${this.escape(options.limit, undefined, options)})`.trim();\n    } else {\n      query = `UPDATE ${this.quoteTable(tableName)} SET ${values.join(',')} ${this.whereQuery(where, whereOptions)}`.trim();\n    }\n\n    const result = { query };\n    if (options.bindParam !== false) {\n      result.bind = bind;\n    }\n\n    return result;\n  }\n\n  truncateTableQuery(tableName, options = {}) {\n    return [\n      `DELETE FROM ${this.quoteTable(tableName)}`,\n      options.restartIdentity ? `; DELETE FROM ${this.quoteTable('sqlite_sequence')} WHERE ${this.quoteIdentifier('name')} = ${this.quoteTable(tableName)};` : '',\n    ].join('');\n  }\n\n  deleteQuery(tableName, where, options = EMPTY_OBJECT, model) {\n    defaults(options, this.options);\n\n    let whereClause = this.whereQuery(where, { ...options, model });\n    if (whereClause) {\n      whereClause = ` ${whereClause}`;\n    }\n\n    if (options.limit) {\n      whereClause = `WHERE rowid IN (SELECT rowid FROM ${this.quoteTable(tableName)} ${whereClause} LIMIT ${this.escape(options.limit, options)})`;\n    }\n\n    return `DELETE FROM ${this.quoteTable(tableName)} ${whereClause}`.trim();\n  }\n\n  attributesToSQL(attributes, options) {\n    const result = {};\n    for (const name in attributes) {\n      const attribute = attributes[name];\n      const columnName = attribute.field || attribute.columnName || name;\n\n      if (isObject(attribute)) {\n        let sql = attribute.type.toString();\n\n        if (attribute.allowNull === false) {\n          sql += ' NOT NULL';\n        }\n\n        if (defaultValueSchemable(attribute.defaultValue)) {\n          // TODO thoroughly check that DataTypes.NOW will properly\n          // get populated on all databases as DEFAULT value\n          // i.e. mysql requires: DEFAULT CURRENT_TIMESTAMP\n          sql += ` DEFAULT ${this.escape(attribute.defaultValue, { ...options, type: attribute.type })}`;\n        }\n\n        if (attribute.unique === true) {\n          sql += ' UNIQUE';\n        }\n\n        if (attribute.primaryKey) {\n          sql += ' PRIMARY KEY';\n\n          if (attribute.autoIncrement) {\n            sql += ' AUTOINCREMENT';\n          }\n        }\n\n        if (attribute.references) {\n          const referencesTable = this.quoteTable(attribute.references.table);\n\n          let referencesKey;\n          if (attribute.references.key) {\n            referencesKey = this.quoteIdentifier(attribute.references.key);\n          } else {\n            referencesKey = this.quoteIdentifier('id');\n          }\n\n          sql += ` REFERENCES ${referencesTable} (${referencesKey})`;\n\n          if (attribute.onDelete) {\n            sql += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;\n          }\n\n          if (attribute.onUpdate) {\n            sql += ` ON UPDATE ${attribute.onUpdate.toUpperCase()}`;\n          }\n        }\n\n        result[columnName] = sql;\n      } else {\n        result[columnName] = attribute;\n      }\n    }\n\n    return result;\n  }\n\n  renameColumnQuery(tableName, attrNameBefore, attrNameAfter, attributes) {\n\n    let backupTableName;\n\n    attributes = this.attributesToSQL(attributes);\n\n    if (typeof tableName === 'object') {\n      backupTableName = {\n        tableName: `${tableName.tableName}_backup`,\n        schema: tableName.schema,\n      };\n    } else {\n      backupTableName = `${tableName}_backup`;\n    }\n\n    const quotedTableName = this.quoteTable(tableName);\n    const quotedBackupTableName = this.quoteTable(backupTableName);\n    const attributeNamesImport = Object.keys(attributes).map(attr => (attrNameAfter === attr ? `${this.quoteIdentifier(attrNameBefore)} AS ${this.quoteIdentifier(attr)}` : this.quoteIdentifier(attr))).join(', ');\n    const attributeNamesExport = Object.keys(attributes).map(attr => this.quoteIdentifier(attr)).join(', ');\n\n    // Temporary tables don't support foreign keys, so creating a temporary table will not allow foreign keys to be preserved\n    return `${this.createTableQuery(backupTableName, attributes)\n    }INSERT INTO ${quotedBackupTableName} SELECT ${attributeNamesImport} FROM ${quotedTableName};`\n      + `DROP TABLE ${quotedTableName};${\n        this.createTableQuery(tableName, attributes)\n      }INSERT INTO ${quotedTableName} SELECT ${attributeNamesExport} FROM ${quotedBackupTableName};`\n      + `DROP TABLE ${quotedBackupTableName};`;\n  }\n\n  startTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `SAVEPOINT ${this.quoteIdentifier(transaction.name)};`;\n    }\n\n    return `BEGIN ${transaction.options.type} TRANSACTION;`;\n  }\n\n  setIsolationLevelQuery(value) {\n    switch (value) {\n      case Transaction.ISOLATION_LEVELS.REPEATABLE_READ:\n        return '-- SQLite is not able to choose the isolation level REPEATABLE READ.';\n      case Transaction.ISOLATION_LEVELS.READ_UNCOMMITTED:\n        return 'PRAGMA read_uncommitted = ON;';\n      case Transaction.ISOLATION_LEVELS.READ_COMMITTED:\n        return 'PRAGMA read_uncommitted = OFF;';\n      case Transaction.ISOLATION_LEVELS.SERIALIZABLE:\n        return '-- SQLite\\'s default isolation level is SERIALIZABLE. Nothing to do.';\n      default:\n        throw new Error(`Unknown isolation level: ${value}`);\n    }\n  }\n\n  replaceBooleanDefaults(sql) {\n    return sql.replaceAll(/DEFAULT '?false'?/g, 'DEFAULT 0').replaceAll(/DEFAULT '?true'?/g, 'DEFAULT 1');\n  }\n\n  /**\n   * Generates an SQL query to check if there are any foreign key violations in the db schema\n   *\n   * @param {string} tableName  The name of the table\n   */\n  foreignKeyCheckQuery(tableName) {\n    return `PRAGMA foreign_key_check(${this.quoteTable(tableName)});`;\n  }\n}\n"],
  "mappings": "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",
  "names": ["defaults", "each", "isObject"]
}
