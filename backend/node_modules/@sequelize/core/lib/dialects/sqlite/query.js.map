{
  "version": 3,
  "sources": ["../../../src/dialects/sqlite/query.js"],
  "sourcesContent": ["'use strict';\n\nimport isEqual from 'lodash/isEqual';\nimport isPlainObject from 'lodash/isPlainObject';\nimport merge from 'lodash/merge';\n\nconst { AbstractQuery } = require('../abstract/query');\nconst { QueryTypes } = require('../../query-types');\nconst sequelizeErrors = require('../../errors');\nconst { logger } = require('../../utils/logger');\n\nconst debug = logger.debugContext('sql:sqlite');\n\n// sqlite3 currently ignores bigint values, so we have to translate to string for now\n// There's a WIP here: https://github.com/TryGhost/node-sqlite3/pull/1501\nfunction stringifyIfBigint(value) {\n  if (typeof value === 'bigint') {\n    return value.toString();\n  }\n\n  return value;\n}\n\nexport class SqliteQuery extends AbstractQuery {\n  getInsertIdField() {\n    return 'lastID';\n  }\n\n  _collectModels(include, prefix) {\n    const ret = {};\n\n    if (include) {\n      for (const _include of include) {\n        let key;\n        if (!prefix) {\n          key = _include.as;\n        } else {\n          key = `${prefix}.${_include.as}`;\n        }\n\n        ret[key] = _include.model;\n\n        if (_include.include) {\n          merge(ret, this._collectModels(_include.include, key));\n        }\n      }\n    }\n\n    return ret;\n  }\n\n  _handleQueryResponse(metaData, results) {\n    let result = this.instance;\n\n    // add the inserted row id to the instance\n    if (this.isInsertQuery(results, metaData) || this.isUpsertQuery()) {\n      this.handleInsertQuery(results, metaData);\n      if (!this.instance) {\n        const modelDefinition = this.model?.modelDefinition;\n\n        // handle bulkCreate AI primary key\n        if (\n          metaData.constructor.name === 'Statement'\n          && modelDefinition?.autoIncrementAttributeName\n          && modelDefinition?.autoIncrementAttributeName === this.model.primaryKeyAttribute\n        ) {\n          const startId = metaData[this.getInsertIdField()] - metaData.changes + 1;\n          result = [];\n          for (let i = startId; i < startId + metaData.changes; i++) {\n            result.push({ [modelDefinition.getColumnName(this.model.primaryKeyAttribute)]: i });\n          }\n        } else {\n          result = metaData[this.getInsertIdField()];\n        }\n      }\n    }\n\n    if (this.isShowConstraintsQuery()) {\n      return result;\n    }\n\n    if (this.isSelectQuery()) {\n      return this.handleSelectQuery(results);\n    }\n\n    if (this.isShowOrDescribeQuery()) {\n      return results;\n    }\n\n    if (this.sql.includes('PRAGMA INDEX_LIST')) {\n      return this.handleShowIndexesQuery(results);\n    }\n\n    if (this.sql.includes('PRAGMA INDEX_INFO')) {\n      return results;\n    }\n\n    if (this.sql.includes('PRAGMA TABLE_INFO')) {\n      // this is the sqlite way of getting the metadata of a table\n      result = {};\n\n      let defaultValue;\n      for (const _result of results) {\n        if (_result.dflt_value === null) {\n          // Column schema omits any \"DEFAULT ...\"\n          defaultValue = undefined;\n        } else if (_result.dflt_value === 'NULL') {\n          // Column schema is a \"DEFAULT NULL\"\n          defaultValue = null;\n        } else {\n          defaultValue = _result.dflt_value;\n        }\n\n        result[_result.name] = {\n          type: _result.type,\n          allowNull: _result.notnull === 0,\n          defaultValue,\n          primaryKey: _result.pk !== 0,\n        };\n\n        if (result[_result.name].type === 'TINYINT(1)') {\n          result[_result.name].defaultValue = { 0: false, 1: true }[result[_result.name].defaultValue];\n        }\n\n        if (typeof result[_result.name].defaultValue === 'string') {\n          result[_result.name].defaultValue = result[_result.name].defaultValue.replaceAll('\\'', '');\n        }\n      }\n\n      return result;\n    }\n\n    if ([QueryTypes.BULKUPDATE, QueryTypes.BULKDELETE].includes(this.options.type)) {\n      return metaData.changes;\n    }\n\n    if (this.options.type === QueryTypes.RAW) {\n      return [results, metaData];\n    }\n\n    if (this.isUpsertQuery()) {\n      return [result, null];\n    }\n\n    if (this.isUpdateQuery() || this.isInsertQuery()) {\n      return [result, metaData.changes];\n    }\n\n    return result;\n  }\n\n  async run(sql, parameters) {\n    const conn = this.connection;\n    this.sql = sql;\n    const method = this.getDatabaseMethod();\n    const complete = this._logQuery(sql, debug, parameters);\n\n    // TODO: remove sql type based parsing for SQLite.\n    //  It is extremely inefficient (requires a series of DESCRIBE TABLE query, which slows down all queries).\n    //  and is very unreliable.\n    //  Use Sequelize DataType parsing instead, until sqlite3 provides a clean API to know the DB type.\n    const columnTypes = {};\n\n    const executeSql = async () => {\n      // TODO: remove this check. A query could start with a comment:\n      if (sql.startsWith('-- ')) {\n        return;\n      }\n\n      const query = this;\n\n      if (!parameters) {\n        parameters = [];\n      }\n\n      if (isPlainObject(parameters)) {\n        const newParameters = Object.create(null);\n\n        for (const key of Object.keys(parameters)) {\n          newParameters[`$${key}`] = stringifyIfBigint(parameters[key]);\n        }\n\n        parameters = newParameters;\n      } else {\n        parameters = parameters.map(stringifyIfBigint);\n      }\n\n      let response;\n      try {\n\n        if (method === 'run') {\n          response = await this.#runSeries(conn, sql, parameters);\n        } else {\n          response = await this.#allSeries(conn, sql, parameters);\n        }\n      } catch (error) {\n        error.sql = this.sql;\n        throw this.formatError(error);\n      }\n\n      complete();\n\n      return query._handleQueryResponse(response.statement, response.results);\n    };\n\n    if (method === 'all') {\n      let tableNames = [];\n      if (this.options && this.options.tableNames) {\n        tableNames = this.options.tableNames;\n      } else if (/from `(.*?)`/i.test(this.sql)) {\n        tableNames.push(/from `(.*?)`/i.exec(this.sql)[1]);\n      }\n\n      // If we already have the metadata for the table, there's no need to ask for it again\n      tableNames = tableNames.filter(tableName => !(tableName in columnTypes) && tableName !== 'sqlite_master');\n\n      if (tableNames.length === 0) {\n        return executeSql();\n      }\n\n      await Promise.all(tableNames.map(async tableName => {\n        tableName = tableName.replaceAll('`', '');\n        columnTypes[tableName] = {};\n\n        const { results } = await this.#allSeries(conn, `PRAGMA table_info(\\`${tableName}\\`)`);\n        for (const result of results) {\n          columnTypes[tableName][result.name] = result.type;\n        }\n      }));\n    }\n\n    return executeSql();\n  }\n\n  #allSeries(connection, query, parameters) {\n    return new Promise((resolve, reject) => {\n      connection.serialize(() => {\n        connection.all(query, parameters, function (err, results) {\n          if (err) {\n            reject(err);\n\n            return;\n          }\n\n          // node-sqlite3 passes the statement object as `this` to the callback\n          resolve({ statement: this, results });\n        });\n      });\n    });\n  }\n\n  #runSeries(connection, query, parameters) {\n    return new Promise((resolve, reject) => {\n      connection.serialize(() => {\n        connection.run(query, parameters, function (err, results) {\n          if (err) {\n            reject(err);\n\n            return;\n          }\n\n          // node-sqlite3 passes the statement object as `this` to the callback\n          resolve({ statement: this, results });\n        });\n      });\n    });\n  }\n\n  formatError(err) {\n\n    switch (err.code) {\n      case 'SQLITE_CONSTRAINT_UNIQUE':\n      case 'SQLITE_CONSTRAINT_PRIMARYKEY':\n      case 'SQLITE_CONSTRAINT_TRIGGER':\n      case 'SQLITE_CONSTRAINT_FOREIGNKEY':\n      case 'SQLITE_CONSTRAINT': {\n        if (err.message.includes('FOREIGN KEY constraint failed')) {\n          return new sequelizeErrors.ForeignKeyConstraintError({\n            cause: err,\n          });\n        }\n\n        let fields = [];\n\n        // Sqlite pre 2.2 behavior - Error: SQLITE_CONSTRAINT: columns x, y are not unique\n        let match = err.message.match(/columns (.*?) are/);\n        if (match !== null && match.length >= 2) {\n          fields = match[1].split(', ');\n        } else {\n\n          // Sqlite post 2.2 behavior - Error: SQLITE_CONSTRAINT: UNIQUE constraint failed: table.x, table.y\n          match = err.message.match(/UNIQUE constraint failed: (.*)/);\n          if (match !== null && match.length >= 2) {\n            fields = match[1].split(', ').map(columnWithTable => columnWithTable.split('.')[1]);\n          }\n        }\n\n        const errors = [];\n        let message = 'Validation error';\n\n        for (const field of fields) {\n          errors.push(new sequelizeErrors.ValidationErrorItem(\n            this.getUniqueConstraintErrorMessage(field),\n            'unique violation', // sequelizeErrors.ValidationErrorItem.Origins.DB,\n            field,\n            this.instance && this.instance[field],\n            this.instance,\n            'not_unique',\n          ));\n        }\n\n        if (this.model) {\n          for (const index of this.model.getIndexes()) {\n            if (index.unique && isEqual(index.fields, fields) && index.msg) {\n              message = index.msg;\n              break;\n            }\n          }\n        }\n\n        return new sequelizeErrors.UniqueConstraintError({ message, errors, cause: err, fields });\n      }\n\n      case 'SQLITE_BUSY':\n        return new sequelizeErrors.TimeoutError(err);\n\n      default:\n        return new sequelizeErrors.DatabaseError(err);\n    }\n  }\n\n  async handleShowIndexesQuery(data) {\n    // Sqlite returns indexes so the one that was defined last is returned first. Lets reverse that!\n    return Promise.all(data.reverse().map(async item => {\n      item.fields = [];\n      item.primary = false;\n      item.unique = Boolean(item.unique);\n      item.constraintName = item.name;\n      const columns = await this.run(`PRAGMA INDEX_INFO(\\`${item.name}\\`)`);\n      for (const column of columns) {\n        item.fields[column.seqno] = {\n          attribute: column.name,\n          length: undefined,\n          order: undefined,\n        };\n      }\n\n      return item;\n    }));\n  }\n\n  getDatabaseMethod() {\n    if (this.isInsertQuery() || this.isUpdateQuery() || this.isUpsertQuery() || this.isBulkUpdateQuery() || this.sql.toLowerCase().includes('CREATE TEMPORARY TABLE'.toLowerCase()) || this.options.type === QueryTypes.BULKDELETE) {\n      return 'run';\n    }\n\n    return 'all';\n  }\n}\n"],
  "mappings": "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",
  "names": ["merge", "isPlainObject", "isEqual"]
}
