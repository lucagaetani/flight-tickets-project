"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var query_interface_exports = {};
__export(query_interface_exports, {
  SqliteQueryInterface: () => SqliteQueryInterface
});
module.exports = __toCommonJS(query_interface_exports);
var import_deprecations = require("../../utils/deprecations");
var import_isEmpty = __toESM(require("lodash/isEmpty"));
const sequelizeErrors = require("../../errors");
const { QueryTypes } = require("../../query-types");
const { ColumnsDescription } = require("../abstract/query-interface.types");
const { QueryOptions } = require("../abstract/query-interface");
const { SqliteQueryInterfaceTypeScript } = require("./query-interface-typescript");
const crypto = require("node:crypto");
class SqliteQueryInterface extends SqliteQueryInterfaceTypeScript {
  /**
   * A wrapper that fixes SQLite's inability to remove columns from existing tables.
   * It will create a backup of the table, drop the table afterwards and create a
   * new table with the same name but without the obsolete column.
   *
   * @override
   */
  async removeColumn(tableName, columnName, options) {
    const fields = await this.describeTable(tableName, options);
    delete fields[columnName];
    return this.alterTableInternal(tableName, fields, options);
  }
  /**
   * A wrapper that fixes SQLite's inability to change columns from existing tables.
   * It will create a backup of the table, drop the table afterwards and create a
   * new table with the same name but with a modified version of the respective column.
   *
   * @override
   */
  async changeColumn(tableName, columnName, dataTypeOrOptions, options) {
    options = options || {};
    const columns = await this.describeTable(tableName, options);
    for (const column of Object.values(columns)) {
      delete column.unique;
    }
    Object.assign(columns[columnName], this.normalizeAttribute(dataTypeOrOptions));
    return this.alterTableInternal(tableName, columns, options);
  }
  /**
   * A wrapper that fixes SQLite's inability to rename columns from existing tables.
   * It will create a backup of the table, drop the table afterwards and create a
   * new table with the same name but with a renamed version of the respective column.
   *
   * @override
   */
  async renameColumn(tableName, attrNameBefore, attrNameAfter, options) {
    options = options || {};
    const fields = await this.assertTableHasColumn(tableName, attrNameBefore, options);
    fields[attrNameAfter] = { ...fields[attrNameBefore] };
    delete fields[attrNameBefore];
    const sql = this.queryGenerator.renameColumnQuery(tableName, attrNameBefore, attrNameAfter, fields);
    const subQueries = sql.split(";").filter((q) => q !== "");
    for (const subQuery of subQueries) {
      await this.sequelize.queryRaw(`${subQuery};`, { raw: true, ...options });
    }
  }
  /**
   * @override
   */
  async describeTable(tableName, options) {
    let table = {};
    if (typeof tableName === "string") {
      table.tableName = tableName;
    }
    if (typeof tableName === "object" && tableName !== null) {
      table = tableName;
    }
    if (typeof options === "string") {
      (0, import_deprecations.noSchemaParameter)();
      table.schema = options;
    }
    if (typeof options === "object" && options !== null) {
      if (options.schema) {
        (0, import_deprecations.noSchemaParameter)();
        table.schema = options.schema;
      }
      if (options.schemaDelimiter) {
        (0, import_deprecations.noSchemaDelimiterParameter)();
        table.delimiter = options.schemaDelimiter;
      }
    }
    const sql = this.queryGenerator.describeTableQuery(table);
    const sqlIndexes = this.queryGenerator.showIndexesQuery(table);
    try {
      const data = await this.sequelize.queryRaw(sql, { ...options, type: QueryTypes.DESCRIBE });
      if ((0, import_isEmpty.default)(data)) {
        throw new Error(`No description found for table ${table.tableName}${table.schema ? ` in schema ${table.schema}` : ""}. Check the table name and schema; remember, they _are_ case sensitive.`);
      }
      const indexes = await this.sequelize.queryRaw(sqlIndexes, { ...options, type: QueryTypes.SHOWINDEXES });
      for (const prop in data) {
        data[prop].unique = false;
      }
      for (const index of indexes) {
        for (const field of index.fields) {
          if (index.unique !== void 0) {
            data[field.attribute].unique = index.unique;
          }
        }
      }
      const foreignKeys = await this.showConstraints(tableName, { ...options, constraintType: "FOREIGN KEY" });
      for (const foreignKey of foreignKeys) {
        for (const [index, columnName] of foreignKey.columnNames.entries()) {
          Object.assign(data[columnName], {
            references: {
              table: foreignKey.referencedTableName,
              key: foreignKey.referencedColumnNames.at(index)
            },
            onUpdate: foreignKey.updateAction,
            onDelete: foreignKey.deleteAction
          });
        }
      }
      return data;
    } catch (error) {
      if (error.cause && error.cause.code === "ER_NO_SUCH_TABLE") {
        throw new Error(`No description found for table ${table.tableName}${table.schema ? ` in schema ${table.schema}` : ""}. Check the table name and schema; remember, they _are_ case sensitive.`);
      }
      throw error;
    }
  }
  /**
   * Alters a table in sqlite.
   * Workaround for sqlite's limited alter table support.
   *
   * @param {string} tableName - The table's name
   * @param {ColumnsDescription} columns - The table's description
   * @param {QueryOptions} options - Query options
   * @private
   */
  async alterTableInternal(tableName, columns, options) {
    return this.withForeignKeysOff(options, async () => {
      const savepointName = this.getSavepointName();
      await this.sequelize.query(`SAVEPOINT ${savepointName};`, options);
      try {
        const indexes = await this.showIndex(tableName, options);
        for (const index of indexes) {
          if (!index.constraintName.startsWith("sqlite_autoindex_")) {
            continue;
          }
          if (!index.unique) {
            continue;
          }
          for (const field of index.fields) {
            if (columns[field.attribute]) {
              columns[field.attribute].unique = true;
            }
          }
        }
        const sql = this.queryGenerator._replaceTableQuery(tableName, columns);
        const subQueries = sql.split(";").filter((q) => q !== "");
        for (const subQuery of subQueries) {
          await this.sequelize.query(`${subQuery};`, { raw: true, ...options });
        }
        const foreignKeyCheckResult = await this.sequelize.query(this.queryGenerator.foreignKeyCheckQuery(tableName), {
          ...options,
          type: QueryTypes.SELECT
        });
        if (foreignKeyCheckResult.length > 0) {
          throw new sequelizeErrors.ForeignKeyConstraintError({
            message: `Foreign key violations detected: ${JSON.stringify(foreignKeyCheckResult, null, 2)}`,
            table: tableName
          });
        }
        await Promise.all(indexes.map(async (index) => {
          if (index.constraintName.startsWith("sqlite_autoindex_")) {
            return;
          }
          return this.addIndex(tableName, index);
        }));
        await this.sequelize.query(`RELEASE ${savepointName};`, options);
      } catch (error) {
        await this.sequelize.query(`ROLLBACK TO ${savepointName};`, options);
        throw error;
      }
    });
  }
  /**
   * Runs the provided callback with foreign keys disabled.
   *
   * @param {QueryOptions} [options]
   * @param {Function<Promise<any>>} cb
   * @private
   */
  async withForeignKeysOff(options, cb) {
    await this.sequelize.query("PRAGMA foreign_keys = OFF;", options);
    try {
      return await cb();
    } finally {
      await this.sequelize.query("PRAGMA foreign_keys = ON;", options);
    }
  }
  /**
   * Returns a randomly generated savepoint name
   *
   * @param {string} prefix
   * @returns {string}
   */
  getSavepointName(prefix = "sequelize") {
    const suffix = crypto.randomUUID().replaceAll("-", "_");
    return `${prefix}_${suffix}`;
  }
}
//# sourceMappingURL=query-interface.js.map
