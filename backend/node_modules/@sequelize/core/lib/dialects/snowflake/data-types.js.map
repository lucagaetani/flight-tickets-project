{
  "version": 3,
  "sources": ["../../../src/dialects/snowflake/data-types.ts"],
  "sourcesContent": ["import maxBy from 'lodash/maxBy.js';\nimport * as BaseTypes from '../abstract/data-types.js';\nimport type { AcceptedDate } from '../abstract/data-types.js';\nimport type { AbstractDialect } from '../abstract/index.js';\n\nexport class DATE extends BaseTypes.DATE {\n  toSql() {\n    return `TIMESTAMP${this.options.precision != null ? `(${this.options.precision})` : ''}`;\n  }\n\n  toBindableValue(date: AcceptedDate) {\n    date = this._applyTimezone(date);\n\n    return date.format('YYYY-MM-DD HH:mm:ss.SSS');\n  }\n}\n\nexport class UUID extends BaseTypes.UUID {\n  toSql() {\n    // https://community.snowflake.com/s/question/0D50Z00009LH2fl/what-is-the-best-way-to-store-uuids\n    return 'VARCHAR(36)';\n  }\n}\n\nexport class ENUM<Member extends string> extends BaseTypes.ENUM<Member> {\n  toSql() {\n    const minLength = maxBy(this.options.values, value => value.length)?.length ?? 0;\n\n    // db2 does not have an ENUM type, we use VARCHAR instead.\n    return `VARCHAR(${Math.max(minLength, 255)})`;\n  }\n}\n\nexport class TEXT extends BaseTypes.TEXT {\n  toSql() {\n    return 'TEXT';\n  }\n}\n\nexport class JSON extends BaseTypes.JSON {\n  escape(value: unknown) {\n    return globalThis.JSON.stringify(value);\n  }\n}\n\n/** @deprecated */\nexport class REAL extends BaseTypes.REAL {\n  toSql(): string {\n    return 'REAL';\n  }\n}\n\nexport class FLOAT extends BaseTypes.FLOAT {\n  // TODO: warn that FLOAT is not supported in Snowflake, only DOUBLE is\n\n  toSql(): string {\n    return 'FLOAT';\n  }\n}\n\nexport class DOUBLE extends BaseTypes.DOUBLE {\n  toSql(): string {\n    // FLOAT is a double-precision floating point in Snowflake\n    return 'FLOAT';\n  }\n}\n\n// Snowflake only has one int type: Integer, which is -99999999999999999999999999999999999999 to 99999999999999999999999999999999999999\nexport class TINYINT extends BaseTypes.TINYINT {\n  toSql() {\n    return 'INTEGER';\n  }\n}\n\nexport class SMALLINT extends BaseTypes.SMALLINT {\n  toSql() {\n    return 'INTEGER';\n  }\n}\n\nexport class MEDIUMINT extends BaseTypes.MEDIUMINT {\n  toSql() {\n    return 'INTEGER';\n  }\n}\n\nexport class INTEGER extends BaseTypes.INTEGER {\n  toSql() {\n    return 'INTEGER';\n  }\n}\n\nexport class BIGINT extends BaseTypes.BIGINT {\n  // not really true, but snowflake allows INT values up to 99999999999999999999999999999999999999,\n  // which is more than enough to cover a 64-bit unsigned integer (0 - 18446744073709551615)\n  protected _supportsNativeUnsigned(_dialect: AbstractDialect): boolean {\n    return true;\n  }\n\n  toSql() {\n    return 'INTEGER';\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAAkB;AAClB,gBAA2B;AAIpB,MAAM,aAAa,UAAU,KAAK;AAAA,EACvC,QAAQ;AACN,WAAO,YAAY,KAAK,QAAQ,aAAa,OAAO,IAAI,KAAK,QAAQ,eAAe;AAAA,EACtF;AAAA,EAEA,gBAAgB,MAAoB;AAClC,WAAO,KAAK,eAAe,IAAI;AAE/B,WAAO,KAAK,OAAO,yBAAyB;AAAA,EAC9C;AACF;AAEO,MAAM,aAAa,UAAU,KAAK;AAAA,EACvC,QAAQ;AAEN,WAAO;AAAA,EACT;AACF;AAEO,MAAM,aAAoC,UAAU,KAAa;AAAA,EACtE,QAAQ;AAzBV;AA0BI,UAAM,cAAY,sBAAAA,SAAM,KAAK,QAAQ,QAAQ,WAAS,MAAM,MAAM,MAAhD,mBAAmD,WAAU;AAG/E,WAAO,WAAW,KAAK,IAAI,WAAW,GAAG;AAAA,EAC3C;AACF;AAEO,MAAM,aAAa,UAAU,KAAK;AAAA,EACvC,QAAQ;AACN,WAAO;AAAA,EACT;AACF;AAEO,MAAM,aAAa,UAAU,KAAK;AAAA,EACvC,OAAO,OAAgB;AACrB,WAAO,WAAW,KAAK,UAAU,KAAK;AAAA,EACxC;AACF;AAGO,MAAM,aAAa,UAAU,KAAK;AAAA,EACvC,QAAgB;AACd,WAAO;AAAA,EACT;AACF;AAEO,MAAM,cAAc,UAAU,MAAM;AAAA;AAAA,EAGzC,QAAgB;AACd,WAAO;AAAA,EACT;AACF;AAEO,MAAM,eAAe,UAAU,OAAO;AAAA,EAC3C,QAAgB;AAEd,WAAO;AAAA,EACT;AACF;AAGO,MAAM,gBAAgB,UAAU,QAAQ;AAAA,EAC7C,QAAQ;AACN,WAAO;AAAA,EACT;AACF;AAEO,MAAM,iBAAiB,UAAU,SAAS;AAAA,EAC/C,QAAQ;AACN,WAAO;AAAA,EACT;AACF;AAEO,MAAM,kBAAkB,UAAU,UAAU;AAAA,EACjD,QAAQ;AACN,WAAO;AAAA,EACT;AACF;AAEO,MAAM,gBAAgB,UAAU,QAAQ;AAAA,EAC7C,QAAQ;AACN,WAAO;AAAA,EACT;AACF;AAEO,MAAM,eAAe,UAAU,OAAO;AAAA;AAAA;AAAA,EAGjC,wBAAwB,UAAoC;AACpE,WAAO;AAAA,EACT;AAAA,EAEA,QAAQ;AACN,WAAO;AAAA,EACT;AACF;",
  "names": ["maxBy"]
}
