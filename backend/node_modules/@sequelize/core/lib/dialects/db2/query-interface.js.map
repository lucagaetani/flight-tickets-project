{
  "version": 3,
  "sources": ["../../../src/dialects/db2/query-interface.js"],
  "sourcesContent": ["'use strict';\n\nimport { AggregateError, BaseError, DatabaseError } from '../../errors';\nimport { isWhereEmpty } from '../../utils/query-builder-utils';\nimport { assertNoReservedBind } from '../../utils/sql';\n\nimport clone from 'lodash/clone';\nimport intersection from 'lodash/intersection';\nimport isPlainObject from 'lodash/isPlainObject';\nimport mapValues from 'lodash/mapValues';\n\nconst { Op } = require('../../operators');\nconst { AbstractQueryInterface } = require('../abstract/query-interface');\nconst { QueryTypes } = require('../../query-types');\n\n/**\n * The interface that Sequelize uses to talk with Db2 database\n */\nexport class Db2QueryInterface extends AbstractQueryInterface {\n  async upsert(tableName, insertValues, updateValues, where, options) {\n    if (options.bind) {\n      assertNoReservedBind(options.bind);\n    }\n\n    options = { ...options };\n\n    const model = options.model;\n    const wheres = [];\n    const attributes = Object.keys(insertValues);\n    let indexFields;\n\n    options = clone(options);\n\n    if (!isWhereEmpty(where)) {\n      wheres.push(where);\n    }\n\n    // Lets combine unique keys and indexes into one\n    const indexes = [];\n\n    for (const value of model.getIndexes()) {\n      if (value.unique) {\n        // fields in the index may both the strings or objects with an attribute property - lets sanitize that\n        indexFields = value.fields.map(field => {\n          if (isPlainObject(field)) {\n            return field.attribute;\n          }\n\n          return field;\n        });\n        indexes.push(indexFields);\n      }\n    }\n\n    for (const index of indexes) {\n      if (intersection(attributes, index).length === index.length) {\n        where = {};\n        for (const field of index) {\n          where[field] = insertValues[field];\n        }\n\n        wheres.push(where);\n      }\n    }\n\n    where = { [Op.or]: wheres };\n\n    options.type = QueryTypes.UPSERT;\n    options.raw = true;\n\n    const sql = this.queryGenerator.upsertQuery(tableName, insertValues, updateValues, where, model, options);\n\n    delete options.replacements;\n\n    const result = await this.sequelize.queryRaw(sql, options);\n\n    return [result, undefined];\n  }\n\n  async dropSchema(schema, options) {\n    const outParams = new Map();\n\n    // DROP SCHEMA works in a weird way in DB2:\n    // Its query uses ADMIN_DROP_SCHEMA, which stores the error message in a table\n    // specified by two IN-OUT parameters.\n    // If the returned values for these parameters is not null, then an error occurred.\n    const response = await super.dropSchema(schema, {\n      ...options,\n      // TODO: db2 supports out parameters. We don't have a proper API for it yet\n      //   for now, this temporary API will have to do.\n      _unsafe_db2Outparams: outParams,\n    });\n\n    const errorTable = outParams.get('sequelize_errorTable');\n    if (errorTable != null) {\n      const errorSchema = outParams.get('sequelize_errorSchema');\n\n      const errorData = await this.sequelize.queryRaw(`SELECT * FROM \"${errorSchema}\".\"${errorTable}\"`, {\n        type: QueryTypes.SELECT,\n      });\n\n      // replicate the data ibm_db adds on an error object\n      const error = new Error(errorData[0].DIAGTEXT);\n      error.sqlcode = errorData[0].SQLCODE;\n      error.sql = errorData[0].STATEMENT;\n      error.state = errorData[0].SQLSTATE;\n\n      const wrappedError = new DatabaseError(error);\n\n      try {\n        await this.dropTable({\n          tableName: errorTable,\n          schema: errorSchema,\n        });\n      } catch (dropError) {\n        throw new AggregateError([\n          wrappedError,\n          new BaseError(`An error occurred while cleaning up table ${errorSchema}.${errorTable}`, { cause: dropError }),\n        ]);\n      }\n\n      // -204 is \"name is undefined\" (schema does not exist)\n      // 'queryInterface.dropSchema' is supposed to be DROP SCHEMA IF EXISTS\n      // so we can ignore this error\n      if (error.sqlcode === -204 && error.state === '42704') {\n        return response;\n      }\n\n      throw wrappedError;\n    }\n\n    return response;\n  }\n\n  // TODO: drop \"schema\" options from the option bag, it must be passed through tableName instead.\n  async createTable(tableName, attributes, options, model) {\n    let sql = '';\n\n    options = { ...options };\n\n    if (model) {\n      options.uniqueKeys = options.uniqueKeys || model.uniqueKeys;\n    }\n\n    attributes = mapValues(\n      attributes,\n      attribute => this.sequelize.normalizeAttribute(attribute),\n    );\n\n    const modelTable = model?.table;\n\n    if (\n      !tableName.schema\n      && (options.schema || modelTable?.schema)\n    ) {\n      tableName = this.queryGenerator.extractTableDetails(tableName);\n      tableName.schema = modelTable?.schema || options.schema || tableName.schema;\n    }\n\n    attributes = this.queryGenerator.attributesToSQL(attributes, { table: tableName, context: 'createTable', withoutForeignKeyConstraints: options.withoutForeignKeyConstraints });\n    sql = this.queryGenerator.createTableQuery(tableName, attributes, options);\n\n    return await this.sequelize.queryRaw(sql, options);\n  }\n\n  async addConstraint(tableName, options) {\n    try {\n      await super.addConstraint(tableName, options);\n    } catch (error) {\n      if (!error.cause) {\n        throw error;\n      }\n\n      // Operation not allowed for reason code \"7\" on table \"DB2INST1.users\".  SQLSTATE=57007\n      if (error.cause.sqlcode !== -668 || error.cause.state !== '57007') {\n        throw error;\n      }\n\n      // https://www.ibm.com/support/pages/how-verify-and-resolve-sql0668n-reason-code-7-when-accessing-table\n      await this.executeTableReorg(tableName);\n      await super.addConstraint(tableName, options);\n    }\n  }\n\n  /**\n   * DB2 can put tables in the \"reorg pending\" state after a structure change (e.g. ALTER)\n   * Other changes cannot be done to these tables until the reorg has been completed.\n   *\n   * This method forces a reorg to happen now.\n   *\n   * @param {TableName} tableName - The name of the table to reorg\n   */\n  async executeTableReorg(tableName) {\n    // https://www.ibm.com/support/pages/sql0668n-operating-not-allowed-reason-code-7-seen-when-querying-or-viewing-table-db2-warehouse-cloud-and-db2-cloud\n    return await this.sequelize.query(`CALL SYSPROC.ADMIN_CMD('REORG TABLE ${this.queryGenerator.quoteTable(tableName)}')`);\n  }\n}\n"],
  "mappings": "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",
  "names": ["clone", "isPlainObject", "intersection", "mapValues"]
}
