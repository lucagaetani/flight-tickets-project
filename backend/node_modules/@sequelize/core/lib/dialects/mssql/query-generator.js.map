{
  "version": 3,
  "sources": ["../../../src/dialects/mssql/query-generator.js"],
  "sourcesContent": ["'use strict';\n\nimport { Col } from '../../expression-builders/col.js';\nimport { Literal } from '../../expression-builders/literal.js';\nimport { rejectInvalidOptions } from '../../utils/check';\nimport { joinSQLFragments } from '../../utils/join-sql-fragments';\nimport { defaultValueSchemable } from '../../utils/query-builder-utils';\nimport { generateIndexName } from '../../utils/string';\nimport { attributeTypeToSql, normalizeDataType } from '../abstract/data-types-utils';\nimport {\n  ADD_COLUMN_QUERY_SUPPORTABLE_OPTIONS,\n  CREATE_DATABASE_QUERY_SUPPORTABLE_OPTIONS,\n  CREATE_SCHEMA_QUERY_SUPPORTABLE_OPTIONS,\n  CREATE_TABLE_QUERY_SUPPORTABLE_OPTIONS,\n  DROP_TABLE_QUERY_SUPPORTABLE_OPTIONS,\n} from '../abstract/query-generator';\n\nimport each from 'lodash/each';\nimport forOwn from 'lodash/forOwn';\nimport isPlainObject from 'lodash/isPlainObject';\nimport isString from 'lodash/isString';\n\nconst DataTypes = require('../../data-types');\nconst { MsSqlQueryGeneratorTypeScript } = require('./query-generator-typescript');\nconst randomBytes = require('node:crypto').randomBytes;\nconst { Op } = require('../../operators');\n\n/* istanbul ignore next */\nfunction throwMethodUndefined(methodName) {\n  throw new Error(`The method \"${methodName}\" is not defined! Please add it to your sql dialect.`);\n}\n\nconst CREATE_DATABASE_QUERY_SUPPORTED_OPTIONS = new Set(['collate']);\nconst CREATE_SCHEMA_QUERY_SUPPORTED_OPTIONS = new Set();\nconst CREATE_TABLE_QUERY_SUPPORTED_OPTIONS = new Set(['uniqueKeys']);\nconst DROP_TABLE_QUERY_SUPPORTED_OPTIONS = new Set();\nconst ADD_COLUMN_QUERY_SUPPORTED_OPTIONS = new Set();\n\nexport class MsSqlQueryGenerator extends MsSqlQueryGeneratorTypeScript {\n  createDatabaseQuery(databaseName, options) {\n    if (options) {\n      rejectInvalidOptions(\n        'createDatabaseQuery',\n        this.dialect.name,\n        CREATE_DATABASE_QUERY_SUPPORTABLE_OPTIONS,\n        CREATE_DATABASE_QUERY_SUPPORTED_OPTIONS,\n        options,\n      );\n    }\n\n    const collation = options?.collate ? `COLLATE ${this.escape(options.collate)}` : '';\n\n    return [\n      'IF NOT EXISTS (SELECT * FROM sys.databases WHERE name =', this.escape(databaseName), ')',\n      'BEGIN',\n      'CREATE DATABASE', this.quoteIdentifier(databaseName),\n      `${collation};`,\n      'END;',\n    ].join(' ');\n  }\n\n  dropDatabaseQuery(databaseName) {\n    return [\n      'IF EXISTS (SELECT * FROM sys.databases WHERE name =', this.escape(databaseName), ')',\n      'BEGIN',\n      'DROP DATABASE', this.quoteIdentifier(databaseName), ';',\n      'END;',\n    ].join(' ');\n  }\n\n  listDatabasesQuery() {\n    return `SELECT name FROM sys.databases;`;\n  }\n\n  createSchemaQuery(schema, options) {\n    if (options) {\n      rejectInvalidOptions(\n        'createSchemaQuery',\n        this.dialect.name,\n        CREATE_SCHEMA_QUERY_SUPPORTABLE_OPTIONS,\n        CREATE_SCHEMA_QUERY_SUPPORTED_OPTIONS,\n        options,\n      );\n    }\n\n    return [\n      'IF NOT EXISTS (SELECT schema_name',\n      'FROM information_schema.schemata',\n      'WHERE schema_name =', this.escape(schema), ')',\n      'BEGIN',\n      'EXEC sp_executesql N\\'CREATE SCHEMA',\n      this.quoteIdentifier(schema),\n      ';\\'',\n      'END;',\n    ].join(' ');\n  }\n\n  dropSchemaQuery(schema) {\n    // Mimics Postgres CASCADE, will drop objects belonging to the schema\n    const quotedSchema = this.escape(schema);\n\n    return [\n      'IF EXISTS (SELECT schema_name',\n      'FROM information_schema.schemata',\n      'WHERE schema_name =', quotedSchema, ')',\n      'BEGIN',\n      'DECLARE @id INT, @ms_sql NVARCHAR(2000);',\n      'DECLARE @cascade TABLE (',\n      'id INT NOT NULL IDENTITY PRIMARY KEY,',\n      'ms_sql NVARCHAR(2000) NOT NULL );',\n      'INSERT INTO @cascade ( ms_sql )',\n      'SELECT CASE WHEN o.type IN (\\'F\\',\\'PK\\')',\n      'THEN N\\'ALTER TABLE [\\'+ s.name + N\\'].[\\' + p.name + N\\'] DROP CONSTRAINT [\\' + o.name + N\\']\\'',\n      'ELSE N\\'DROP TABLE [\\'+ s.name + N\\'].[\\' + o.name + N\\']\\' END',\n      'FROM sys.objects o',\n      'JOIN sys.schemas s on o.schema_id = s.schema_id',\n      'LEFT OUTER JOIN sys.objects p on o.parent_object_id = p.object_id',\n      'WHERE o.type IN (\\'F\\', \\'PK\\', \\'U\\') AND s.name = ', quotedSchema,\n      'ORDER BY o.type ASC;',\n      'SELECT TOP 1 @id = id, @ms_sql = ms_sql FROM @cascade ORDER BY id;',\n      'WHILE @id IS NOT NULL',\n      'BEGIN',\n      'BEGIN TRY EXEC sp_executesql @ms_sql; END TRY',\n      'BEGIN CATCH BREAK; THROW; END CATCH;',\n      'DELETE FROM @cascade WHERE id = @id;',\n      'SELECT @id = NULL, @ms_sql = NULL;',\n      'SELECT TOP 1 @id = id, @ms_sql = ms_sql FROM @cascade ORDER BY id;',\n      'END',\n      'EXEC sp_executesql N\\'DROP SCHEMA', this.quoteIdentifier(schema), ';\\'',\n      'END;',\n    ].join(' ');\n  }\n\n  createTableQuery(tableName, attributes, options) {\n    if (options) {\n      rejectInvalidOptions(\n        'createTableQuery',\n        this.dialect.name,\n        CREATE_TABLE_QUERY_SUPPORTABLE_OPTIONS,\n        CREATE_TABLE_QUERY_SUPPORTED_OPTIONS,\n        options,\n      );\n    }\n\n    const primaryKeys = [];\n    const foreignKeys = {};\n    const attributesClauseParts = [];\n\n    let commentStr = '';\n\n    for (const attr in attributes) {\n      if (Object.hasOwn(attributes, attr)) {\n        let dataType = attributes[attr];\n        let match;\n\n        if (dataType.includes('COMMENT ')) {\n          const commentMatch = dataType.match(/^(.+) (COMMENT.*)$/);\n          const commentText = commentMatch[2].replace('COMMENT', '').trim();\n          commentStr += this.commentTemplate(commentText, tableName, attr);\n          // remove comment related substring from dataType\n          dataType = commentMatch[1];\n        }\n\n        if (dataType.includes('PRIMARY KEY')) {\n          primaryKeys.push(attr);\n\n          if (dataType.includes('REFERENCES')) {\n            // MSSQL doesn't support inline REFERENCES declarations: move to the end\n            match = dataType.match(/^(.+) (REFERENCES.*)$/);\n            attributesClauseParts.push(`${this.quoteIdentifier(attr)} ${match[1].replace('PRIMARY KEY', '')}`);\n            foreignKeys[attr] = match[2];\n          } else {\n            attributesClauseParts.push(`${this.quoteIdentifier(attr)} ${dataType.replace('PRIMARY KEY', '')}`);\n          }\n        } else if (dataType.includes('REFERENCES')) {\n          // MSSQL doesn't support inline REFERENCES declarations: move to the end\n          match = dataType.match(/^(.+) (REFERENCES.*)$/);\n          attributesClauseParts.push(`${this.quoteIdentifier(attr)} ${match[1]}`);\n          foreignKeys[attr] = match[2];\n        } else {\n          attributesClauseParts.push(`${this.quoteIdentifier(attr)} ${dataType}`);\n        }\n      }\n    }\n\n    const pkString = primaryKeys.map(pk => this.quoteIdentifier(pk)).join(', ');\n\n    if (options?.uniqueKeys) {\n      each(options.uniqueKeys, (columns, indexName) => {\n        if (typeof indexName !== 'string') {\n          indexName = generateIndexName(tableName, columns);\n        }\n\n        attributesClauseParts.push(`CONSTRAINT ${\n          this.quoteIdentifier(indexName)\n        } UNIQUE (${\n          columns.fields.map(field => this.quoteIdentifier(field)).join(', ')\n        })`);\n      });\n    }\n\n    if (pkString.length > 0) {\n      attributesClauseParts.push(`PRIMARY KEY (${pkString})`);\n    }\n\n    for (const fkey in foreignKeys) {\n      if (Object.hasOwn(foreignKeys, fkey)) {\n        attributesClauseParts.push(`FOREIGN KEY (${this.quoteIdentifier(fkey)}) ${foreignKeys[fkey]}`);\n      }\n    }\n\n    const quotedTableName = this.quoteTable(tableName);\n\n    return joinSQLFragments([\n      `IF OBJECT_ID(${this.escape(quotedTableName)}, 'U') IS NULL`,\n      `CREATE TABLE ${quotedTableName} (${attributesClauseParts.join(', ')})`,\n      ';',\n      commentStr,\n    ]);\n  }\n\n  renameTableQuery(before, after) {\n    return `EXEC sp_rename ${this.quoteTable(before)}, ${this.quoteTable(after)};`;\n  }\n\n  addColumnQuery(table, key, dataType, options) {\n    if (options) {\n      rejectInvalidOptions(\n        'addColumnQuery',\n        this.dialect.name,\n        ADD_COLUMN_QUERY_SUPPORTABLE_OPTIONS,\n        ADD_COLUMN_QUERY_SUPPORTED_OPTIONS,\n        options,\n      );\n    }\n\n    dataType = {\n      ...dataType,\n      // TODO: attributeToSQL SHOULD be using attributes in addColumnQuery\n      //       but instead we need to pass the key along as the field here\n      field: key,\n      type: normalizeDataType(dataType.type, this.dialect),\n    };\n\n    let commentStr = '';\n\n    if (dataType.comment && isString(dataType.comment)) {\n      commentStr = this.commentTemplate(dataType.comment, table, key);\n      // attributeToSQL will try to include `COMMENT 'Comment Text'` when it returns if the comment key\n      // is present. This is needed for createTable statement where that part is extracted with regex.\n      // Here we can intercept the object and remove comment property since we have the original object.\n      delete dataType.comment;\n    }\n\n    return joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(table),\n      'ADD',\n      this.quoteIdentifier(key),\n      this.attributeToSQL(dataType, { context: 'addColumn' }),\n      ';',\n      commentStr,\n    ]);\n  }\n\n  commentTemplate(comment, table, column) {\n    return ' EXEC sp_addextendedproperty '\n        + `@name = N'MS_Description', @value = ${this.escape(comment)}, `\n        + '@level0type = N\\'Schema\\', @level0name = \\'dbo\\', '\n        + `@level1type = N'Table', @level1name = ${this.quoteTable(table)}, `\n        + `@level2type = N'Column', @level2name = ${this.quoteIdentifier(column)};`;\n  }\n\n  changeColumnQuery(tableName, attributes) {\n    const attrString = [];\n    const constraintString = [];\n    let commentString = '';\n\n    for (const attributeName in attributes) {\n      const quotedAttrName = this.quoteIdentifier(attributeName);\n      let definition = attributes[attributeName];\n      if (definition.includes('COMMENT ')) {\n        const commentMatch = definition.match(/^(.+) (COMMENT.*)$/);\n        const commentText = commentMatch[2].replace('COMMENT', '').trim();\n        commentString += this.commentTemplate(commentText, tableName, attributeName);\n        // remove comment related substring from dataType\n        definition = commentMatch[1];\n      }\n\n      if (definition.includes('REFERENCES')) {\n        constraintString.push(`FOREIGN KEY (${quotedAttrName}) ${definition.replace(/.+?(?=REFERENCES)/, '')}`);\n      } else {\n        attrString.push(`${quotedAttrName} ${definition}`);\n      }\n    }\n\n    return joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(tableName),\n      attrString.length && `ALTER COLUMN ${attrString.join(', ')}`,\n      constraintString.length && `ADD ${constraintString.join(', ')}`,\n      ';',\n      commentString,\n    ]);\n  }\n\n  renameColumnQuery(tableName, attrBefore, attributes) {\n    const newName = Object.keys(attributes)[0];\n\n    return joinSQLFragments([\n      'EXEC sp_rename',\n      `'${this.quoteTable(tableName)}.${attrBefore}',`,\n      `'${newName}',`,\n      '\\'COLUMN\\'',\n      ';',\n    ]);\n  }\n\n  bulkInsertQuery(tableName, attrValueHashes, options, attributes) {\n    const quotedTable = this.quoteTable(tableName);\n    options = options || {};\n    attributes = attributes || {};\n\n    const tuples = [];\n    const allAttributes = [];\n    const allQueries = [];\n\n    let needIdentityInsertWrapper = false;\n    let outputFragment = '';\n\n    if (options.returning) {\n      const returnValues = this.generateReturnValues(attributes, options);\n\n      outputFragment = returnValues.outputFragment;\n    }\n\n    const emptyQuery = `INSERT INTO ${quotedTable}${outputFragment} DEFAULT VALUES`;\n\n    for (const attrValueHash of attrValueHashes) {\n      // special case for empty objects with primary keys\n      const fields = Object.keys(attrValueHash);\n      const firstAttr = attributes[fields[0]];\n      if (fields.length === 1 && firstAttr && firstAttr.autoIncrement && attrValueHash[fields[0]] === null) {\n        allQueries.push(emptyQuery);\n        continue;\n      }\n\n      // normal case\n      forOwn(attrValueHash, (value, key) => {\n        if (value !== null && attributes[key] && attributes[key].autoIncrement) {\n          needIdentityInsertWrapper = true;\n        }\n\n        if (!allAttributes.includes(key)) {\n          if (value === null && attributes[key] && attributes[key].autoIncrement) {\n            return;\n          }\n\n          allAttributes.push(key);\n        }\n      });\n    }\n\n    if (allAttributes.length > 0) {\n      for (const attrValueHash of attrValueHashes) {\n        tuples.push(`(${\n          allAttributes.map(key => {\n            // TODO: bindParam\n            // TODO: pass \"model\"\n            return this.escape(attrValueHash[key] ?? null, {\n              type: attributes[key]?.type,\n              replacements: options.replacements,\n            });\n          }).join(',')\n        })`);\n      }\n\n      const quotedAttributes = allAttributes.map(attr => this.quoteIdentifier(attr)).join(',');\n      allQueries.push(tupleStr => `INSERT INTO ${quotedTable} (${quotedAttributes})${outputFragment} VALUES ${tupleStr}`);\n    }\n\n    const commands = [];\n    let offset = 0;\n    while (offset < Math.max(tuples.length, 1)) {\n      // SQL Server can insert a maximum of 1000 rows at a time,\n      // This splits the insert in multiple statements to respect that limit\n      const tupleStr = tuples.slice(offset, Math.min(tuples.length, offset + 1000));\n      let generatedQuery = allQueries.map(v => (typeof v === 'string' ? v : v(tupleStr))).join(';');\n      if (needIdentityInsertWrapper) {\n        generatedQuery = `SET IDENTITY_INSERT ${quotedTable} ON; ${generatedQuery}; SET IDENTITY_INSERT ${quotedTable} OFF`;\n      }\n\n      commands.push(generatedQuery);\n      offset += 1000;\n    }\n\n    return `${commands.join(';')};`;\n  }\n\n  updateQuery(tableName, attrValueHash, where, options = {}, attributes) {\n    const sql = super.updateQuery(tableName, attrValueHash, where, options, attributes);\n\n    if (options.limit) {\n      const updateArgs = `UPDATE TOP(${this.escape(options.limit, undefined, options)})`;\n      sql.query = sql.query.replace('UPDATE', updateArgs);\n    }\n\n    return sql;\n  }\n\n  upsertQuery(tableName, insertValues, updateValues, where, model, options) {\n    // TODO: support TableNameWithSchema objects\n    const targetTableAlias = this.quoteTable(`${tableName}_target`);\n    const sourceTableAlias = this.quoteTable(`${tableName}_source`);\n    const primaryKeysColumns = [];\n    const identityColumns = [];\n    const uniqueColumns = [];\n    const tableNameQuoted = this.quoteTable(tableName);\n    let needIdentityInsertWrapper = false;\n\n    const modelDefinition = model.modelDefinition;\n    // Obtain primaryKeys, uniquekeys and identity attrs from rawAttributes as model is not passed\n    for (const attribute of modelDefinition.attributes.values()) {\n      if (attribute.primaryKey) {\n        primaryKeysColumns.push(attribute.columnName);\n      }\n\n      if (attribute.autoIncrement) {\n        identityColumns.push(attribute.columnName);\n      }\n    }\n\n    // Add unique indexes defined by indexes option to uniqueAttrs\n    for (const index of model.getIndexes()) {\n      if (index.unique && index.fields) {\n        for (const field of index.fields) {\n          const columnName = typeof field === 'string' ? field : field.name || field.attribute;\n          // TODO: columnName can't be used to get an attribute from modelDefinition.attributes, this is a bug\n          if (!uniqueColumns.includes(columnName) && modelDefinition.attributes.has(columnName)) {\n            uniqueColumns.push(columnName);\n          }\n        }\n      }\n    }\n\n    const updateKeys = Object.keys(updateValues);\n    const insertKeys = Object.keys(insertValues);\n    const insertKeysQuoted = insertKeys.map(key => this.quoteIdentifier(key)).join(', ');\n    const insertValuesEscaped = insertKeys.map(key => {\n      // TODO: pass \"model\", \"type\" and \"bindParam\" options\n      return this.escape(insertValues[key], options);\n    }).join(', ');\n    const sourceTableQuery = `VALUES(${insertValuesEscaped})`; // Virtual Table\n    let joinCondition;\n\n    // IDENTITY_INSERT Condition\n    for (const key of identityColumns) {\n      if (insertValues[key] && insertValues[key] !== null) {\n        needIdentityInsertWrapper = true;\n        /*\n         * IDENTITY_INSERT Column Cannot be updated, only inserted\n         * http://stackoverflow.com/a/30176254/2254360\n         */\n      }\n    }\n\n    // Filter NULL Clauses\n    const clauses = where[Op.or].filter(clause => {\n      let valid = true;\n      /*\n       * Exclude NULL Composite PK/UK. Partial Composite clauses should also be excluded as it doesn't guarantee a single row\n       */\n      for (const key of Object.keys(clause)) {\n        if (clause[key] == null) {\n          valid = false;\n          break;\n        }\n      }\n\n      return valid;\n    });\n\n    /*\n     * Generate ON condition using PK(s).\n     * If not, generate using UK(s). Else throw error\n     */\n    const getJoinSnippet = array => {\n      return array.map(key => {\n        key = this.quoteIdentifier(key);\n\n        return `${targetTableAlias}.${key} = ${sourceTableAlias}.${key}`;\n      });\n    };\n\n    if (clauses.length === 0) {\n      throw new Error('Primary Key or Unique key should be passed to upsert query');\n    } else {\n      // Search for primary key attribute in clauses -- Model can have two separate unique keys\n      for (const key in clauses) {\n        const keys = Object.keys(clauses[key]);\n        const columnName = modelDefinition.getColumnNameLoose(keys[0]);\n\n        if (primaryKeysColumns.includes(columnName)) {\n          joinCondition = getJoinSnippet(primaryKeysColumns).join(' AND ');\n          break;\n        }\n      }\n\n      if (!joinCondition) {\n        joinCondition = getJoinSnippet(uniqueColumns).join(' AND ');\n      }\n    }\n\n    // Remove the IDENTITY_INSERT Column from update\n    const filteredUpdateClauses = updateKeys.filter(key => !identityColumns.includes(key))\n      .map(key => {\n        const value = this.escape(updateValues[key], undefined, options);\n        key = this.quoteIdentifier(key);\n\n        return `${targetTableAlias}.${key} = ${value}`;\n      });\n    const updateSnippet = filteredUpdateClauses.length > 0 ? `WHEN MATCHED THEN UPDATE SET ${filteredUpdateClauses.join(', ')}` : '';\n\n    const insertSnippet = `(${insertKeysQuoted}) VALUES(${insertValuesEscaped})`;\n\n    let query = `MERGE INTO ${tableNameQuoted} WITH(HOLDLOCK) AS ${targetTableAlias} USING (${sourceTableQuery}) AS ${sourceTableAlias}(${insertKeysQuoted}) ON ${joinCondition}`;\n    query += ` ${updateSnippet} WHEN NOT MATCHED THEN INSERT ${insertSnippet} OUTPUT $action, INSERTED.*;`;\n    if (needIdentityInsertWrapper) {\n      query = `SET IDENTITY_INSERT ${tableNameQuoted} ON; ${query} SET IDENTITY_INSERT ${tableNameQuoted} OFF;`;\n    }\n\n    return query;\n  }\n\n  truncateTableQuery(tableName) {\n    return `TRUNCATE TABLE ${this.quoteTable(tableName)}`;\n  }\n\n  deleteQuery(tableName, where, options = {}, model) {\n    const table = this.quoteTable(tableName);\n\n    const escapeOptions = { ...options, model };\n    const whereClause = this.whereQuery(where, escapeOptions);\n\n    return joinSQLFragments([\n      'DELETE',\n      options.limit && `TOP(${this.escape(options.limit, escapeOptions)})`,\n      'FROM',\n      table,\n      whereClause,\n      ';',\n      'SELECT @@ROWCOUNT AS AFFECTEDROWS',\n      ';',\n    ]);\n  }\n\n  attributeToSQL(attribute, options) {\n    if (!isPlainObject(attribute)) {\n      attribute = {\n        type: attribute,\n      };\n    }\n\n    // handle self-referential constraints\n    if (attribute.references && attribute.Model && this.isSameTable(attribute.Model.tableName, attribute.references.table)) {\n      this.sequelize.log('MSSQL does not support self-referential constraints, '\n          + 'we will remove it but we recommend restructuring your query');\n      attribute.onDelete = '';\n      attribute.onUpdate = '';\n    }\n\n    let template;\n\n    if (attribute.type instanceof DataTypes.ENUM) {\n      // enums are a special case\n      template = attribute.type.toSql({ dialect: this.dialect });\n      template += ` CHECK (${this.quoteIdentifier(attribute.field)} IN(${attribute.type.options.values.map(value => {\n        return this.escape(value, options);\n      }).join(', ')}))`;\n\n      return template;\n    }\n\n    template = attributeTypeToSql(attribute.type, { dialect: this.dialect });\n\n    if (attribute.allowNull === false) {\n      template += ' NOT NULL';\n    } else if (!attribute.primaryKey && !defaultValueSchemable(attribute.defaultValue)) {\n      template += ' NULL';\n    }\n\n    if (attribute.autoIncrement) {\n      template += ' IDENTITY(1,1)';\n    }\n\n    // Blobs/texts cannot have a defaultValue\n    if (attribute.type !== 'TEXT' && attribute.type._binary !== true\n        && defaultValueSchemable(attribute.defaultValue)) {\n      template += ` DEFAULT ${this.escape(attribute.defaultValue, { ...options, type: attribute.type })}`;\n    }\n\n    if (attribute.unique === true && (options?.context !== 'changeColumn' || this.dialect.supports.alterColumn.unique)) {\n      template += ' UNIQUE';\n    }\n\n    if (attribute.primaryKey) {\n      template += ' PRIMARY KEY';\n    }\n\n    if ((!options || !options.withoutForeignKeyConstraints) && attribute.references) {\n      template += ` REFERENCES ${this.quoteTable(attribute.references.table)}`;\n\n      if (attribute.references.key) {\n        template += ` (${this.quoteIdentifier(attribute.references.key)})`;\n      } else {\n        template += ` (${this.quoteIdentifier('id')})`;\n      }\n\n      if (attribute.onDelete) {\n        template += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;\n      }\n\n      if (attribute.onUpdate) {\n        template += ` ON UPDATE ${attribute.onUpdate.toUpperCase()}`;\n      }\n    }\n\n    if (attribute.comment && typeof attribute.comment === 'string') {\n      template += ` COMMENT ${attribute.comment}`;\n    }\n\n    return template;\n  }\n\n  attributesToSQL(attributes, options) {\n    const result = Object.create(null);\n    const existingConstraints = [];\n\n    for (const key of Object.keys(attributes)) {\n      const attribute = { ...attributes[key] };\n\n      if (attribute.references) {\n        if (existingConstraints.includes(this.quoteTable(attribute.references.table))) {\n          // no cascading constraints to a table more than once\n          attribute.onDelete = '';\n          attribute.onUpdate = '';\n        } else {\n          existingConstraints.push(this.quoteTable(attribute.references.table));\n\n          // NOTE: this really just disables cascading updates for all\n          //       definitions. Can be made more robust to support the\n          //       few cases where MSSQL actually supports them\n          attribute.onUpdate = '';\n        }\n      }\n\n      if (key && !attribute.field) {\n        attribute.field = key;\n      }\n\n      result[attribute.field || key] = this.attributeToSQL(attribute, options);\n    }\n\n    return result;\n  }\n\n  createTrigger() {\n    throwMethodUndefined('createTrigger');\n  }\n\n  dropTrigger() {\n    throwMethodUndefined('dropTrigger');\n  }\n\n  renameTrigger() {\n    throwMethodUndefined('renameTrigger');\n  }\n\n  createFunction() {\n    throwMethodUndefined('createFunction');\n  }\n\n  dropFunction() {\n    throwMethodUndefined('dropFunction');\n  }\n\n  renameFunction() {\n    throwMethodUndefined('renameFunction');\n  }\n\n  setIsolationLevelQuery() {}\n\n  generateTransactionId() {\n    return randomBytes(10).toString('hex');\n  }\n\n  startTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `SAVE TRANSACTION ${this.quoteIdentifier(transaction.name)};`;\n    }\n\n    return 'BEGIN TRANSACTION;';\n  }\n\n  commitTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return;\n    }\n\n    return 'COMMIT TRANSACTION;';\n  }\n\n  rollbackTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `ROLLBACK TRANSACTION ${this.quoteIdentifier(transaction.name)};`;\n    }\n\n    return 'ROLLBACK TRANSACTION;';\n  }\n\n  addLimitAndOffset(options, model) {\n    const offset = options.offset || 0;\n    const isSubQuery = options.subQuery === undefined\n      ? options.hasIncludeWhere || options.hasIncludeRequired || options.hasMultiAssociation\n      : options.subQuery;\n\n    let fragment = '';\n    let orders = {};\n\n    if (options.order) {\n      orders = this.getQueryOrders(options, model, isSubQuery);\n    }\n\n    if (options.limit || options.offset) {\n      // TODO: document why this is adding the primary key of the model in ORDER BY if options.include is set\n      if (!options.order || options.order.length === 0 || options.include && orders.subQueryOrder.length === 0) {\n        let primaryKey = model.primaryKeyField;\n        const tablePkFragment = `${this.quoteTable(options.tableAs || model.name)}.${this.quoteIdentifier(primaryKey)}`;\n        const aliasedAttribute = this._getAliasForFieldFromQueryOptions(primaryKey, options);\n\n        if (aliasedAttribute) {\n          const modelName = this.quoteIdentifier(options.tableAs || model.name);\n          const alias = this._getAliasForField(modelName, aliasedAttribute[1], options);\n\n          primaryKey = alias || aliasedAttribute[1];\n        }\n\n        if (!orders.mainQueryOrder || orders.mainQueryOrder.length === 0) {\n          fragment += ` ORDER BY ${tablePkFragment}`;\n        } else {\n          const orderFieldNames = (options.order || []).map(order => {\n            const value = Array.isArray(order) ? order[0] : order;\n\n            if (value instanceof Col) {\n              return value.identifiers[0];\n            }\n\n            if (value instanceof Literal) {\n              return value.val;\n            }\n\n            return value;\n          });\n          const primaryKeyFieldAlreadyPresent = orderFieldNames.includes(\n            (primaryKey.col || primaryKey),\n          );\n\n          if (!primaryKeyFieldAlreadyPresent) {\n            fragment += options.order && !isSubQuery ? ', ' : ' ORDER BY ';\n            fragment += tablePkFragment;\n          }\n        }\n      }\n\n      if (options.offset || options.limit) {\n        fragment += ` OFFSET ${this.escape(offset, options)} ROWS`;\n      }\n\n      if (options.limit) {\n        fragment += ` FETCH NEXT ${this.escape(options.limit, options)} ROWS ONLY`;\n      }\n    }\n\n    return fragment;\n  }\n}\n"],
  "mappings": "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",
  "names": ["each", "isString", "forOwn", "isPlainObject"]
}
