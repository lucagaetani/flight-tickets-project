{
  "version": 3,
  "sources": ["../../../src/dialects/mssql/data-types.ts"],
  "sourcesContent": ["import NodeUtil from 'node:util';\nimport maxBy from 'lodash/maxBy';\nimport { BaseError } from '../../errors/index.js';\nimport type { Falsy } from '../../generic/falsy.js';\nimport * as BaseTypes from '../abstract/data-types.js';\nimport type { AbstractDialect } from '../abstract/index.js';\n\nfunction removeUnsupportedIntegerOptions(\n  dataType: BaseTypes.BaseIntegerDataType,\n  dialect: AbstractDialect,\n) {\n  if (dataType.options.length != null) {\n    dialect.warnDataTypeIssue(`${dialect.name} does not support '${dataType.constructor.name}' with length specified. This options is ignored.`);\n\n    delete dataType.options.length;\n  }\n}\n\nexport class BLOB extends BaseTypes.BLOB {\n  protected _checkOptionSupport(dialect: AbstractDialect) {\n    super._checkOptionSupport(dialect);\n\n    // tiny = 2^8\n    // regular = 2^16\n    // medium = 2^24\n    // long = 2^32\n    // in mssql, anything above 8000 bytes must be MAX\n\n    if (this.options.length != null && this.options.length.toLowerCase() !== 'tiny') {\n      dialect.warnDataTypeIssue(`${dialect.name}: ${this.getDataTypeId()} cannot limit its size beyond length=tiny. This option is ignored, in favor of the highest size possible.`);\n    }\n  }\n\n  toSql() {\n    if (this.options.length && this.options.length.toLowerCase() === 'tiny') {\n      return 'VARBINARY(256)';\n    }\n\n    return 'VARBINARY(MAX)';\n  }\n}\n\nexport class STRING extends BaseTypes.STRING {\n  toSql() {\n    return `NVARCHAR(${this.options.length ?? 255})`;\n  }\n}\n\nexport class TEXT extends BaseTypes.TEXT {\n  protected _checkOptionSupport(dialect: AbstractDialect) {\n    super._checkOptionSupport(dialect);\n\n    // tiny = 2^8\n    // regular = 2^16\n    // medium = 2^24\n    // long = 2^32\n    // in mssql, anything above 8000 bytes must be MAX\n\n    if (this.options.length != null && this.options.length.toLowerCase() !== 'tiny') {\n      dialect.warnDataTypeIssue(`${dialect.name}: ${this.getDataTypeId()} cannot limit its size beyond length=tiny. This option is ignored, in favor of the highest size possible.`);\n    }\n  }\n\n  toSql() {\n    if (this.options.length && this.options.length.toLowerCase() === 'tiny') {\n      return 'NVARCHAR(256)';\n    }\n\n    return 'NVARCHAR(MAX)';\n  }\n}\n\nexport class BOOLEAN extends BaseTypes.BOOLEAN {\n  escape(value: boolean | Falsy): string {\n    return value ? '1' : '0';\n  }\n\n  toBindableValue(value: boolean | Falsy): unknown {\n    return value ? 1 : 0;\n  }\n\n  toSql() {\n    return 'BIT';\n  }\n}\n\nexport class UUID extends BaseTypes.UUID {\n  toSql() {\n    return 'UNIQUEIDENTIFIER';\n  }\n}\n\nexport class NOW extends BaseTypes.NOW {\n  toSql() {\n    return 'GETDATE()';\n  }\n}\n\nexport class DATE extends BaseTypes.DATE {\n  toSql() {\n    if (this.options.precision != null) {\n      return `DATETIMEOFFSET(${this.options.precision})`;\n    }\n\n    return 'DATETIMEOFFSET';\n  }\n}\n\nexport class TINYINT extends BaseTypes.TINYINT {\n  protected _checkOptionSupport(dialect: AbstractDialect) {\n    super._checkOptionSupport(dialect);\n    removeUnsupportedIntegerOptions(this, dialect);\n  }\n\n  // TODO: add check constraint between -128 & 127 inclusive when the unsigned option is false\n\n  toSql() {\n    if (!this.options.unsigned) {\n      return 'SMALLINT';\n    }\n\n    // tinyint is always unsigned in mssql\n    return 'TINYINT';\n  }\n}\n\nexport class SMALLINT extends BaseTypes.SMALLINT {\n  protected _checkOptionSupport(dialect: AbstractDialect) {\n    super._checkOptionSupport(dialect);\n    removeUnsupportedIntegerOptions(this, dialect);\n  }\n\n  // TODO: add check constraint between 0 & 65535 inclusive when the unsigned option is true\n\n  toSql() {\n    if (this.options.unsigned) {\n      return 'INT';\n    }\n\n    return 'SMALLINT';\n  }\n}\n\nexport class MEDIUMINT extends BaseTypes.MEDIUMINT {\n  protected _checkOptionSupport(dialect: AbstractDialect) {\n    super._checkOptionSupport(dialect);\n    removeUnsupportedIntegerOptions(this, dialect);\n  }\n\n  // TODO: unsigned: add check constraint between 0 & 16777215 inclusive\n  // TODO: signed: add check constraint between -8388608 & 8388607 inclusive\n\n  toSql() {\n    return 'INTEGER';\n  }\n}\n\nexport class INTEGER extends BaseTypes.INTEGER {\n  protected _checkOptionSupport(dialect: AbstractDialect) {\n    super._checkOptionSupport(dialect);\n    removeUnsupportedIntegerOptions(this, dialect);\n  }\n\n  // TODO:add check constraint between 0 & 4294967295 inclusive when the unsigned option is true\n\n  toSql() {\n    if (this.options.unsigned) {\n      return 'BIGINT';\n    }\n\n    return 'INTEGER';\n  }\n}\n\nexport class BIGINT extends BaseTypes.BIGINT {\n  protected _checkOptionSupport(dialect: AbstractDialect) {\n    super._checkOptionSupport(dialect);\n    removeUnsupportedIntegerOptions(this, dialect);\n  }\n}\n\nexport class FLOAT extends BaseTypes.FLOAT {\n  // TODO: add check constraint >= 0 if unsigned is true\n\n  protected getNumberSqlTypeName(): string {\n    return 'REAL';\n  }\n}\n\nexport class DOUBLE extends BaseTypes.DOUBLE {\n  // TODO: add check constraint >= 0 if unsigned is true\n}\n\nexport class DECIMAL extends BaseTypes.DECIMAL {\n  // TODO: add check constraint >= 0 if unsigned is true\n}\n\n// https://learn.microsoft.com/en-us/sql/relational-databases/json/json-data-sql-server?view=sql-server-ver16\nexport class JSON extends BaseTypes.JSON {\n  // TODO: add constraint\n  //  https://learn.microsoft.com/en-us/sql/t-sql/functions/isjson-transact-sql?view=sql-server-ver16\n\n  toBindableValue(value: any): string {\n    return globalThis.JSON.stringify(value);\n  }\n\n  parseDatabaseValue(value: unknown): unknown {\n    if (typeof value !== 'string') {\n\n      throw new BaseError(`DataTypes.JSON received a non-string value from the database, which it cannot parse: ${NodeUtil.inspect(value)}.`);\n    }\n\n    try {\n      return globalThis.JSON.parse(value);\n    } catch (error) {\n      throw new BaseError(`DataTypes.JSON received a value from the database that it not valid JSON: ${NodeUtil.inspect(value)}.`, { cause: error });\n    }\n  }\n\n  toSql() {\n    return 'NVARCHAR(MAX)';\n  }\n}\n\nexport class ENUM<Member extends string> extends BaseTypes.ENUM<Member> {\n  // TODO: add constraint\n\n  toSql() {\n    const minLength = maxBy(this.options.values, value => value.length)?.length ?? 0;\n\n    // mssql does not have an ENUM type, we use NVARCHAR instead.\n    // It is not possible to create an index on NVARCHAR(MAX), so we use 255 which should be plenty for everyone\n    // but just in case, we also increase the length if the longest value is longer than 255 characters\n    return `NVARCHAR(${Math.max(minLength, 255)})`;\n  }\n}\n"],
  "mappings": "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",
  "names": ["NodeUtil", "maxBy"]
}
