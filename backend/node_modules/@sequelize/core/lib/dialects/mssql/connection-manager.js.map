{
  "version": 3,
  "sources": ["../../../src/dialects/mssql/connection-manager.ts"],
  "sourcesContent": ["import type { Connection as TediousConnection, ConnectionConfig as TediousConnectionConfig } from 'tedious';\nimport {\n  AccessDeniedError,\n  ConnectionError,\n  ConnectionRefusedError,\n  HostNotFoundError,\n  HostNotReachableError,\n  InvalidConnectionError,\n} from '../../errors/index.js';\nimport type { ConnectionOptions, Sequelize } from '../../sequelize.js';\nimport { assertCaughtError, isErrorWithStringCode, isPlainObject } from '../../utils/check.js';\nimport { logger } from '../../utils/logger';\nimport type { Connection } from '../abstract/connection-manager';\nimport { AbstractConnectionManager } from '../abstract/connection-manager';\nimport { AsyncQueue } from './async-queue';\nimport type { MssqlDialect } from './index.js';\n\nconst debug = logger.debugContext('connection:mssql');\nconst debugTedious = logger.debugContext('connection:mssql:tedious');\n\n// TODO: once the code has been split into packages, we won't need to lazy load this anymore\n// eslint-disable-next-line @typescript-eslint/consistent-type-imports\ntype Lib = typeof import('tedious');\n\ninterface TediousConnectionState {\n  name: string;\n}\n\nexport interface MsSqlConnection extends Connection, TediousConnection {\n  // custom properties we attach to the connection\n  // TODO: replace with Symbols.\n  queue: AsyncQueue;\n  lib: Lib;\n\n  // undeclared tedious properties\n  closed: boolean;\n  loggedIn: boolean;\n  state: TediousConnectionState;\n  // on prototype\n  STATE: Record<string, TediousConnectionState>;\n}\n\nexport class MsSqlConnectionManager extends AbstractConnectionManager<MsSqlConnection> {\n  lib: Lib;\n\n  constructor(dialect: MssqlDialect, sequelize: Sequelize) {\n    super(dialect, sequelize);\n    this.lib = this._loadDialectModule('tedious') as Lib;\n  }\n\n  async connect(config: ConnectionOptions): Promise<MsSqlConnection> {\n    const options: TediousConnectionConfig['options'] = {\n      port: typeof config.port === 'string' ? Number.parseInt(config.port, 10) : config.port,\n      database: config.database,\n      trustServerCertificate: true,\n    };\n\n    const authentication: TediousConnectionConfig['authentication'] = {\n      type: 'default',\n      options: {\n        userName: config.username || undefined,\n        password: config.password || undefined,\n      },\n    };\n\n    if (config.dialectOptions) {\n      // only set port if no instance name was provided\n      if (\n        isPlainObject(config.dialectOptions.options)\n        && config.dialectOptions.options.instanceName\n      ) {\n        delete options.port;\n      }\n\n      if (config.dialectOptions.authentication) {\n        Object.assign(authentication, config.dialectOptions.authentication);\n      }\n\n      Object.assign(options, config.dialectOptions.options);\n    }\n\n    const connectionConfig: TediousConnectionConfig = {\n      server: config.host,\n      authentication,\n      options,\n    };\n\n    try {\n      return await new Promise((resolve, reject) => {\n        const connection: MsSqlConnection = new this.lib.Connection(connectionConfig) as MsSqlConnection;\n        if (connection.state === connection.STATE.INITIALIZED) {\n          connection.connect();\n        }\n\n        connection.queue = new AsyncQueue();\n        connection.lib = this.lib;\n\n        const connectHandler = (error: unknown) => {\n          connection.removeListener('end', endHandler);\n          connection.removeListener('error', errorHandler);\n\n          if (error) {\n            return void reject(error);\n          }\n\n          debug('connection acquired');\n          resolve(connection);\n        };\n\n        const endHandler = () => {\n          connection.removeListener('connect', connectHandler);\n          connection.removeListener('error', errorHandler);\n          reject(new Error('Connection was closed by remote server'));\n        };\n\n        const errorHandler = (error: unknown) => {\n          connection.removeListener('connect', connectHandler);\n          connection.removeListener('end', endHandler);\n          reject(error);\n        };\n\n        connection.once('error', errorHandler);\n        connection.once('end', endHandler);\n        connection.once('connect', connectHandler);\n\n        /*\n         * Permanently attach this event before connection is even acquired\n         * tedious sometime emits error even after connect(with error).\n         *\n         * If we dont attach this even that unexpected error event will crash node process\n         *\n         * E.g. connectTimeout is set higher than requestTimeout\n         */\n        connection.on('error', (error: unknown) => {\n          if (isErrorWithStringCode(error) && (error.code === 'ESOCKET' || error.code === 'ECONNRESET')) {\n            void this.pool.destroy(connection);\n          }\n        });\n\n        if (config.dialectOptions && config.dialectOptions.debug) {\n          connection.on('debug', debugTedious.log.bind(debugTedious));\n        }\n      });\n    } catch (error: unknown) {\n      assertCaughtError(error);\n\n      if (!isErrorWithStringCode(error)) {\n        throw new ConnectionError(error);\n      }\n\n      switch (error.code) {\n        case 'ESOCKET':\n          if (error.message.includes('connect EHOSTUNREACH')) {\n            throw new HostNotReachableError(error);\n          }\n\n          if (error.message.includes('connect ENETUNREACH')) {\n            throw new HostNotReachableError(error);\n          }\n\n          if (error.message.includes('connect EADDRNOTAVAIL')) {\n            throw new HostNotReachableError(error);\n          }\n\n          if (error.message.includes('getaddrinfo ENOTFOUND')) {\n            throw new HostNotFoundError(error);\n          }\n\n          if (error.message.includes('connect ECONNREFUSED')) {\n            throw new ConnectionRefusedError(error);\n          }\n\n          throw new ConnectionError(error);\n        case 'ER_ACCESS_DENIED_ERROR':\n        case 'ELOGIN':\n          throw new AccessDeniedError(error);\n        case 'EINVAL':\n          throw new InvalidConnectionError(error);\n        default:\n          throw new ConnectionError(error);\n      }\n    }\n  }\n\n  async disconnect(connection: MsSqlConnection): Promise<void> {\n    // Don't disconnect a connection that is already disconnected\n    if (connection.closed) {\n      return;\n    }\n\n    connection.queue.close();\n\n    await new Promise<void>(resolve => {\n      connection.on('end', resolve);\n      connection.close();\n      debug('connection closed');\n    });\n  }\n\n  validate(connection: MsSqlConnection) {\n    return connection && (connection.loggedIn || connection.state.name === 'LoggedIn');\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
